
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Authenticator
 * 
 */
export type Authenticator = $Result.DefaultSelection<Prisma.$AuthenticatorPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model Sector
 * 
 */
export type Sector = $Result.DefaultSelection<Prisma.$SectorPayload>
/**
 * Model Trade
 * 
 */
export type Trade = $Result.DefaultSelection<Prisma.$TradePayload>
/**
 * Model ClassRoom
 * 
 */
export type ClassRoom = $Result.DefaultSelection<Prisma.$ClassRoomPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model SubClass
 * 
 */
export type SubClass = $Result.DefaultSelection<Prisma.$SubClassPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model LearningOutcome
 * 
 */
export type LearningOutcome = $Result.DefaultSelection<Prisma.$LearningOutcomePayload>
/**
 * Model IndicativeContent
 * 
 */
export type IndicativeContent = $Result.DefaultSelection<Prisma.$IndicativeContentPayload>
/**
 * Model Knowledge
 * 
 */
export type Knowledge = $Result.DefaultSelection<Prisma.$KnowledgePayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model Attitude
 * 
 */
export type Attitude = $Result.DefaultSelection<Prisma.$AttitudePayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Competence
 * 
 */
export type Competence = $Result.DefaultSelection<Prisma.$CompetencePayload>
/**
 * Model PerformanceCriteria
 * 
 */
export type PerformanceCriteria = $Result.DefaultSelection<Prisma.$PerformanceCriteriaPayload>
/**
 * Model Assessment
 * 
 */
export type Assessment = $Result.DefaultSelection<Prisma.$AssessmentPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  TEACHER: 'TEACHER',
  SCHOOLSTAFF: 'SCHOOLSTAFF',
  ADMIN: 'ADMIN',
  PARENT: 'PARENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ClassRoomType: {
  DEFAULT: 'DEFAULT',
  OTHER: 'OTHER'
};

export type ClassRoomType = (typeof ClassRoomType)[keyof typeof ClassRoomType]


export const ClassType: {
  SCHOOLCLASS: 'SCHOOLCLASS',
  PRIVET: 'PRIVET',
  PUBLIC: 'PUBLIC'
};

export type ClassType = (typeof ClassType)[keyof typeof ClassType]


export const PostRole: {
  NOTES: 'NOTES',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  POST: 'POST',
  ACTIVITY: 'ACTIVITY',
  TEXT: 'TEXT'
};

export type PostRole = (typeof PostRole)[keyof typeof PostRole]


export const SubjectType: {
  GENERAL: 'GENERAL'
};

export type SubjectType = (typeof SubjectType)[keyof typeof SubjectType]


export const ResourceType: {
  EQUIPMENT: 'EQUIPMENT',
  MATERIAL: 'MATERIAL',
  TOOLS: 'TOOLS'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const AssessmentType: {
  FORMATIVE: 'FORMATIVE',
  SUMMATIVE: 'SUMMATIVE'
};

export type AssessmentType = (typeof AssessmentType)[keyof typeof AssessmentType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ClassRoomType = $Enums.ClassRoomType

export const ClassRoomType: typeof $Enums.ClassRoomType

export type ClassType = $Enums.ClassType

export const ClassType: typeof $Enums.ClassType

export type PostRole = $Enums.PostRole

export const PostRole: typeof $Enums.PostRole

export type SubjectType = $Enums.SubjectType

export const SubjectType: typeof $Enums.SubjectType

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type AssessmentType = $Enums.AssessmentType

export const AssessmentType: typeof $Enums.AssessmentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authenticator`: Exposes CRUD operations for the **Authenticator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authenticators
    * const authenticators = await prisma.authenticator.findMany()
    * ```
    */
  get authenticator(): Prisma.AuthenticatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sector`: Exposes CRUD operations for the **Sector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sector.findMany()
    * ```
    */
  get sector(): Prisma.SectorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trade`: Exposes CRUD operations for the **Trade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trade.findMany()
    * ```
    */
  get trade(): Prisma.TradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classRoom`: Exposes CRUD operations for the **ClassRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassRooms
    * const classRooms = await prisma.classRoom.findMany()
    * ```
    */
  get classRoom(): Prisma.ClassRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subClass`: Exposes CRUD operations for the **SubClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubClasses
    * const subClasses = await prisma.subClass.findMany()
    * ```
    */
  get subClass(): Prisma.SubClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningOutcome`: Exposes CRUD operations for the **LearningOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningOutcomes
    * const learningOutcomes = await prisma.learningOutcome.findMany()
    * ```
    */
  get learningOutcome(): Prisma.LearningOutcomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicativeContent`: Exposes CRUD operations for the **IndicativeContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicativeContents
    * const indicativeContents = await prisma.indicativeContent.findMany()
    * ```
    */
  get indicativeContent(): Prisma.IndicativeContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledge`: Exposes CRUD operations for the **Knowledge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Knowledges
    * const knowledges = await prisma.knowledge.findMany()
    * ```
    */
  get knowledge(): Prisma.KnowledgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attitude`: Exposes CRUD operations for the **Attitude** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attitudes
    * const attitudes = await prisma.attitude.findMany()
    * ```
    */
  get attitude(): Prisma.AttitudeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.competence`: Exposes CRUD operations for the **Competence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Competences
    * const competences = await prisma.competence.findMany()
    * ```
    */
  get competence(): Prisma.CompetenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceCriteria`: Exposes CRUD operations for the **PerformanceCriteria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceCriteria
    * const performanceCriteria = await prisma.performanceCriteria.findMany()
    * ```
    */
  get performanceCriteria(): Prisma.PerformanceCriteriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessment`: Exposes CRUD operations for the **Assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.AssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Authenticator: 'Authenticator',
    Education: 'Education',
    Sector: 'Sector',
    Trade: 'Trade',
    ClassRoom: 'ClassRoom',
    Class: 'Class',
    SubClass: 'SubClass',
    Student: 'Student',
    Teacher: 'Teacher',
    Post: 'Post',
    Subject: 'Subject',
    LearningOutcome: 'LearningOutcome',
    IndicativeContent: 'IndicativeContent',
    Knowledge: 'Knowledge',
    Skill: 'Skill',
    Attitude: 'Attitude',
    Resource: 'Resource',
    Competence: 'Competence',
    PerformanceCriteria: 'PerformanceCriteria',
    Assessment: 'Assessment',
    Note: 'Note',
    Model: 'Model'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "authenticator" | "education" | "sector" | "trade" | "classRoom" | "class" | "subClass" | "student" | "teacher" | "post" | "subject" | "learningOutcome" | "indicativeContent" | "knowledge" | "skill" | "attitude" | "resource" | "competence" | "performanceCriteria" | "assessment" | "note" | "model"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationTokenFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationTokenAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Authenticator: {
        payload: Prisma.$AuthenticatorPayload<ExtArgs>
        fields: Prisma.AuthenticatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthenticatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthenticatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findFirst: {
            args: Prisma.AuthenticatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthenticatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findMany: {
            args: Prisma.AuthenticatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          create: {
            args: Prisma.AuthenticatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          createMany: {
            args: Prisma.AuthenticatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthenticatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          update: {
            args: Prisma.AuthenticatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          deleteMany: {
            args: Prisma.AuthenticatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthenticatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthenticatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          aggregate: {
            args: Prisma.AuthenticatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthenticator>
          }
          groupBy: {
            args: Prisma.AuthenticatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AuthenticatorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AuthenticatorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AuthenticatorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EducationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EducationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      Sector: {
        payload: Prisma.$SectorPayload<ExtArgs>
        fields: Prisma.SectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findFirst: {
            args: Prisma.SectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findMany: {
            args: Prisma.SectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>[]
          }
          create: {
            args: Prisma.SectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          createMany: {
            args: Prisma.SectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          update: {
            args: Prisma.SectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          deleteMany: {
            args: Prisma.SectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          aggregate: {
            args: Prisma.SectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSector>
          }
          groupBy: {
            args: Prisma.SectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SectorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SectorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SectorCountArgs<ExtArgs>
            result: $Utils.Optional<SectorCountAggregateOutputType> | number
          }
        }
      }
      Trade: {
        payload: Prisma.$TradePayload<ExtArgs>
        fields: Prisma.TradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findFirst: {
            args: Prisma.TradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findMany: {
            args: Prisma.TradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          create: {
            args: Prisma.TradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          createMany: {
            args: Prisma.TradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          update: {
            args: Prisma.TradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          deleteMany: {
            args: Prisma.TradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          aggregate: {
            args: Prisma.TradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrade>
          }
          groupBy: {
            args: Prisma.TradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TradeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TradeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TradeCountArgs<ExtArgs>
            result: $Utils.Optional<TradeCountAggregateOutputType> | number
          }
        }
      }
      ClassRoom: {
        payload: Prisma.$ClassRoomPayload<ExtArgs>
        fields: Prisma.ClassRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          findFirst: {
            args: Prisma.ClassRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          findMany: {
            args: Prisma.ClassRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>[]
          }
          create: {
            args: Prisma.ClassRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          createMany: {
            args: Prisma.ClassRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          update: {
            args: Prisma.ClassRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          deleteMany: {
            args: Prisma.ClassRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassRoomPayload>
          }
          aggregate: {
            args: Prisma.ClassRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassRoom>
          }
          groupBy: {
            args: Prisma.ClassRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassRoomGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClassRoomFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClassRoomAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClassRoomCountArgs<ExtArgs>
            result: $Utils.Optional<ClassRoomCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClassFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClassAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      SubClass: {
        payload: Prisma.$SubClassPayload<ExtArgs>
        fields: Prisma.SubClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          findFirst: {
            args: Prisma.SubClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          findMany: {
            args: Prisma.SubClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>[]
          }
          create: {
            args: Prisma.SubClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          createMany: {
            args: Prisma.SubClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          update: {
            args: Prisma.SubClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          deleteMany: {
            args: Prisma.SubClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubClassPayload>
          }
          aggregate: {
            args: Prisma.SubClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubClass>
          }
          groupBy: {
            args: Prisma.SubClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubClassGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubClassFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubClassAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubClassCountArgs<ExtArgs>
            result: $Utils.Optional<SubClassCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeacherFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeacherAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      LearningOutcome: {
        payload: Prisma.$LearningOutcomePayload<ExtArgs>
        fields: Prisma.LearningOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          findFirst: {
            args: Prisma.LearningOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          findMany: {
            args: Prisma.LearningOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>[]
          }
          create: {
            args: Prisma.LearningOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          createMany: {
            args: Prisma.LearningOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LearningOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          update: {
            args: Prisma.LearningOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          deleteMany: {
            args: Prisma.LearningOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningOutcomePayload>
          }
          aggregate: {
            args: Prisma.LearningOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningOutcome>
          }
          groupBy: {
            args: Prisma.LearningOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningOutcomeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LearningOutcomeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LearningOutcomeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LearningOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<LearningOutcomeCountAggregateOutputType> | number
          }
        }
      }
      IndicativeContent: {
        payload: Prisma.$IndicativeContentPayload<ExtArgs>
        fields: Prisma.IndicativeContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicativeContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicativeContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          findFirst: {
            args: Prisma.IndicativeContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicativeContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          findMany: {
            args: Prisma.IndicativeContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>[]
          }
          create: {
            args: Prisma.IndicativeContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          createMany: {
            args: Prisma.IndicativeContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IndicativeContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          update: {
            args: Prisma.IndicativeContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          deleteMany: {
            args: Prisma.IndicativeContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicativeContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicativeContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicativeContentPayload>
          }
          aggregate: {
            args: Prisma.IndicativeContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicativeContent>
          }
          groupBy: {
            args: Prisma.IndicativeContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicativeContentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IndicativeContentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IndicativeContentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IndicativeContentCountArgs<ExtArgs>
            result: $Utils.Optional<IndicativeContentCountAggregateOutputType> | number
          }
        }
      }
      Knowledge: {
        payload: Prisma.$KnowledgePayload<ExtArgs>
        fields: Prisma.KnowledgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findMany: {
            args: Prisma.KnowledgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>[]
          }
          create: {
            args: Prisma.KnowledgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          createMany: {
            args: Prisma.KnowledgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KnowledgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          update: {
            args: Prisma.KnowledgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledge>
          }
          groupBy: {
            args: Prisma.KnowledgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.KnowledgeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.KnowledgeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.KnowledgeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SkillFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SkillAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      Attitude: {
        payload: Prisma.$AttitudePayload<ExtArgs>
        fields: Prisma.AttitudeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttitudeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttitudeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          findFirst: {
            args: Prisma.AttitudeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttitudeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          findMany: {
            args: Prisma.AttitudeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>[]
          }
          create: {
            args: Prisma.AttitudeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          createMany: {
            args: Prisma.AttitudeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttitudeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          update: {
            args: Prisma.AttitudeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          deleteMany: {
            args: Prisma.AttitudeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttitudeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttitudeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttitudePayload>
          }
          aggregate: {
            args: Prisma.AttitudeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttitude>
          }
          groupBy: {
            args: Prisma.AttitudeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttitudeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttitudeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttitudeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttitudeCountArgs<ExtArgs>
            result: $Utils.Optional<AttitudeCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ResourceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ResourceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Competence: {
        payload: Prisma.$CompetencePayload<ExtArgs>
        fields: Prisma.CompetenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          findFirst: {
            args: Prisma.CompetenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          findMany: {
            args: Prisma.CompetenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>[]
          }
          create: {
            args: Prisma.CompetenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          createMany: {
            args: Prisma.CompetenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompetenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          update: {
            args: Prisma.CompetenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          deleteMany: {
            args: Prisma.CompetenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          aggregate: {
            args: Prisma.CompetenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetence>
          }
          groupBy: {
            args: Prisma.CompetenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetenceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CompetenceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CompetenceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CompetenceCountArgs<ExtArgs>
            result: $Utils.Optional<CompetenceCountAggregateOutputType> | number
          }
        }
      }
      PerformanceCriteria: {
        payload: Prisma.$PerformanceCriteriaPayload<ExtArgs>
        fields: Prisma.PerformanceCriteriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceCriteriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceCriteriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          findFirst: {
            args: Prisma.PerformanceCriteriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceCriteriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          findMany: {
            args: Prisma.PerformanceCriteriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>[]
          }
          create: {
            args: Prisma.PerformanceCriteriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          createMany: {
            args: Prisma.PerformanceCriteriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PerformanceCriteriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          update: {
            args: Prisma.PerformanceCriteriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceCriteriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceCriteriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceCriteriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCriteriaPayload>
          }
          aggregate: {
            args: Prisma.PerformanceCriteriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceCriteria>
          }
          groupBy: {
            args: Prisma.PerformanceCriteriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCriteriaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PerformanceCriteriaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PerformanceCriteriaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PerformanceCriteriaCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCriteriaCountAggregateOutputType> | number
          }
        }
      }
      Assessment: {
        payload: Prisma.$AssessmentPayload<ExtArgs>
        fields: Prisma.AssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findMany: {
            args: Prisma.AssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          create: {
            args: Prisma.AssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          createMany: {
            args: Prisma.AssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          update: {
            args: Prisma.AssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.AssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AssessmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AssessmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NoteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NoteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    authenticator?: AuthenticatorOmit
    education?: EducationOmit
    sector?: SectorOmit
    trade?: TradeOmit
    classRoom?: ClassRoomOmit
    class?: ClassOmit
    subClass?: SubClassOmit
    student?: StudentOmit
    teacher?: TeacherOmit
    post?: PostOmit
    subject?: SubjectOmit
    learningOutcome?: LearningOutcomeOmit
    indicativeContent?: IndicativeContentOmit
    knowledge?: KnowledgeOmit
    skill?: SkillOmit
    attitude?: AttitudeOmit
    resource?: ResourceOmit
    competence?: CompetenceOmit
    performanceCriteria?: PerformanceCriteriaOmit
    assessment?: AssessmentOmit
    note?: NoteOmit
    model?: ModelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    Authenticator: number
    Student: number
    Teacher: number
    Class: number
    Post: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    Authenticator?: boolean | UserCountOutputTypeCountAuthenticatorArgs
    Student?: boolean | UserCountOutputTypeCountStudentArgs
    Teacher?: boolean | UserCountOutputTypeCountTeacherArgs
    Class?: boolean | UserCountOutputTypeCountClassArgs
    Post?: boolean | UserCountOutputTypeCountPostArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type EducationCountOutputType
   */

  export type EducationCountOutputType = {
    Sector: number
    Trade: number
  }

  export type EducationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sector?: boolean | EducationCountOutputTypeCountSectorArgs
    Trade?: boolean | EducationCountOutputTypeCountTradeArgs
  }

  // Custom InputTypes
  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationCountOutputType
     */
    select?: EducationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeCountSectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectorWhereInput
  }

  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeCountTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }


  /**
   * Count Type SectorCountOutputType
   */

  export type SectorCountOutputType = {
    ClassRoom: number
    Class: number
  }

  export type SectorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ClassRoom?: boolean | SectorCountOutputTypeCountClassRoomArgs
    Class?: boolean | SectorCountOutputTypeCountClassArgs
  }

  // Custom InputTypes
  /**
   * SectorCountOutputType without action
   */
  export type SectorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectorCountOutputType
     */
    select?: SectorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectorCountOutputType without action
   */
  export type SectorCountOutputTypeCountClassRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassRoomWhereInput
  }

  /**
   * SectorCountOutputType without action
   */
  export type SectorCountOutputTypeCountClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type TradeCountOutputType
   */

  export type TradeCountOutputType = {
    ClassRoom: number
    Class: number
  }

  export type TradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ClassRoom?: boolean | TradeCountOutputTypeCountClassRoomArgs
    Class?: boolean | TradeCountOutputTypeCountClassArgs
  }

  // Custom InputTypes
  /**
   * TradeCountOutputType without action
   */
  export type TradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeCountOutputType
     */
    select?: TradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TradeCountOutputType without action
   */
  export type TradeCountOutputTypeCountClassRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassRoomWhereInput
  }

  /**
   * TradeCountOutputType without action
   */
  export type TradeCountOutputTypeCountClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type ClassRoomCountOutputType
   */

  export type ClassRoomCountOutputType = {
    Class: number
    Subject: number
  }

  export type ClassRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Class?: boolean | ClassRoomCountOutputTypeCountClassArgs
    Subject?: boolean | ClassRoomCountOutputTypeCountSubjectArgs
  }

  // Custom InputTypes
  /**
   * ClassRoomCountOutputType without action
   */
  export type ClassRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoomCountOutputType
     */
    select?: ClassRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassRoomCountOutputType without action
   */
  export type ClassRoomCountOutputTypeCountClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * ClassRoomCountOutputType without action
   */
  export type ClassRoomCountOutputTypeCountSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    Student: number
    SubClass: number
    Post: number
    Subject: number
    Model: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Student?: boolean | ClassCountOutputTypeCountStudentArgs
    SubClass?: boolean | ClassCountOutputTypeCountSubClassArgs
    Post?: boolean | ClassCountOutputTypeCountPostArgs
    Subject?: boolean | ClassCountOutputTypeCountSubjectArgs
    Model?: boolean | ClassCountOutputTypeCountModelArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubClassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    knowledge: number
    Resource: number
    Competence: number
    Assessment: number
    LearningOutcome: number
    IndicativeContent: number
    Skill: number
    Attitude: number
    Note: number
    Model: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | SubjectCountOutputTypeCountKnowledgeArgs
    Resource?: boolean | SubjectCountOutputTypeCountResourceArgs
    Competence?: boolean | SubjectCountOutputTypeCountCompetenceArgs
    Assessment?: boolean | SubjectCountOutputTypeCountAssessmentArgs
    LearningOutcome?: boolean | SubjectCountOutputTypeCountLearningOutcomeArgs
    IndicativeContent?: boolean | SubjectCountOutputTypeCountIndicativeContentArgs
    Skill?: boolean | SubjectCountOutputTypeCountSkillArgs
    Attitude?: boolean | SubjectCountOutputTypeCountAttitudeArgs
    Note?: boolean | SubjectCountOutputTypeCountNoteArgs
    Model?: boolean | SubjectCountOutputTypeCountModelArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountCompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetenceWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountLearningOutcomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningOutcomeWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountIndicativeContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicativeContentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAttitudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttitudeWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }


  /**
   * Count Type LearningOutcomeCountOutputType
   */

  export type LearningOutcomeCountOutputType = {
    indicativeContent: number
  }

  export type LearningOutcomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicativeContent?: boolean | LearningOutcomeCountOutputTypeCountIndicativeContentArgs
  }

  // Custom InputTypes
  /**
   * LearningOutcomeCountOutputType without action
   */
  export type LearningOutcomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcomeCountOutputType
     */
    select?: LearningOutcomeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningOutcomeCountOutputType without action
   */
  export type LearningOutcomeCountOutputTypeCountIndicativeContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicativeContentWhereInput
  }


  /**
   * Count Type CompetenceCountOutputType
   */

  export type CompetenceCountOutputType = {
    PerformanceCriteria: number
  }

  export type CompetenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PerformanceCriteria?: boolean | CompetenceCountOutputTypeCountPerformanceCriteriaArgs
  }

  // Custom InputTypes
  /**
   * CompetenceCountOutputType without action
   */
  export type CompetenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetenceCountOutputType
     */
    select?: CompetenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompetenceCountOutputType without action
   */
  export type CompetenceCountOutputTypeCountPerformanceCriteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCriteriaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole | null
    password: string | null
    username: string | null
    bio: string | null
    age: Date | null
    disabled: boolean | null
    gender: $Enums.Gender | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole | null
    password: string | null
    username: string | null
    bio: string | null
    age: Date | null
    disabled: boolean | null
    gender: $Enums.Gender | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    role: number
    password: number
    username: number
    bio: number
    age: number
    disabled: number
    gender: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    password?: true
    username?: true
    bio?: true
    age?: true
    disabled?: true
    gender?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    password?: true
    username?: true
    bio?: true
    age?: true
    disabled?: true
    gender?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    password?: true
    username?: true
    bio?: true
    age?: true
    disabled?: true
    gender?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole
    password: string | null
    username: string | null
    bio: string | null
    age: Date | null
    disabled: boolean
    gender: $Enums.Gender | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    password?: boolean
    username?: boolean
    bio?: boolean
    age?: boolean
    disabled?: boolean
    gender?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Authenticator?: boolean | User$AuthenticatorArgs<ExtArgs>
    Student?: boolean | User$StudentArgs<ExtArgs>
    Teacher?: boolean | User$TeacherArgs<ExtArgs>
    Class?: boolean | User$ClassArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    password?: boolean
    username?: boolean
    bio?: boolean
    age?: boolean
    disabled?: boolean
    gender?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "role" | "password" | "username" | "bio" | "age" | "disabled" | "gender" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Authenticator?: boolean | User$AuthenticatorArgs<ExtArgs>
    Student?: boolean | User$StudentArgs<ExtArgs>
    Teacher?: boolean | User$TeacherArgs<ExtArgs>
    Class?: boolean | User$ClassArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      Authenticator: Prisma.$AuthenticatorPayload<ExtArgs>[]
      Student: Prisma.$StudentPayload<ExtArgs>[]
      Teacher: Prisma.$TeacherPayload<ExtArgs>[]
      Class: Prisma.$ClassPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      role: $Enums.UserRole
      password: string | null
      username: string | null
      bio: string | null
      age: Date | null
      disabled: boolean
      gender: $Enums.Gender | null
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Authenticator<T extends User$AuthenticatorArgs<ExtArgs> = {}>(args?: Subset<T, User$AuthenticatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Student<T extends User$StudentArgs<ExtArgs> = {}>(args?: Subset<T, User$StudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Teacher<T extends User$TeacherArgs<ExtArgs> = {}>(args?: Subset<T, User$TeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Class<T extends User$ClassArgs<ExtArgs> = {}>(args?: Subset<T, User$ClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Post<T extends User$PostArgs<ExtArgs> = {}>(args?: Subset<T, User$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly age: FieldRef<"User", 'DateTime'>
    readonly disabled: FieldRef<"User", 'Boolean'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.Authenticator
   */
  export type User$AuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    cursor?: AuthenticatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * User.Student
   */
  export type User$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * User.Teacher
   */
  export type User$TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * User.Class
   */
  export type User$ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * User.Post
   */
  export type User$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * @param {VerificationTokenFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerificationTokenFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VerificationToken.
     * @param {VerificationTokenAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationTokenAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken findRaw
   */
  export type VerificationTokenFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationToken aggregateRaw
   */
  export type VerificationTokenAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Authenticator
   */

  export type AggregateAuthenticator = {
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  export type AuthenticatorAvgAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorSumAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorMinAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorMaxAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorCountAggregateOutputType = {
    credentialID: number
    userId: number
    providerAccountId: number
    credentialPublicKey: number
    counter: number
    credentialDeviceType: number
    credentialBackedUp: number
    transports: number
    _all: number
  }


  export type AuthenticatorAvgAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorSumAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorMinAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorMaxAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorCountAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
    _all?: true
  }

  export type AuthenticatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticator to aggregate.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authenticators
    **/
    _count?: true | AuthenticatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthenticatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthenticatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthenticatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type GetAuthenticatorAggregateType<T extends AuthenticatorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthenticator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthenticator[P]>
      : GetScalarType<T[P], AggregateAuthenticator[P]>
  }




  export type AuthenticatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithAggregationInput | AuthenticatorOrderByWithAggregationInput[]
    by: AuthenticatorScalarFieldEnum[] | AuthenticatorScalarFieldEnum
    having?: AuthenticatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthenticatorCountAggregateInputType | true
    _avg?: AuthenticatorAvgAggregateInputType
    _sum?: AuthenticatorSumAggregateInputType
    _min?: AuthenticatorMinAggregateInputType
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type AuthenticatorGroupByOutputType = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports: string | null
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  type GetAuthenticatorGroupByPayload<T extends AuthenticatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthenticatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthenticatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
        }
      >
    >


  export type AuthenticatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>



  export type AuthenticatorSelectScalar = {
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
  }

  export type AuthenticatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"credentialID" | "userId" | "providerAccountId" | "credentialPublicKey" | "counter" | "credentialDeviceType" | "credentialBackedUp" | "transports", ExtArgs["result"]["authenticator"]>
  export type AuthenticatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthenticatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authenticator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      credentialID: string
      userId: string
      providerAccountId: string
      credentialPublicKey: string
      counter: number
      credentialDeviceType: string
      credentialBackedUp: boolean
      transports: string | null
    }, ExtArgs["result"]["authenticator"]>
    composites: {}
  }

  type AuthenticatorGetPayload<S extends boolean | null | undefined | AuthenticatorDefaultArgs> = $Result.GetResult<Prisma.$AuthenticatorPayload, S>

  type AuthenticatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthenticatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthenticatorCountAggregateInputType | true
    }

  export interface AuthenticatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authenticator'], meta: { name: 'Authenticator' } }
    /**
     * Find zero or one Authenticator that matches the filter.
     * @param {AuthenticatorFindUniqueArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthenticatorFindUniqueArgs>(args: SelectSubset<T, AuthenticatorFindUniqueArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Authenticator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthenticatorFindUniqueOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthenticatorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthenticatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Authenticator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthenticatorFindFirstArgs>(args?: SelectSubset<T, AuthenticatorFindFirstArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Authenticator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthenticatorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthenticatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Authenticators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authenticators
     * const authenticators = await prisma.authenticator.findMany()
     * 
     * // Get first 10 Authenticators
     * const authenticators = await prisma.authenticator.findMany({ take: 10 })
     * 
     * // Only select the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.findMany({ select: { credentialID: true } })
     * 
     */
    findMany<T extends AuthenticatorFindManyArgs>(args?: SelectSubset<T, AuthenticatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Authenticator.
     * @param {AuthenticatorCreateArgs} args - Arguments to create a Authenticator.
     * @example
     * // Create one Authenticator
     * const Authenticator = await prisma.authenticator.create({
     *   data: {
     *     // ... data to create a Authenticator
     *   }
     * })
     * 
     */
    create<T extends AuthenticatorCreateArgs>(args: SelectSubset<T, AuthenticatorCreateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Authenticators.
     * @param {AuthenticatorCreateManyArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthenticatorCreateManyArgs>(args?: SelectSubset<T, AuthenticatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authenticator.
     * @param {AuthenticatorDeleteArgs} args - Arguments to delete one Authenticator.
     * @example
     * // Delete one Authenticator
     * const Authenticator = await prisma.authenticator.delete({
     *   where: {
     *     // ... filter to delete one Authenticator
     *   }
     * })
     * 
     */
    delete<T extends AuthenticatorDeleteArgs>(args: SelectSubset<T, AuthenticatorDeleteArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Authenticator.
     * @param {AuthenticatorUpdateArgs} args - Arguments to update one Authenticator.
     * @example
     * // Update one Authenticator
     * const authenticator = await prisma.authenticator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthenticatorUpdateArgs>(args: SelectSubset<T, AuthenticatorUpdateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Authenticators.
     * @param {AuthenticatorDeleteManyArgs} args - Arguments to filter Authenticators to delete.
     * @example
     * // Delete a few Authenticators
     * const { count } = await prisma.authenticator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthenticatorDeleteManyArgs>(args?: SelectSubset<T, AuthenticatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthenticatorUpdateManyArgs>(args: SelectSubset<T, AuthenticatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authenticator.
     * @param {AuthenticatorUpsertArgs} args - Arguments to update or create a Authenticator.
     * @example
     * // Update or create a Authenticator
     * const authenticator = await prisma.authenticator.upsert({
     *   create: {
     *     // ... data to create a Authenticator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authenticator we want to update
     *   }
     * })
     */
    upsert<T extends AuthenticatorUpsertArgs>(args: SelectSubset<T, AuthenticatorUpsertArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Authenticators that matches the filter.
     * @param {AuthenticatorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const authenticator = await prisma.authenticator.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AuthenticatorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Authenticator.
     * @param {AuthenticatorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const authenticator = await prisma.authenticator.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AuthenticatorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorCountArgs} args - Arguments to filter Authenticators to count.
     * @example
     * // Count the number of Authenticators
     * const count = await prisma.authenticator.count({
     *   where: {
     *     // ... the filter for the Authenticators we want to count
     *   }
     * })
    **/
    count<T extends AuthenticatorCountArgs>(
      args?: Subset<T, AuthenticatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthenticatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthenticatorAggregateArgs>(args: Subset<T, AuthenticatorAggregateArgs>): Prisma.PrismaPromise<GetAuthenticatorAggregateType<T>>

    /**
     * Group by Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthenticatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthenticatorGroupByArgs['orderBy'] }
        : { orderBy?: AuthenticatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthenticatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthenticatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authenticator model
   */
  readonly fields: AuthenticatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authenticator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthenticatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authenticator model
   */ 
  interface AuthenticatorFieldRefs {
    readonly credentialID: FieldRef<"Authenticator", 'String'>
    readonly userId: FieldRef<"Authenticator", 'String'>
    readonly providerAccountId: FieldRef<"Authenticator", 'String'>
    readonly credentialPublicKey: FieldRef<"Authenticator", 'String'>
    readonly counter: FieldRef<"Authenticator", 'Int'>
    readonly credentialDeviceType: FieldRef<"Authenticator", 'String'>
    readonly credentialBackedUp: FieldRef<"Authenticator", 'Boolean'>
    readonly transports: FieldRef<"Authenticator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Authenticator findUnique
   */
  export type AuthenticatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findUniqueOrThrow
   */
  export type AuthenticatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findFirst
   */
  export type AuthenticatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findFirstOrThrow
   */
  export type AuthenticatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findMany
   */
  export type AuthenticatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticators to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator create
   */
  export type AuthenticatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Authenticator.
     */
    data: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
  }

  /**
   * Authenticator createMany
   */
  export type AuthenticatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
  }

  /**
   * Authenticator update
   */
  export type AuthenticatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Authenticator.
     */
    data: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
    /**
     * Choose, which Authenticator to update.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator updateMany
   */
  export type AuthenticatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to update.
     */
    limit?: number
  }

  /**
   * Authenticator upsert
   */
  export type AuthenticatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Authenticator to update in case it exists.
     */
    where: AuthenticatorWhereUniqueInput
    /**
     * In case the Authenticator found by the `where` argument doesn't exist, create a new Authenticator with this data.
     */
    create: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
    /**
     * In case the Authenticator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
  }

  /**
   * Authenticator delete
   */
  export type AuthenticatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter which Authenticator to delete.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator deleteMany
   */
  export type AuthenticatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticators to delete
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to delete.
     */
    limit?: number
  }

  /**
   * Authenticator findRaw
   */
  export type AuthenticatorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Authenticator aggregateRaw
   */
  export type AuthenticatorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Authenticator without action
   */
  export type AuthenticatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    name: number
    username: number
    description: number
    symbol: number
    disabled: number
    roles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EducationMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    roles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: string
    name: string
    username: string
    description: string | null
    symbol: string | null
    disabled: boolean
    roles: string[]
    createdAt: Date
    updatedAt: Date
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sector?: boolean | Education$SectorArgs<ExtArgs>
    Trade?: boolean | Education$TradeArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>



  export type EducationSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "description" | "symbol" | "disabled" | "roles" | "createdAt" | "updatedAt", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sector?: boolean | Education$SectorArgs<ExtArgs>
    Trade?: boolean | Education$TradeArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      Sector: Prisma.$SectorPayload<ExtArgs>[]
      Trade: Prisma.$TradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      description: string | null
      symbol: string | null
      disabled: boolean
      roles: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * @param {EducationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const education = await prisma.education.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EducationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Education.
     * @param {EducationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const education = await prisma.education.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EducationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sector<T extends Education$SectorArgs<ExtArgs> = {}>(args?: Subset<T, Education$SectorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Trade<T extends Education$TradeArgs<ExtArgs> = {}>(args?: Subset<T, Education$TradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */ 
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'String'>
    readonly name: FieldRef<"Education", 'String'>
    readonly username: FieldRef<"Education", 'String'>
    readonly description: FieldRef<"Education", 'String'>
    readonly symbol: FieldRef<"Education", 'String'>
    readonly disabled: FieldRef<"Education", 'Boolean'>
    readonly roles: FieldRef<"Education", 'String[]'>
    readonly createdAt: FieldRef<"Education", 'DateTime'>
    readonly updatedAt: FieldRef<"Education", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education findRaw
   */
  export type EducationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Education aggregateRaw
   */
  export type EducationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Education.Sector
   */
  export type Education$SectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    where?: SectorWhereInput
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    cursor?: SectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Education.Trade
   */
  export type Education$TradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model Sector
   */

  export type AggregateSector = {
    _count: SectorCountAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  export type SectorMinAggregateOutputType = {
    id: string | null
    educationId: string | null
    username: string | null
    name: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorMaxAggregateOutputType = {
    id: string | null
    educationId: string | null
    username: string | null
    name: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorCountAggregateOutputType = {
    id: number
    educationId: number
    username: number
    name: number
    description: number
    symbol: number
    disabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectorMinAggregateInputType = {
    id?: true
    educationId?: true
    username?: true
    name?: true
    description?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorMaxAggregateInputType = {
    id?: true
    educationId?: true
    username?: true
    name?: true
    description?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorCountAggregateInputType = {
    id?: true
    educationId?: true
    username?: true
    name?: true
    description?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sector to aggregate.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sectors
    **/
    _count?: true | SectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorMaxAggregateInputType
  }

  export type GetSectorAggregateType<T extends SectorAggregateArgs> = {
        [P in keyof T & keyof AggregateSector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSector[P]>
      : GetScalarType<T[P], AggregateSector[P]>
  }




  export type SectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectorWhereInput
    orderBy?: SectorOrderByWithAggregationInput | SectorOrderByWithAggregationInput[]
    by: SectorScalarFieldEnum[] | SectorScalarFieldEnum
    having?: SectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorCountAggregateInputType | true
    _min?: SectorMinAggregateInputType
    _max?: SectorMaxAggregateInputType
  }

  export type SectorGroupByOutputType = {
    id: string
    educationId: string
    username: string
    name: string
    description: string | null
    symbol: string | null
    disabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: SectorCountAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  type GetSectorGroupByPayload<T extends SectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorGroupByOutputType[P]>
            : GetScalarType<T[P], SectorGroupByOutputType[P]>
        }
      >
    >


  export type SectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    educationId?: boolean
    username?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    education?: boolean | EducationDefaultArgs<ExtArgs>
    ClassRoom?: boolean | Sector$ClassRoomArgs<ExtArgs>
    Class?: boolean | Sector$ClassArgs<ExtArgs>
    _count?: boolean | SectorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sector"]>



  export type SectorSelectScalar = {
    id?: boolean
    educationId?: boolean
    username?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "educationId" | "username" | "name" | "description" | "symbol" | "disabled" | "createdAt" | "updatedAt", ExtArgs["result"]["sector"]>
  export type SectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    education?: boolean | EducationDefaultArgs<ExtArgs>
    ClassRoom?: boolean | Sector$ClassRoomArgs<ExtArgs>
    Class?: boolean | Sector$ClassArgs<ExtArgs>
    _count?: boolean | SectorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sector"
    objects: {
      education: Prisma.$EducationPayload<ExtArgs>
      ClassRoom: Prisma.$ClassRoomPayload<ExtArgs>[]
      Class: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      educationId: string
      username: string
      name: string
      description: string | null
      symbol: string | null
      disabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sector"]>
    composites: {}
  }

  type SectorGetPayload<S extends boolean | null | undefined | SectorDefaultArgs> = $Result.GetResult<Prisma.$SectorPayload, S>

  type SectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectorCountAggregateInputType | true
    }

  export interface SectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sector'], meta: { name: 'Sector' } }
    /**
     * Find zero or one Sector that matches the filter.
     * @param {SectorFindUniqueArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectorFindUniqueArgs>(args: SelectSubset<T, SectorFindUniqueArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sector that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectorFindUniqueOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectorFindUniqueOrThrowArgs>(args: SelectSubset<T, SectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectorFindFirstArgs>(args?: SelectSubset<T, SectorFindFirstArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectorFindFirstOrThrowArgs>(args?: SelectSubset<T, SectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sector.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorWithIdOnly = await prisma.sector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectorFindManyArgs>(args?: SelectSubset<T, SectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sector.
     * @param {SectorCreateArgs} args - Arguments to create a Sector.
     * @example
     * // Create one Sector
     * const Sector = await prisma.sector.create({
     *   data: {
     *     // ... data to create a Sector
     *   }
     * })
     * 
     */
    create<T extends SectorCreateArgs>(args: SelectSubset<T, SectorCreateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sectors.
     * @param {SectorCreateManyArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sector = await prisma.sector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectorCreateManyArgs>(args?: SelectSubset<T, SectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sector.
     * @param {SectorDeleteArgs} args - Arguments to delete one Sector.
     * @example
     * // Delete one Sector
     * const Sector = await prisma.sector.delete({
     *   where: {
     *     // ... filter to delete one Sector
     *   }
     * })
     * 
     */
    delete<T extends SectorDeleteArgs>(args: SelectSubset<T, SectorDeleteArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sector.
     * @param {SectorUpdateArgs} args - Arguments to update one Sector.
     * @example
     * // Update one Sector
     * const sector = await prisma.sector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectorUpdateArgs>(args: SelectSubset<T, SectorUpdateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sectors.
     * @param {SectorDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectorDeleteManyArgs>(args?: SelectSubset<T, SectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sector = await prisma.sector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectorUpdateManyArgs>(args: SelectSubset<T, SectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sector.
     * @param {SectorUpsertArgs} args - Arguments to update or create a Sector.
     * @example
     * // Update or create a Sector
     * const sector = await prisma.sector.upsert({
     *   create: {
     *     // ... data to create a Sector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sector we want to update
     *   }
     * })
     */
    upsert<T extends SectorUpsertArgs>(args: SelectSubset<T, SectorUpsertArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sectors that matches the filter.
     * @param {SectorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sector = await prisma.sector.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SectorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sector.
     * @param {SectorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sector = await prisma.sector.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SectorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sector.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends SectorCountArgs>(
      args?: Subset<T, SectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorAggregateArgs>(args: Subset<T, SectorAggregateArgs>): Prisma.PrismaPromise<GetSectorAggregateType<T>>

    /**
     * Group by Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectorGroupByArgs['orderBy'] }
        : { orderBy?: SectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sector model
   */
  readonly fields: SectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    education<T extends EducationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationDefaultArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ClassRoom<T extends Sector$ClassRoomArgs<ExtArgs> = {}>(args?: Subset<T, Sector$ClassRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Class<T extends Sector$ClassArgs<ExtArgs> = {}>(args?: Subset<T, Sector$ClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sector model
   */ 
  interface SectorFieldRefs {
    readonly id: FieldRef<"Sector", 'String'>
    readonly educationId: FieldRef<"Sector", 'String'>
    readonly username: FieldRef<"Sector", 'String'>
    readonly name: FieldRef<"Sector", 'String'>
    readonly description: FieldRef<"Sector", 'String'>
    readonly symbol: FieldRef<"Sector", 'String'>
    readonly disabled: FieldRef<"Sector", 'Boolean'>
    readonly createdAt: FieldRef<"Sector", 'DateTime'>
    readonly updatedAt: FieldRef<"Sector", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sector findUnique
   */
  export type SectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findUniqueOrThrow
   */
  export type SectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findFirst
   */
  export type SectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findFirstOrThrow
   */
  export type SectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findMany
   */
  export type SectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sectors to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector create
   */
  export type SectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sector.
     */
    data: XOR<SectorCreateInput, SectorUncheckedCreateInput>
  }

  /**
   * Sector createMany
   */
  export type SectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sectors.
     */
    data: SectorCreateManyInput | SectorCreateManyInput[]
  }

  /**
   * Sector update
   */
  export type SectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sector.
     */
    data: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
    /**
     * Choose, which Sector to update.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector updateMany
   */
  export type SectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sectors.
     */
    data: XOR<SectorUpdateManyMutationInput, SectorUncheckedUpdateManyInput>
    /**
     * Filter which Sectors to update
     */
    where?: SectorWhereInput
    /**
     * Limit how many Sectors to update.
     */
    limit?: number
  }

  /**
   * Sector upsert
   */
  export type SectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sector to update in case it exists.
     */
    where: SectorWhereUniqueInput
    /**
     * In case the Sector found by the `where` argument doesn't exist, create a new Sector with this data.
     */
    create: XOR<SectorCreateInput, SectorUncheckedCreateInput>
    /**
     * In case the Sector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
  }

  /**
   * Sector delete
   */
  export type SectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter which Sector to delete.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector deleteMany
   */
  export type SectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sectors to delete
     */
    where?: SectorWhereInput
    /**
     * Limit how many Sectors to delete.
     */
    limit?: number
  }

  /**
   * Sector findRaw
   */
  export type SectorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sector aggregateRaw
   */
  export type SectorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sector.ClassRoom
   */
  export type Sector$ClassRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    where?: ClassRoomWhereInput
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassRoomScalarFieldEnum | ClassRoomScalarFieldEnum[]
  }

  /**
   * Sector.Class
   */
  export type Sector$ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Sector without action
   */
  export type SectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
  }


  /**
   * Model Trade
   */

  export type AggregateTrade = {
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  export type TradeAvgAggregateOutputType = {
    limitClasses: number | null
  }

  export type TradeSumAggregateOutputType = {
    limitClasses: number | null
  }

  export type TradeMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    sectorId: string | null
    limitClasses: number | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    sectorId: string | null
    limitClasses: number | null
    symbol: string | null
    disabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeCountAggregateOutputType = {
    id: number
    name: number
    username: number
    description: number
    sectorId: number
    limitClasses: number
    symbol: number
    disabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradeAvgAggregateInputType = {
    limitClasses?: true
  }

  export type TradeSumAggregateInputType = {
    limitClasses?: true
  }

  export type TradeMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    sectorId?: true
    limitClasses?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    sectorId?: true
    limitClasses?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    sectorId?: true
    limitClasses?: true
    symbol?: true
    disabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trade to aggregate.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trades
    **/
    _count?: true | TradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeMaxAggregateInputType
  }

  export type GetTradeAggregateType<T extends TradeAggregateArgs> = {
        [P in keyof T & keyof AggregateTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrade[P]>
      : GetScalarType<T[P], AggregateTrade[P]>
  }




  export type TradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithAggregationInput | TradeOrderByWithAggregationInput[]
    by: TradeScalarFieldEnum[] | TradeScalarFieldEnum
    having?: TradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeCountAggregateInputType | true
    _avg?: TradeAvgAggregateInputType
    _sum?: TradeSumAggregateInputType
    _min?: TradeMinAggregateInputType
    _max?: TradeMaxAggregateInputType
  }

  export type TradeGroupByOutputType = {
    id: string
    name: string
    username: string
    description: string | null
    sectorId: string
    limitClasses: number
    symbol: string | null
    disabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  type GetTradeGroupByPayload<T extends TradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeGroupByOutputType[P]>
            : GetScalarType<T[P], TradeGroupByOutputType[P]>
        }
      >
    >


  export type TradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    sectorId?: boolean
    limitClasses?: boolean
    symbol?: boolean
    disabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sector?: boolean | EducationDefaultArgs<ExtArgs>
    ClassRoom?: boolean | Trade$ClassRoomArgs<ExtArgs>
    Class?: boolean | Trade$ClassArgs<ExtArgs>
    _count?: boolean | TradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>



  export type TradeSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    sectorId?: boolean
    limitClasses?: boolean
    symbol?: boolean
    disabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "description" | "sectorId" | "limitClasses" | "symbol" | "disabled" | "createdAt" | "updatedAt", ExtArgs["result"]["trade"]>
  export type TradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sector?: boolean | EducationDefaultArgs<ExtArgs>
    ClassRoom?: boolean | Trade$ClassRoomArgs<ExtArgs>
    Class?: boolean | Trade$ClassArgs<ExtArgs>
    _count?: boolean | TradeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trade"
    objects: {
      sector: Prisma.$EducationPayload<ExtArgs>
      ClassRoom: Prisma.$ClassRoomPayload<ExtArgs>[]
      Class: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      description: string | null
      sectorId: string
      limitClasses: number
      symbol: string | null
      disabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trade"]>
    composites: {}
  }

  type TradeGetPayload<S extends boolean | null | undefined | TradeDefaultArgs> = $Result.GetResult<Prisma.$TradePayload, S>

  type TradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeCountAggregateInputType | true
    }

  export interface TradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trade'], meta: { name: 'Trade' } }
    /**
     * Find zero or one Trade that matches the filter.
     * @param {TradeFindUniqueArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeFindUniqueArgs>(args: SelectSubset<T, TradeFindUniqueArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Trade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeFindUniqueOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Trade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeFindFirstArgs>(args?: SelectSubset<T, TradeFindFirstArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Trade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trade.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeWithIdOnly = await prisma.trade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeFindManyArgs>(args?: SelectSubset<T, TradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Trade.
     * @param {TradeCreateArgs} args - Arguments to create a Trade.
     * @example
     * // Create one Trade
     * const Trade = await prisma.trade.create({
     *   data: {
     *     // ... data to create a Trade
     *   }
     * })
     * 
     */
    create<T extends TradeCreateArgs>(args: SelectSubset<T, TradeCreateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Trades.
     * @param {TradeCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeCreateManyArgs>(args?: SelectSubset<T, TradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trade.
     * @param {TradeDeleteArgs} args - Arguments to delete one Trade.
     * @example
     * // Delete one Trade
     * const Trade = await prisma.trade.delete({
     *   where: {
     *     // ... filter to delete one Trade
     *   }
     * })
     * 
     */
    delete<T extends TradeDeleteArgs>(args: SelectSubset<T, TradeDeleteArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Trade.
     * @param {TradeUpdateArgs} args - Arguments to update one Trade.
     * @example
     * // Update one Trade
     * const trade = await prisma.trade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeUpdateArgs>(args: SelectSubset<T, TradeUpdateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Trades.
     * @param {TradeDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeDeleteManyArgs>(args?: SelectSubset<T, TradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trade = await prisma.trade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeUpdateManyArgs>(args: SelectSubset<T, TradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trade.
     * @param {TradeUpsertArgs} args - Arguments to update or create a Trade.
     * @example
     * // Update or create a Trade
     * const trade = await prisma.trade.upsert({
     *   create: {
     *     // ... data to create a Trade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trade we want to update
     *   }
     * })
     */
    upsert<T extends TradeUpsertArgs>(args: SelectSubset<T, TradeUpsertArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Trades that matches the filter.
     * @param {TradeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const trade = await prisma.trade.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TradeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Trade.
     * @param {TradeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const trade = await prisma.trade.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TradeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trade.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends TradeCountArgs>(
      args?: Subset<T, TradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeAggregateArgs>(args: Subset<T, TradeAggregateArgs>): Prisma.PrismaPromise<GetTradeAggregateType<T>>

    /**
     * Group by Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeGroupByArgs['orderBy'] }
        : { orderBy?: TradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trade model
   */
  readonly fields: TradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sector<T extends EducationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationDefaultArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ClassRoom<T extends Trade$ClassRoomArgs<ExtArgs> = {}>(args?: Subset<T, Trade$ClassRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Class<T extends Trade$ClassArgs<ExtArgs> = {}>(args?: Subset<T, Trade$ClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trade model
   */ 
  interface TradeFieldRefs {
    readonly id: FieldRef<"Trade", 'String'>
    readonly name: FieldRef<"Trade", 'String'>
    readonly username: FieldRef<"Trade", 'String'>
    readonly description: FieldRef<"Trade", 'String'>
    readonly sectorId: FieldRef<"Trade", 'String'>
    readonly limitClasses: FieldRef<"Trade", 'Int'>
    readonly symbol: FieldRef<"Trade", 'String'>
    readonly disabled: FieldRef<"Trade", 'Boolean'>
    readonly createdAt: FieldRef<"Trade", 'DateTime'>
    readonly updatedAt: FieldRef<"Trade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trade findUnique
   */
  export type TradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findUniqueOrThrow
   */
  export type TradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findFirst
   */
  export type TradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findFirstOrThrow
   */
  export type TradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findMany
   */
  export type TradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trades to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade create
   */
  export type TradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Trade.
     */
    data: XOR<TradeCreateInput, TradeUncheckedCreateInput>
  }

  /**
   * Trade createMany
   */
  export type TradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
  }

  /**
   * Trade update
   */
  export type TradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Trade.
     */
    data: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
    /**
     * Choose, which Trade to update.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade updateMany
   */
  export type TradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trades.
     */
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyInput>
    /**
     * Filter which Trades to update
     */
    where?: TradeWhereInput
    /**
     * Limit how many Trades to update.
     */
    limit?: number
  }

  /**
   * Trade upsert
   */
  export type TradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Trade to update in case it exists.
     */
    where: TradeWhereUniqueInput
    /**
     * In case the Trade found by the `where` argument doesn't exist, create a new Trade with this data.
     */
    create: XOR<TradeCreateInput, TradeUncheckedCreateInput>
    /**
     * In case the Trade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
  }

  /**
   * Trade delete
   */
  export type TradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter which Trade to delete.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade deleteMany
   */
  export type TradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trades to delete
     */
    where?: TradeWhereInput
    /**
     * Limit how many Trades to delete.
     */
    limit?: number
  }

  /**
   * Trade findRaw
   */
  export type TradeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Trade aggregateRaw
   */
  export type TradeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Trade.ClassRoom
   */
  export type Trade$ClassRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    where?: ClassRoomWhereInput
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassRoomScalarFieldEnum | ClassRoomScalarFieldEnum[]
  }

  /**
   * Trade.Class
   */
  export type Trade$ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Trade without action
   */
  export type TradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
  }


  /**
   * Model ClassRoom
   */

  export type AggregateClassRoom = {
    _count: ClassRoomCountAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  export type ClassRoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    ClassRoomType: $Enums.ClassRoomType | null
    sectorId: string | null
    tradeId: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassRoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    symbol: string | null
    disabled: boolean | null
    ClassRoomType: $Enums.ClassRoomType | null
    sectorId: string | null
    tradeId: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassRoomCountAggregateOutputType = {
    id: number
    name: number
    username: number
    description: number
    symbol: number
    disabled: number
    ClassRoomType: number
    sectorId: number
    tradeId: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassRoomMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    ClassRoomType?: true
    sectorId?: true
    tradeId?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassRoomMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    ClassRoomType?: true
    sectorId?: true
    tradeId?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassRoomCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    symbol?: true
    disabled?: true
    ClassRoomType?: true
    sectorId?: true
    tradeId?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassRoom to aggregate.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassRooms
    **/
    _count?: true | ClassRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassRoomMaxAggregateInputType
  }

  export type GetClassRoomAggregateType<T extends ClassRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassRoom[P]>
      : GetScalarType<T[P], AggregateClassRoom[P]>
  }




  export type ClassRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassRoomWhereInput
    orderBy?: ClassRoomOrderByWithAggregationInput | ClassRoomOrderByWithAggregationInput[]
    by: ClassRoomScalarFieldEnum[] | ClassRoomScalarFieldEnum
    having?: ClassRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassRoomCountAggregateInputType | true
    _min?: ClassRoomMinAggregateInputType
    _max?: ClassRoomMaxAggregateInputType
  }

  export type ClassRoomGroupByOutputType = {
    id: string
    name: string
    username: string
    description: string | null
    symbol: string | null
    disabled: boolean
    ClassRoomType: $Enums.ClassRoomType
    sectorId: string | null
    tradeId: string | null
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassRoomCountAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  type GetClassRoomGroupByPayload<T extends ClassRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
        }
      >
    >


  export type ClassRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    ClassRoomType?: boolean
    sectorId?: boolean
    tradeId?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trade?: boolean | ClassRoom$tradeArgs<ExtArgs>
    sector?: boolean | ClassRoom$sectorArgs<ExtArgs>
    Class?: boolean | ClassRoom$ClassArgs<ExtArgs>
    Subject?: boolean | ClassRoom$SubjectArgs<ExtArgs>
    _count?: boolean | ClassRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classRoom"]>



  export type ClassRoomSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    symbol?: boolean
    disabled?: boolean
    ClassRoomType?: boolean
    sectorId?: boolean
    tradeId?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "description" | "symbol" | "disabled" | "ClassRoomType" | "sectorId" | "tradeId" | "code" | "createdAt" | "updatedAt", ExtArgs["result"]["classRoom"]>
  export type ClassRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trade?: boolean | ClassRoom$tradeArgs<ExtArgs>
    sector?: boolean | ClassRoom$sectorArgs<ExtArgs>
    Class?: boolean | ClassRoom$ClassArgs<ExtArgs>
    Subject?: boolean | ClassRoom$SubjectArgs<ExtArgs>
    _count?: boolean | ClassRoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassRoom"
    objects: {
      trade: Prisma.$TradePayload<ExtArgs> | null
      sector: Prisma.$SectorPayload<ExtArgs> | null
      Class: Prisma.$ClassPayload<ExtArgs>[]
      Subject: Prisma.$SubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      description: string | null
      symbol: string | null
      disabled: boolean
      ClassRoomType: $Enums.ClassRoomType
      sectorId: string | null
      tradeId: string | null
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classRoom"]>
    composites: {}
  }

  type ClassRoomGetPayload<S extends boolean | null | undefined | ClassRoomDefaultArgs> = $Result.GetResult<Prisma.$ClassRoomPayload, S>

  type ClassRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassRoomCountAggregateInputType | true
    }

  export interface ClassRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassRoom'], meta: { name: 'ClassRoom' } }
    /**
     * Find zero or one ClassRoom that matches the filter.
     * @param {ClassRoomFindUniqueArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassRoomFindUniqueArgs>(args: SelectSubset<T, ClassRoomFindUniqueArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ClassRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassRoomFindUniqueOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ClassRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassRoomFindFirstArgs>(args?: SelectSubset<T, ClassRoomFindFirstArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ClassRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassRooms
     * const classRooms = await prisma.classRoom.findMany()
     * 
     * // Get first 10 ClassRooms
     * const classRooms = await prisma.classRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classRoomWithIdOnly = await prisma.classRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassRoomFindManyArgs>(args?: SelectSubset<T, ClassRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ClassRoom.
     * @param {ClassRoomCreateArgs} args - Arguments to create a ClassRoom.
     * @example
     * // Create one ClassRoom
     * const ClassRoom = await prisma.classRoom.create({
     *   data: {
     *     // ... data to create a ClassRoom
     *   }
     * })
     * 
     */
    create<T extends ClassRoomCreateArgs>(args: SelectSubset<T, ClassRoomCreateArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ClassRooms.
     * @param {ClassRoomCreateManyArgs} args - Arguments to create many ClassRooms.
     * @example
     * // Create many ClassRooms
     * const classRoom = await prisma.classRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassRoomCreateManyArgs>(args?: SelectSubset<T, ClassRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassRoom.
     * @param {ClassRoomDeleteArgs} args - Arguments to delete one ClassRoom.
     * @example
     * // Delete one ClassRoom
     * const ClassRoom = await prisma.classRoom.delete({
     *   where: {
     *     // ... filter to delete one ClassRoom
     *   }
     * })
     * 
     */
    delete<T extends ClassRoomDeleteArgs>(args: SelectSubset<T, ClassRoomDeleteArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ClassRoom.
     * @param {ClassRoomUpdateArgs} args - Arguments to update one ClassRoom.
     * @example
     * // Update one ClassRoom
     * const classRoom = await prisma.classRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassRoomUpdateArgs>(args: SelectSubset<T, ClassRoomUpdateArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ClassRooms.
     * @param {ClassRoomDeleteManyArgs} args - Arguments to filter ClassRooms to delete.
     * @example
     * // Delete a few ClassRooms
     * const { count } = await prisma.classRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassRoomDeleteManyArgs>(args?: SelectSubset<T, ClassRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassRooms
     * const classRoom = await prisma.classRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassRoomUpdateManyArgs>(args: SelectSubset<T, ClassRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassRoom.
     * @param {ClassRoomUpsertArgs} args - Arguments to update or create a ClassRoom.
     * @example
     * // Update or create a ClassRoom
     * const classRoom = await prisma.classRoom.upsert({
     *   create: {
     *     // ... data to create a ClassRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassRoom we want to update
     *   }
     * })
     */
    upsert<T extends ClassRoomUpsertArgs>(args: SelectSubset<T, ClassRoomUpsertArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * @param {ClassRoomFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClassRoomFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClassRoom.
     * @param {ClassRoomAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClassRoomAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomCountArgs} args - Arguments to filter ClassRooms to count.
     * @example
     * // Count the number of ClassRooms
     * const count = await prisma.classRoom.count({
     *   where: {
     *     // ... the filter for the ClassRooms we want to count
     *   }
     * })
    **/
    count<T extends ClassRoomCountArgs>(
      args?: Subset<T, ClassRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassRoomAggregateArgs>(args: Subset<T, ClassRoomAggregateArgs>): Prisma.PrismaPromise<GetClassRoomAggregateType<T>>

    /**
     * Group by ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassRoomGroupByArgs['orderBy'] }
        : { orderBy?: ClassRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassRoom model
   */
  readonly fields: ClassRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trade<T extends ClassRoom$tradeArgs<ExtArgs> = {}>(args?: Subset<T, ClassRoom$tradeArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    sector<T extends ClassRoom$sectorArgs<ExtArgs> = {}>(args?: Subset<T, ClassRoom$sectorArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Class<T extends ClassRoom$ClassArgs<ExtArgs> = {}>(args?: Subset<T, ClassRoom$ClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Subject<T extends ClassRoom$SubjectArgs<ExtArgs> = {}>(args?: Subset<T, ClassRoom$SubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassRoom model
   */ 
  interface ClassRoomFieldRefs {
    readonly id: FieldRef<"ClassRoom", 'String'>
    readonly name: FieldRef<"ClassRoom", 'String'>
    readonly username: FieldRef<"ClassRoom", 'String'>
    readonly description: FieldRef<"ClassRoom", 'String'>
    readonly symbol: FieldRef<"ClassRoom", 'String'>
    readonly disabled: FieldRef<"ClassRoom", 'Boolean'>
    readonly ClassRoomType: FieldRef<"ClassRoom", 'ClassRoomType'>
    readonly sectorId: FieldRef<"ClassRoom", 'String'>
    readonly tradeId: FieldRef<"ClassRoom", 'String'>
    readonly code: FieldRef<"ClassRoom", 'String'>
    readonly createdAt: FieldRef<"ClassRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassRoom findUnique
   */
  export type ClassRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom findUniqueOrThrow
   */
  export type ClassRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom findFirst
   */
  export type ClassRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: ClassRoomScalarFieldEnum | ClassRoomScalarFieldEnum[]
  }

  /**
   * ClassRoom findFirstOrThrow
   */
  export type ClassRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: ClassRoomScalarFieldEnum | ClassRoomScalarFieldEnum[]
  }

  /**
   * ClassRoom findMany
   */
  export type ClassRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter, which ClassRooms to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: ClassRoomOrderByWithRelationInput | ClassRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    distinct?: ClassRoomScalarFieldEnum | ClassRoomScalarFieldEnum[]
  }

  /**
   * ClassRoom create
   */
  export type ClassRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassRoom.
     */
    data: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
  }

  /**
   * ClassRoom createMany
   */
  export type ClassRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassRooms.
     */
    data: ClassRoomCreateManyInput | ClassRoomCreateManyInput[]
  }

  /**
   * ClassRoom update
   */
  export type ClassRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassRoom.
     */
    data: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
    /**
     * Choose, which ClassRoom to update.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom updateMany
   */
  export type ClassRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassRooms.
     */
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyInput>
    /**
     * Filter which ClassRooms to update
     */
    where?: ClassRoomWhereInput
    /**
     * Limit how many ClassRooms to update.
     */
    limit?: number
  }

  /**
   * ClassRoom upsert
   */
  export type ClassRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassRoom to update in case it exists.
     */
    where: ClassRoomWhereUniqueInput
    /**
     * In case the ClassRoom found by the `where` argument doesn't exist, create a new ClassRoom with this data.
     */
    create: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
    /**
     * In case the ClassRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
  }

  /**
   * ClassRoom delete
   */
  export type ClassRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    /**
     * Filter which ClassRoom to delete.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom deleteMany
   */
  export type ClassRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassRooms to delete
     */
    where?: ClassRoomWhereInput
    /**
     * Limit how many ClassRooms to delete.
     */
    limit?: number
  }

  /**
   * ClassRoom findRaw
   */
  export type ClassRoomFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClassRoom aggregateRaw
   */
  export type ClassRoomAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClassRoom.trade
   */
  export type ClassRoom$tradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
  }

  /**
   * ClassRoom.sector
   */
  export type ClassRoom$sectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    where?: SectorWhereInput
  }

  /**
   * ClassRoom.Class
   */
  export type ClassRoom$ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * ClassRoom.Subject
   */
  export type ClassRoom$SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * ClassRoom without action
   */
  export type ClassRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    code: string | null
    symbol: string | null
    disabled: boolean | null
    sectorId: string | null
    tradeId: string | null
    classRoomId: string | null
    userId: string | null
    classType: $Enums.ClassType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    description: string | null
    code: string | null
    symbol: string | null
    disabled: boolean | null
    sectorId: string | null
    tradeId: string | null
    classRoomId: string | null
    userId: string | null
    classType: $Enums.ClassType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    username: number
    description: number
    code: number
    symbol: number
    disabled: number
    sectorId: number
    tradeId: number
    classRoomId: number
    userId: number
    classType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    code?: true
    symbol?: true
    disabled?: true
    sectorId?: true
    tradeId?: true
    classRoomId?: true
    userId?: true
    classType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    code?: true
    symbol?: true
    disabled?: true
    sectorId?: true
    tradeId?: true
    classRoomId?: true
    userId?: true
    classType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    description?: true
    code?: true
    symbol?: true
    disabled?: true
    sectorId?: true
    tradeId?: true
    classRoomId?: true
    userId?: true
    classType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    username: string
    description: string | null
    code: string
    symbol: string | null
    disabled: boolean
    sectorId: string | null
    tradeId: string | null
    classRoomId: string | null
    userId: string
    classType: $Enums.ClassType | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    code?: boolean
    symbol?: boolean
    disabled?: boolean
    sectorId?: boolean
    tradeId?: boolean
    classRoomId?: boolean
    userId?: boolean
    classType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Student?: boolean | Class$StudentArgs<ExtArgs>
    SubClass?: boolean | Class$SubClassArgs<ExtArgs>
    trade?: boolean | Class$tradeArgs<ExtArgs>
    sector?: boolean | Class$sectorArgs<ExtArgs>
    user?: boolean | Class$userArgs<ExtArgs>
    classTeacher?: boolean | Class$classTeacherArgs<ExtArgs>
    Post?: boolean | Class$PostArgs<ExtArgs>
    Subject?: boolean | Class$SubjectArgs<ExtArgs>
    Model?: boolean | Class$ModelArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>



  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    description?: boolean
    code?: boolean
    symbol?: boolean
    disabled?: boolean
    sectorId?: boolean
    tradeId?: boolean
    classRoomId?: boolean
    userId?: boolean
    classType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "description" | "code" | "symbol" | "disabled" | "sectorId" | "tradeId" | "classRoomId" | "userId" | "classType" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Student?: boolean | Class$StudentArgs<ExtArgs>
    SubClass?: boolean | Class$SubClassArgs<ExtArgs>
    trade?: boolean | Class$tradeArgs<ExtArgs>
    sector?: boolean | Class$sectorArgs<ExtArgs>
    user?: boolean | Class$userArgs<ExtArgs>
    classTeacher?: boolean | Class$classTeacherArgs<ExtArgs>
    Post?: boolean | Class$PostArgs<ExtArgs>
    Subject?: boolean | Class$SubjectArgs<ExtArgs>
    Model?: boolean | Class$ModelArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      Student: Prisma.$StudentPayload<ExtArgs>[]
      SubClass: Prisma.$SubClassPayload<ExtArgs>[]
      trade: Prisma.$TradePayload<ExtArgs> | null
      sector: Prisma.$SectorPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      classTeacher: Prisma.$ClassRoomPayload<ExtArgs> | null
      Post: Prisma.$PostPayload<ExtArgs>[]
      Subject: Prisma.$SubjectPayload<ExtArgs>[]
      Model: Prisma.$ModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      description: string | null
      code: string
      symbol: string | null
      disabled: boolean
      sectorId: string | null
      tradeId: string | null
      classRoomId: string | null
      userId: string
      classType: $Enums.ClassType | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * @param {ClassFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const class = await prisma.class.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClassFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Class.
     * @param {ClassAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const class = await prisma.class.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClassAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Student<T extends Class$StudentArgs<ExtArgs> = {}>(args?: Subset<T, Class$StudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    SubClass<T extends Class$SubClassArgs<ExtArgs> = {}>(args?: Subset<T, Class$SubClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    trade<T extends Class$tradeArgs<ExtArgs> = {}>(args?: Subset<T, Class$tradeArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    sector<T extends Class$sectorArgs<ExtArgs> = {}>(args?: Subset<T, Class$sectorArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    user<T extends Class$userArgs<ExtArgs> = {}>(args?: Subset<T, Class$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    classTeacher<T extends Class$classTeacherArgs<ExtArgs> = {}>(args?: Subset<T, Class$classTeacherArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Post<T extends Class$PostArgs<ExtArgs> = {}>(args?: Subset<T, Class$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Subject<T extends Class$SubjectArgs<ExtArgs> = {}>(args?: Subset<T, Class$SubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Model<T extends Class$ModelArgs<ExtArgs> = {}>(args?: Subset<T, Class$ModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly username: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly code: FieldRef<"Class", 'String'>
    readonly symbol: FieldRef<"Class", 'String'>
    readonly disabled: FieldRef<"Class", 'Boolean'>
    readonly sectorId: FieldRef<"Class", 'String'>
    readonly tradeId: FieldRef<"Class", 'String'>
    readonly classRoomId: FieldRef<"Class", 'String'>
    readonly userId: FieldRef<"Class", 'String'>
    readonly classType: FieldRef<"Class", 'ClassType'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class findRaw
   */
  export type ClassFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class aggregateRaw
   */
  export type ClassAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class.Student
   */
  export type Class$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.SubClass
   */
  export type Class$SubClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    where?: SubClassWhereInput
    orderBy?: SubClassOrderByWithRelationInput | SubClassOrderByWithRelationInput[]
    cursor?: SubClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubClassScalarFieldEnum | SubClassScalarFieldEnum[]
  }

  /**
   * Class.trade
   */
  export type Class$tradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trade
     */
    omit?: TradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
  }

  /**
   * Class.sector
   */
  export type Class$sectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sector
     */
    omit?: SectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    where?: SectorWhereInput
  }

  /**
   * Class.user
   */
  export type Class$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Class.classTeacher
   */
  export type Class$classTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    where?: ClassRoomWhereInput
  }

  /**
   * Class.Post
   */
  export type Class$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Class.Subject
   */
  export type Class$SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Class.Model
   */
  export type Class$ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model SubClass
   */

  export type AggregateSubClass = {
    _count: SubClassCountAggregateOutputType | null
    _min: SubClassMinAggregateOutputType | null
    _max: SubClassMaxAggregateOutputType | null
  }

  export type SubClassMinAggregateOutputType = {
    id: string | null
    classId: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubClassMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubClassCountAggregateOutputType = {
    id: number
    classId: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubClassMinAggregateInputType = {
    id?: true
    classId?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubClassMaxAggregateInputType = {
    id?: true
    classId?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubClassCountAggregateInputType = {
    id?: true
    classId?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubClass to aggregate.
     */
    where?: SubClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubClasses to fetch.
     */
    orderBy?: SubClassOrderByWithRelationInput | SubClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubClasses
    **/
    _count?: true | SubClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubClassMaxAggregateInputType
  }

  export type GetSubClassAggregateType<T extends SubClassAggregateArgs> = {
        [P in keyof T & keyof AggregateSubClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubClass[P]>
      : GetScalarType<T[P], AggregateSubClass[P]>
  }




  export type SubClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubClassWhereInput
    orderBy?: SubClassOrderByWithAggregationInput | SubClassOrderByWithAggregationInput[]
    by: SubClassScalarFieldEnum[] | SubClassScalarFieldEnum
    having?: SubClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubClassCountAggregateInputType | true
    _min?: SubClassMinAggregateInputType
    _max?: SubClassMaxAggregateInputType
  }

  export type SubClassGroupByOutputType = {
    id: string
    classId: string
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SubClassCountAggregateOutputType | null
    _min: SubClassMinAggregateOutputType | null
    _max: SubClassMaxAggregateOutputType | null
  }

  type GetSubClassGroupByPayload<T extends SubClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubClassGroupByOutputType[P]>
            : GetScalarType<T[P], SubClassGroupByOutputType[P]>
        }
      >
    >


  export type SubClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | SubClass$classArgs<ExtArgs>
  }, ExtArgs["result"]["subClass"]>



  export type SubClassSelectScalar = {
    id?: boolean
    classId?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "code" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["subClass"]>
  export type SubClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | SubClass$classArgs<ExtArgs>
  }

  export type $SubClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubClass"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      code: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subClass"]>
    composites: {}
  }

  type SubClassGetPayload<S extends boolean | null | undefined | SubClassDefaultArgs> = $Result.GetResult<Prisma.$SubClassPayload, S>

  type SubClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubClassCountAggregateInputType | true
    }

  export interface SubClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubClass'], meta: { name: 'SubClass' } }
    /**
     * Find zero or one SubClass that matches the filter.
     * @param {SubClassFindUniqueArgs} args - Arguments to find a SubClass
     * @example
     * // Get one SubClass
     * const subClass = await prisma.subClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubClassFindUniqueArgs>(args: SelectSubset<T, SubClassFindUniqueArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SubClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubClassFindUniqueOrThrowArgs} args - Arguments to find a SubClass
     * @example
     * // Get one SubClass
     * const subClass = await prisma.subClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubClassFindUniqueOrThrowArgs>(args: SelectSubset<T, SubClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SubClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassFindFirstArgs} args - Arguments to find a SubClass
     * @example
     * // Get one SubClass
     * const subClass = await prisma.subClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubClassFindFirstArgs>(args?: SelectSubset<T, SubClassFindFirstArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SubClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassFindFirstOrThrowArgs} args - Arguments to find a SubClass
     * @example
     * // Get one SubClass
     * const subClass = await prisma.subClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubClassFindFirstOrThrowArgs>(args?: SelectSubset<T, SubClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SubClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubClasses
     * const subClasses = await prisma.subClass.findMany()
     * 
     * // Get first 10 SubClasses
     * const subClasses = await prisma.subClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subClassWithIdOnly = await prisma.subClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubClassFindManyArgs>(args?: SelectSubset<T, SubClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SubClass.
     * @param {SubClassCreateArgs} args - Arguments to create a SubClass.
     * @example
     * // Create one SubClass
     * const SubClass = await prisma.subClass.create({
     *   data: {
     *     // ... data to create a SubClass
     *   }
     * })
     * 
     */
    create<T extends SubClassCreateArgs>(args: SelectSubset<T, SubClassCreateArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SubClasses.
     * @param {SubClassCreateManyArgs} args - Arguments to create many SubClasses.
     * @example
     * // Create many SubClasses
     * const subClass = await prisma.subClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubClassCreateManyArgs>(args?: SelectSubset<T, SubClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubClass.
     * @param {SubClassDeleteArgs} args - Arguments to delete one SubClass.
     * @example
     * // Delete one SubClass
     * const SubClass = await prisma.subClass.delete({
     *   where: {
     *     // ... filter to delete one SubClass
     *   }
     * })
     * 
     */
    delete<T extends SubClassDeleteArgs>(args: SelectSubset<T, SubClassDeleteArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SubClass.
     * @param {SubClassUpdateArgs} args - Arguments to update one SubClass.
     * @example
     * // Update one SubClass
     * const subClass = await prisma.subClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubClassUpdateArgs>(args: SelectSubset<T, SubClassUpdateArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SubClasses.
     * @param {SubClassDeleteManyArgs} args - Arguments to filter SubClasses to delete.
     * @example
     * // Delete a few SubClasses
     * const { count } = await prisma.subClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubClassDeleteManyArgs>(args?: SelectSubset<T, SubClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubClasses
     * const subClass = await prisma.subClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubClassUpdateManyArgs>(args: SelectSubset<T, SubClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubClass.
     * @param {SubClassUpsertArgs} args - Arguments to update or create a SubClass.
     * @example
     * // Update or create a SubClass
     * const subClass = await prisma.subClass.upsert({
     *   create: {
     *     // ... data to create a SubClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubClass we want to update
     *   }
     * })
     */
    upsert<T extends SubClassUpsertArgs>(args: SelectSubset<T, SubClassUpsertArgs<ExtArgs>>): Prisma__SubClassClient<$Result.GetResult<Prisma.$SubClassPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SubClasses that matches the filter.
     * @param {SubClassFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subClass = await prisma.subClass.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SubClassFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SubClass.
     * @param {SubClassAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subClass = await prisma.subClass.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubClassAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SubClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassCountArgs} args - Arguments to filter SubClasses to count.
     * @example
     * // Count the number of SubClasses
     * const count = await prisma.subClass.count({
     *   where: {
     *     // ... the filter for the SubClasses we want to count
     *   }
     * })
    **/
    count<T extends SubClassCountArgs>(
      args?: Subset<T, SubClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubClassAggregateArgs>(args: Subset<T, SubClassAggregateArgs>): Prisma.PrismaPromise<GetSubClassAggregateType<T>>

    /**
     * Group by SubClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubClassGroupByArgs['orderBy'] }
        : { orderBy?: SubClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubClass model
   */
  readonly fields: SubClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends SubClass$classArgs<ExtArgs> = {}>(args?: Subset<T, SubClass$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubClass model
   */ 
  interface SubClassFieldRefs {
    readonly id: FieldRef<"SubClass", 'String'>
    readonly classId: FieldRef<"SubClass", 'String'>
    readonly code: FieldRef<"SubClass", 'String'>
    readonly name: FieldRef<"SubClass", 'String'>
    readonly createdAt: FieldRef<"SubClass", 'DateTime'>
    readonly updatedAt: FieldRef<"SubClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubClass findUnique
   */
  export type SubClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter, which SubClass to fetch.
     */
    where: SubClassWhereUniqueInput
  }

  /**
   * SubClass findUniqueOrThrow
   */
  export type SubClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter, which SubClass to fetch.
     */
    where: SubClassWhereUniqueInput
  }

  /**
   * SubClass findFirst
   */
  export type SubClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter, which SubClass to fetch.
     */
    where?: SubClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubClasses to fetch.
     */
    orderBy?: SubClassOrderByWithRelationInput | SubClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubClasses.
     */
    cursor?: SubClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubClasses.
     */
    distinct?: SubClassScalarFieldEnum | SubClassScalarFieldEnum[]
  }

  /**
   * SubClass findFirstOrThrow
   */
  export type SubClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter, which SubClass to fetch.
     */
    where?: SubClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubClasses to fetch.
     */
    orderBy?: SubClassOrderByWithRelationInput | SubClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubClasses.
     */
    cursor?: SubClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubClasses.
     */
    distinct?: SubClassScalarFieldEnum | SubClassScalarFieldEnum[]
  }

  /**
   * SubClass findMany
   */
  export type SubClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter, which SubClasses to fetch.
     */
    where?: SubClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubClasses to fetch.
     */
    orderBy?: SubClassOrderByWithRelationInput | SubClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubClasses.
     */
    cursor?: SubClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubClasses.
     */
    skip?: number
    distinct?: SubClassScalarFieldEnum | SubClassScalarFieldEnum[]
  }

  /**
   * SubClass create
   */
  export type SubClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * The data needed to create a SubClass.
     */
    data: XOR<SubClassCreateInput, SubClassUncheckedCreateInput>
  }

  /**
   * SubClass createMany
   */
  export type SubClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubClasses.
     */
    data: SubClassCreateManyInput | SubClassCreateManyInput[]
  }

  /**
   * SubClass update
   */
  export type SubClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * The data needed to update a SubClass.
     */
    data: XOR<SubClassUpdateInput, SubClassUncheckedUpdateInput>
    /**
     * Choose, which SubClass to update.
     */
    where: SubClassWhereUniqueInput
  }

  /**
   * SubClass updateMany
   */
  export type SubClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubClasses.
     */
    data: XOR<SubClassUpdateManyMutationInput, SubClassUncheckedUpdateManyInput>
    /**
     * Filter which SubClasses to update
     */
    where?: SubClassWhereInput
    /**
     * Limit how many SubClasses to update.
     */
    limit?: number
  }

  /**
   * SubClass upsert
   */
  export type SubClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * The filter to search for the SubClass to update in case it exists.
     */
    where: SubClassWhereUniqueInput
    /**
     * In case the SubClass found by the `where` argument doesn't exist, create a new SubClass with this data.
     */
    create: XOR<SubClassCreateInput, SubClassUncheckedCreateInput>
    /**
     * In case the SubClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubClassUpdateInput, SubClassUncheckedUpdateInput>
  }

  /**
   * SubClass delete
   */
  export type SubClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
    /**
     * Filter which SubClass to delete.
     */
    where: SubClassWhereUniqueInput
  }

  /**
   * SubClass deleteMany
   */
  export type SubClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubClasses to delete
     */
    where?: SubClassWhereInput
    /**
     * Limit how many SubClasses to delete.
     */
    limit?: number
  }

  /**
   * SubClass findRaw
   */
  export type SubClassFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SubClass aggregateRaw
   */
  export type SubClassAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SubClass.class
   */
  export type SubClass$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * SubClass without action
   */
  export type SubClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubClass
     */
    select?: SubClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubClass
     */
    omit?: SubClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubClassInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subClassId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subClassId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    subClassId: number
    classId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    subClassId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    subClassId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    subClassId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    subClassId: string | null
    classId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subClassId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Student$userArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    subClassId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subClassId" | "classId" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Student$userArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subClassId: string | null
      classId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const student = await prisma.student.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Student.
     * @param {StudentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const student = await prisma.student.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Student$userArgs<ExtArgs> = {}>(args?: Subset<T, Student$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    class<T extends Student$classArgs<ExtArgs> = {}>(args?: Subset<T, Student$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly subClassId: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student findRaw
   */
  export type StudentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student aggregateRaw
   */
  export type StudentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student.user
   */
  export type Student$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Student.class
   */
  export type Student$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    classesId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    classesId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    classesId: string[]
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Teacher$userArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>



  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    classesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "classesId" | "createdAt" | "updatedAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Teacher$userArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      classesId: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * @param {TeacherFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacher = await prisma.teacher.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeacherFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Teacher.
     * @param {TeacherAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacher = await prisma.teacher.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeacherAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Teacher$userArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly classesId: FieldRef<"Teacher", 'String[]'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher findRaw
   */
  export type TeacherFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Teacher aggregateRaw
   */
  export type TeacherAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Teacher.user
   */
  export type Teacher$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    file: string | null
    content: string | null
    role: $Enums.PostRole | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    file: string | null
    content: string | null
    role: $Enums.PostRole | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    file: number
    content: number
    role: number
    classId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    file?: true
    content?: true
    role?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    file?: true
    content?: true
    role?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    file?: true
    content?: true
    role?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    userId: string
    file: string | null
    content: string | null
    role: $Enums.PostRole
    classId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    file?: boolean
    content?: boolean
    role?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Post$userArgs<ExtArgs>
    class?: boolean | Post$classArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>



  export type PostSelectScalar = {
    id?: boolean
    userId?: boolean
    file?: boolean
    content?: boolean
    role?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "file" | "content" | "role" | "classId" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Post$userArgs<ExtArgs>
    class?: boolean | Post$classArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      file: string | null
      content: string | null
      role: $Enums.PostRole
      classId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {PostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const post = await prisma.post.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Post.
     * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const post = await prisma.post.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Post$userArgs<ExtArgs> = {}>(args?: Subset<T, Post$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    class<T extends Post$classArgs<ExtArgs> = {}>(args?: Subset<T, Post$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
    readonly file: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly role: FieldRef<"Post", 'PostRole'>
    readonly classId: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post findRaw
   */
  export type PostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post aggregateRaw
   */
  export type PostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post.user
   */
  export type Post$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Post.class
   */
  export type Post$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    learningHours: number | null
  }

  export type SubjectSumAggregateOutputType = {
    learningHours: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    classRoomId: string | null
    classId: string | null
    code: string | null
    sectorId: string | null
    tradeId: string | null
    subjectType: $Enums.SubjectType | null
    curriculum: string | null
    copyright: string | null
    learningHours: number | null
    issueDate: Date | null
    purpose: string | null
    symbol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    classRoomId: string | null
    classId: string | null
    code: string | null
    sectorId: string | null
    tradeId: string | null
    subjectType: $Enums.SubjectType | null
    curriculum: string | null
    copyright: string | null
    learningHours: number | null
    issueDate: Date | null
    purpose: string | null
    symbol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    classRoomId: number
    classId: number
    code: number
    sectorId: number
    tradeId: number
    subjectType: number
    curriculum: number
    copyright: number
    learningHours: number
    issueDate: number
    purpose: number
    symbol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    learningHours?: true
  }

  export type SubjectSumAggregateInputType = {
    learningHours?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    classRoomId?: true
    classId?: true
    code?: true
    sectorId?: true
    tradeId?: true
    subjectType?: true
    curriculum?: true
    copyright?: true
    learningHours?: true
    issueDate?: true
    purpose?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    classRoomId?: true
    classId?: true
    code?: true
    sectorId?: true
    tradeId?: true
    subjectType?: true
    curriculum?: true
    copyright?: true
    learningHours?: true
    issueDate?: true
    purpose?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    classRoomId?: true
    classId?: true
    code?: true
    sectorId?: true
    tradeId?: true
    subjectType?: true
    curriculum?: true
    copyright?: true
    learningHours?: true
    issueDate?: true
    purpose?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    classRoomId: string | null
    classId: string | null
    code: string
    sectorId: string | null
    tradeId: string | null
    subjectType: $Enums.SubjectType | null
    curriculum: string | null
    copyright: string | null
    learningHours: number | null
    issueDate: Date | null
    purpose: string | null
    symbol: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    classRoomId?: boolean
    classId?: boolean
    code?: boolean
    sectorId?: boolean
    tradeId?: boolean
    subjectType?: boolean
    curriculum?: boolean
    copyright?: boolean
    learningHours?: boolean
    issueDate?: boolean
    purpose?: boolean
    symbol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    knowledge?: boolean | Subject$knowledgeArgs<ExtArgs>
    Resource?: boolean | Subject$ResourceArgs<ExtArgs>
    Competence?: boolean | Subject$CompetenceArgs<ExtArgs>
    Assessment?: boolean | Subject$AssessmentArgs<ExtArgs>
    LearningOutcome?: boolean | Subject$LearningOutcomeArgs<ExtArgs>
    IndicativeContent?: boolean | Subject$IndicativeContentArgs<ExtArgs>
    Skill?: boolean | Subject$SkillArgs<ExtArgs>
    Attitude?: boolean | Subject$AttitudeArgs<ExtArgs>
    class?: boolean | Subject$classArgs<ExtArgs>
    classRoom?: boolean | Subject$classRoomArgs<ExtArgs>
    Note?: boolean | Subject$NoteArgs<ExtArgs>
    Model?: boolean | Subject$ModelArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    classRoomId?: boolean
    classId?: boolean
    code?: boolean
    sectorId?: boolean
    tradeId?: boolean
    subjectType?: boolean
    curriculum?: boolean
    copyright?: boolean
    learningHours?: boolean
    issueDate?: boolean
    purpose?: boolean
    symbol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "classRoomId" | "classId" | "code" | "sectorId" | "tradeId" | "subjectType" | "curriculum" | "copyright" | "learningHours" | "issueDate" | "purpose" | "symbol" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | Subject$knowledgeArgs<ExtArgs>
    Resource?: boolean | Subject$ResourceArgs<ExtArgs>
    Competence?: boolean | Subject$CompetenceArgs<ExtArgs>
    Assessment?: boolean | Subject$AssessmentArgs<ExtArgs>
    LearningOutcome?: boolean | Subject$LearningOutcomeArgs<ExtArgs>
    IndicativeContent?: boolean | Subject$IndicativeContentArgs<ExtArgs>
    Skill?: boolean | Subject$SkillArgs<ExtArgs>
    Attitude?: boolean | Subject$AttitudeArgs<ExtArgs>
    class?: boolean | Subject$classArgs<ExtArgs>
    classRoom?: boolean | Subject$classRoomArgs<ExtArgs>
    Note?: boolean | Subject$NoteArgs<ExtArgs>
    Model?: boolean | Subject$ModelArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      knowledge: Prisma.$KnowledgePayload<ExtArgs>[]
      Resource: Prisma.$ResourcePayload<ExtArgs>[]
      Competence: Prisma.$CompetencePayload<ExtArgs>[]
      Assessment: Prisma.$AssessmentPayload<ExtArgs>[]
      LearningOutcome: Prisma.$LearningOutcomePayload<ExtArgs>[]
      IndicativeContent: Prisma.$IndicativeContentPayload<ExtArgs>[]
      Skill: Prisma.$SkillPayload<ExtArgs>[]
      Attitude: Prisma.$AttitudePayload<ExtArgs>[]
      class: Prisma.$ClassPayload<ExtArgs> | null
      classRoom: Prisma.$ClassRoomPayload<ExtArgs> | null
      Note: Prisma.$NotePayload<ExtArgs>[]
      Model: Prisma.$ModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      classRoomId: string | null
      classId: string | null
      code: string
      sectorId: string | null
      tradeId: string | null
      subjectType: $Enums.SubjectType | null
      curriculum: string | null
      copyright: string | null
      learningHours: number | null
      issueDate: Date | null
      purpose: string | null
      symbol: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * @param {SubjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subject = await prisma.subject.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SubjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subject.
     * @param {SubjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subject = await prisma.subject.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledge<T extends Subject$knowledgeArgs<ExtArgs> = {}>(args?: Subset<T, Subject$knowledgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Resource<T extends Subject$ResourceArgs<ExtArgs> = {}>(args?: Subset<T, Subject$ResourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Competence<T extends Subject$CompetenceArgs<ExtArgs> = {}>(args?: Subset<T, Subject$CompetenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Assessment<T extends Subject$AssessmentArgs<ExtArgs> = {}>(args?: Subset<T, Subject$AssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    LearningOutcome<T extends Subject$LearningOutcomeArgs<ExtArgs> = {}>(args?: Subset<T, Subject$LearningOutcomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    IndicativeContent<T extends Subject$IndicativeContentArgs<ExtArgs> = {}>(args?: Subset<T, Subject$IndicativeContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Skill<T extends Subject$SkillArgs<ExtArgs> = {}>(args?: Subset<T, Subject$SkillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Attitude<T extends Subject$AttitudeArgs<ExtArgs> = {}>(args?: Subset<T, Subject$AttitudeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    class<T extends Subject$classArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    classRoom<T extends Subject$classRoomArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classRoomArgs<ExtArgs>>): Prisma__ClassRoomClient<$Result.GetResult<Prisma.$ClassRoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Note<T extends Subject$NoteArgs<ExtArgs> = {}>(args?: Subset<T, Subject$NoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Model<T extends Subject$ModelArgs<ExtArgs> = {}>(args?: Subset<T, Subject$ModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly classRoomId: FieldRef<"Subject", 'String'>
    readonly classId: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly sectorId: FieldRef<"Subject", 'String'>
    readonly tradeId: FieldRef<"Subject", 'String'>
    readonly subjectType: FieldRef<"Subject", 'SubjectType'>
    readonly curriculum: FieldRef<"Subject", 'String'>
    readonly copyright: FieldRef<"Subject", 'String'>
    readonly learningHours: FieldRef<"Subject", 'Int'>
    readonly issueDate: FieldRef<"Subject", 'DateTime'>
    readonly purpose: FieldRef<"Subject", 'String'>
    readonly symbol: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject findRaw
   */
  export type SubjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject aggregateRaw
   */
  export type SubjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject.knowledge
   */
  export type Subject$knowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    where?: KnowledgeWhereInput
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    cursor?: KnowledgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Subject.Resource
   */
  export type Subject$ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Subject.Competence
   */
  export type Subject$CompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    where?: CompetenceWhereInput
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    cursor?: CompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Subject.Assessment
   */
  export type Subject$AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    cursor?: AssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Subject.LearningOutcome
   */
  export type Subject$LearningOutcomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    where?: LearningOutcomeWhereInput
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    cursor?: LearningOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * Subject.IndicativeContent
   */
  export type Subject$IndicativeContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    where?: IndicativeContentWhereInput
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    cursor?: IndicativeContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicativeContentScalarFieldEnum | IndicativeContentScalarFieldEnum[]
  }

  /**
   * Subject.Skill
   */
  export type Subject$SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Subject.Attitude
   */
  export type Subject$AttitudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    where?: AttitudeWhereInput
    orderBy?: AttitudeOrderByWithRelationInput | AttitudeOrderByWithRelationInput[]
    cursor?: AttitudeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttitudeScalarFieldEnum | AttitudeScalarFieldEnum[]
  }

  /**
   * Subject.class
   */
  export type Subject$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Subject.classRoom
   */
  export type Subject$classRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassRoom
     */
    omit?: ClassRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassRoomInclude<ExtArgs> | null
    where?: ClassRoomWhereInput
  }

  /**
   * Subject.Note
   */
  export type Subject$NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Subject.Model
   */
  export type Subject$ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model LearningOutcome
   */

  export type AggregateLearningOutcome = {
    _count: LearningOutcomeCountAggregateOutputType | null
    _avg: LearningOutcomeAvgAggregateOutputType | null
    _sum: LearningOutcomeSumAggregateOutputType | null
    _min: LearningOutcomeMinAggregateOutputType | null
    _max: LearningOutcomeMaxAggregateOutputType | null
  }

  export type LearningOutcomeAvgAggregateOutputType = {
    learningHours: number | null
  }

  export type LearningOutcomeSumAggregateOutputType = {
    learningHours: number | null
  }

  export type LearningOutcomeMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    learningHours: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningOutcomeMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    learningHours: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningOutcomeCountAggregateOutputType = {
    id: number
    SubjectId: number
    learningHours: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LearningOutcomeAvgAggregateInputType = {
    learningHours?: true
  }

  export type LearningOutcomeSumAggregateInputType = {
    learningHours?: true
  }

  export type LearningOutcomeMinAggregateInputType = {
    id?: true
    SubjectId?: true
    learningHours?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningOutcomeMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    learningHours?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningOutcomeCountAggregateInputType = {
    id?: true
    SubjectId?: true
    learningHours?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LearningOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningOutcome to aggregate.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningOutcomes
    **/
    _count?: true | LearningOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningOutcomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningOutcomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningOutcomeMaxAggregateInputType
  }

  export type GetLearningOutcomeAggregateType<T extends LearningOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningOutcome[P]>
      : GetScalarType<T[P], AggregateLearningOutcome[P]>
  }




  export type LearningOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningOutcomeWhereInput
    orderBy?: LearningOutcomeOrderByWithAggregationInput | LearningOutcomeOrderByWithAggregationInput[]
    by: LearningOutcomeScalarFieldEnum[] | LearningOutcomeScalarFieldEnum
    having?: LearningOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningOutcomeCountAggregateInputType | true
    _avg?: LearningOutcomeAvgAggregateInputType
    _sum?: LearningOutcomeSumAggregateInputType
    _min?: LearningOutcomeMinAggregateInputType
    _max?: LearningOutcomeMaxAggregateInputType
  }

  export type LearningOutcomeGroupByOutputType = {
    id: string
    SubjectId: string
    learningHours: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: LearningOutcomeCountAggregateOutputType | null
    _avg: LearningOutcomeAvgAggregateOutputType | null
    _sum: LearningOutcomeSumAggregateOutputType | null
    _min: LearningOutcomeMinAggregateOutputType | null
    _max: LearningOutcomeMaxAggregateOutputType | null
  }

  type GetLearningOutcomeGroupByPayload<T extends LearningOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], LearningOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type LearningOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    learningHours?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    indicativeContent?: boolean | LearningOutcome$indicativeContentArgs<ExtArgs>
    subject?: boolean | LearningOutcome$subjectArgs<ExtArgs>
    _count?: boolean | LearningOutcomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningOutcome"]>



  export type LearningOutcomeSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    learningHours?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LearningOutcomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "learningHours" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["learningOutcome"]>
  export type LearningOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicativeContent?: boolean | LearningOutcome$indicativeContentArgs<ExtArgs>
    subject?: boolean | LearningOutcome$subjectArgs<ExtArgs>
    _count?: boolean | LearningOutcomeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LearningOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningOutcome"
    objects: {
      indicativeContent: Prisma.$IndicativeContentPayload<ExtArgs>[]
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string
      learningHours: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["learningOutcome"]>
    composites: {}
  }

  type LearningOutcomeGetPayload<S extends boolean | null | undefined | LearningOutcomeDefaultArgs> = $Result.GetResult<Prisma.$LearningOutcomePayload, S>

  type LearningOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningOutcomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningOutcomeCountAggregateInputType | true
    }

  export interface LearningOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningOutcome'], meta: { name: 'LearningOutcome' } }
    /**
     * Find zero or one LearningOutcome that matches the filter.
     * @param {LearningOutcomeFindUniqueArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningOutcomeFindUniqueArgs>(args: SelectSubset<T, LearningOutcomeFindUniqueArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LearningOutcome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningOutcomeFindUniqueOrThrowArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LearningOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindFirstArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningOutcomeFindFirstArgs>(args?: SelectSubset<T, LearningOutcomeFindFirstArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LearningOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindFirstOrThrowArgs} args - Arguments to find a LearningOutcome
     * @example
     * // Get one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LearningOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningOutcomes
     * const learningOutcomes = await prisma.learningOutcome.findMany()
     * 
     * // Get first 10 LearningOutcomes
     * const learningOutcomes = await prisma.learningOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningOutcomeWithIdOnly = await prisma.learningOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningOutcomeFindManyArgs>(args?: SelectSubset<T, LearningOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LearningOutcome.
     * @param {LearningOutcomeCreateArgs} args - Arguments to create a LearningOutcome.
     * @example
     * // Create one LearningOutcome
     * const LearningOutcome = await prisma.learningOutcome.create({
     *   data: {
     *     // ... data to create a LearningOutcome
     *   }
     * })
     * 
     */
    create<T extends LearningOutcomeCreateArgs>(args: SelectSubset<T, LearningOutcomeCreateArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LearningOutcomes.
     * @param {LearningOutcomeCreateManyArgs} args - Arguments to create many LearningOutcomes.
     * @example
     * // Create many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningOutcomeCreateManyArgs>(args?: SelectSubset<T, LearningOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LearningOutcome.
     * @param {LearningOutcomeDeleteArgs} args - Arguments to delete one LearningOutcome.
     * @example
     * // Delete one LearningOutcome
     * const LearningOutcome = await prisma.learningOutcome.delete({
     *   where: {
     *     // ... filter to delete one LearningOutcome
     *   }
     * })
     * 
     */
    delete<T extends LearningOutcomeDeleteArgs>(args: SelectSubset<T, LearningOutcomeDeleteArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LearningOutcome.
     * @param {LearningOutcomeUpdateArgs} args - Arguments to update one LearningOutcome.
     * @example
     * // Update one LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningOutcomeUpdateArgs>(args: SelectSubset<T, LearningOutcomeUpdateArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LearningOutcomes.
     * @param {LearningOutcomeDeleteManyArgs} args - Arguments to filter LearningOutcomes to delete.
     * @example
     * // Delete a few LearningOutcomes
     * const { count } = await prisma.learningOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningOutcomeDeleteManyArgs>(args?: SelectSubset<T, LearningOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningOutcomes
     * const learningOutcome = await prisma.learningOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningOutcomeUpdateManyArgs>(args: SelectSubset<T, LearningOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningOutcome.
     * @param {LearningOutcomeUpsertArgs} args - Arguments to update or create a LearningOutcome.
     * @example
     * // Update or create a LearningOutcome
     * const learningOutcome = await prisma.learningOutcome.upsert({
     *   create: {
     *     // ... data to create a LearningOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningOutcome we want to update
     *   }
     * })
     */
    upsert<T extends LearningOutcomeUpsertArgs>(args: SelectSubset<T, LearningOutcomeUpsertArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LearningOutcomes that matches the filter.
     * @param {LearningOutcomeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const learningOutcome = await prisma.learningOutcome.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LearningOutcomeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LearningOutcome.
     * @param {LearningOutcomeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const learningOutcome = await prisma.learningOutcome.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LearningOutcomeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LearningOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeCountArgs} args - Arguments to filter LearningOutcomes to count.
     * @example
     * // Count the number of LearningOutcomes
     * const count = await prisma.learningOutcome.count({
     *   where: {
     *     // ... the filter for the LearningOutcomes we want to count
     *   }
     * })
    **/
    count<T extends LearningOutcomeCountArgs>(
      args?: Subset<T, LearningOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningOutcomeAggregateArgs>(args: Subset<T, LearningOutcomeAggregateArgs>): Prisma.PrismaPromise<GetLearningOutcomeAggregateType<T>>

    /**
     * Group by LearningOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: LearningOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningOutcome model
   */
  readonly fields: LearningOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicativeContent<T extends LearningOutcome$indicativeContentArgs<ExtArgs> = {}>(args?: Subset<T, LearningOutcome$indicativeContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    subject<T extends LearningOutcome$subjectArgs<ExtArgs> = {}>(args?: Subset<T, LearningOutcome$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningOutcome model
   */ 
  interface LearningOutcomeFieldRefs {
    readonly id: FieldRef<"LearningOutcome", 'String'>
    readonly SubjectId: FieldRef<"LearningOutcome", 'String'>
    readonly learningHours: FieldRef<"LearningOutcome", 'Int'>
    readonly description: FieldRef<"LearningOutcome", 'String'>
    readonly createdAt: FieldRef<"LearningOutcome", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningOutcome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningOutcome findUnique
   */
  export type LearningOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome findUniqueOrThrow
   */
  export type LearningOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome findFirst
   */
  export type LearningOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningOutcomes.
     */
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome findFirstOrThrow
   */
  export type LearningOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcome to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningOutcomes.
     */
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome findMany
   */
  export type LearningOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which LearningOutcomes to fetch.
     */
    where?: LearningOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningOutcomes to fetch.
     */
    orderBy?: LearningOutcomeOrderByWithRelationInput | LearningOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningOutcomes.
     */
    cursor?: LearningOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningOutcomes.
     */
    skip?: number
    distinct?: LearningOutcomeScalarFieldEnum | LearningOutcomeScalarFieldEnum[]
  }

  /**
   * LearningOutcome create
   */
  export type LearningOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningOutcome.
     */
    data: XOR<LearningOutcomeCreateInput, LearningOutcomeUncheckedCreateInput>
  }

  /**
   * LearningOutcome createMany
   */
  export type LearningOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningOutcomes.
     */
    data: LearningOutcomeCreateManyInput | LearningOutcomeCreateManyInput[]
  }

  /**
   * LearningOutcome update
   */
  export type LearningOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningOutcome.
     */
    data: XOR<LearningOutcomeUpdateInput, LearningOutcomeUncheckedUpdateInput>
    /**
     * Choose, which LearningOutcome to update.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome updateMany
   */
  export type LearningOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningOutcomes.
     */
    data: XOR<LearningOutcomeUpdateManyMutationInput, LearningOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which LearningOutcomes to update
     */
    where?: LearningOutcomeWhereInput
    /**
     * Limit how many LearningOutcomes to update.
     */
    limit?: number
  }

  /**
   * LearningOutcome upsert
   */
  export type LearningOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningOutcome to update in case it exists.
     */
    where: LearningOutcomeWhereUniqueInput
    /**
     * In case the LearningOutcome found by the `where` argument doesn't exist, create a new LearningOutcome with this data.
     */
    create: XOR<LearningOutcomeCreateInput, LearningOutcomeUncheckedCreateInput>
    /**
     * In case the LearningOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningOutcomeUpdateInput, LearningOutcomeUncheckedUpdateInput>
  }

  /**
   * LearningOutcome delete
   */
  export type LearningOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
    /**
     * Filter which LearningOutcome to delete.
     */
    where: LearningOutcomeWhereUniqueInput
  }

  /**
   * LearningOutcome deleteMany
   */
  export type LearningOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningOutcomes to delete
     */
    where?: LearningOutcomeWhereInput
    /**
     * Limit how many LearningOutcomes to delete.
     */
    limit?: number
  }

  /**
   * LearningOutcome findRaw
   */
  export type LearningOutcomeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LearningOutcome aggregateRaw
   */
  export type LearningOutcomeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LearningOutcome.indicativeContent
   */
  export type LearningOutcome$indicativeContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    where?: IndicativeContentWhereInput
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    cursor?: IndicativeContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicativeContentScalarFieldEnum | IndicativeContentScalarFieldEnum[]
  }

  /**
   * LearningOutcome.subject
   */
  export type LearningOutcome$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * LearningOutcome without action
   */
  export type LearningOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningOutcome
     */
    select?: LearningOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningOutcome
     */
    omit?: LearningOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model IndicativeContent
   */

  export type AggregateIndicativeContent = {
    _count: IndicativeContentCountAggregateOutputType | null
    _min: IndicativeContentMinAggregateOutputType | null
    _max: IndicativeContentMaxAggregateOutputType | null
  }

  export type IndicativeContentMinAggregateOutputType = {
    id: string | null
    learningOutcomeId: string | null
    content: string | null
  }

  export type IndicativeContentMaxAggregateOutputType = {
    id: string | null
    learningOutcomeId: string | null
    content: string | null
  }

  export type IndicativeContentCountAggregateOutputType = {
    id: number
    learningOutcomeId: number
    content: number
    _all: number
  }


  export type IndicativeContentMinAggregateInputType = {
    id?: true
    learningOutcomeId?: true
    content?: true
  }

  export type IndicativeContentMaxAggregateInputType = {
    id?: true
    learningOutcomeId?: true
    content?: true
  }

  export type IndicativeContentCountAggregateInputType = {
    id?: true
    learningOutcomeId?: true
    content?: true
    _all?: true
  }

  export type IndicativeContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicativeContent to aggregate.
     */
    where?: IndicativeContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicativeContents to fetch.
     */
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicativeContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicativeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicativeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicativeContents
    **/
    _count?: true | IndicativeContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicativeContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicativeContentMaxAggregateInputType
  }

  export type GetIndicativeContentAggregateType<T extends IndicativeContentAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicativeContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicativeContent[P]>
      : GetScalarType<T[P], AggregateIndicativeContent[P]>
  }




  export type IndicativeContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicativeContentWhereInput
    orderBy?: IndicativeContentOrderByWithAggregationInput | IndicativeContentOrderByWithAggregationInput[]
    by: IndicativeContentScalarFieldEnum[] | IndicativeContentScalarFieldEnum
    having?: IndicativeContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicativeContentCountAggregateInputType | true
    _min?: IndicativeContentMinAggregateInputType
    _max?: IndicativeContentMaxAggregateInputType
  }

  export type IndicativeContentGroupByOutputType = {
    id: string
    learningOutcomeId: string
    content: string
    _count: IndicativeContentCountAggregateOutputType | null
    _min: IndicativeContentMinAggregateOutputType | null
    _max: IndicativeContentMaxAggregateOutputType | null
  }

  type GetIndicativeContentGroupByPayload<T extends IndicativeContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicativeContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicativeContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicativeContentGroupByOutputType[P]>
            : GetScalarType<T[P], IndicativeContentGroupByOutputType[P]>
        }
      >
    >


  export type IndicativeContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningOutcomeId?: boolean
    content?: boolean
    subject?: boolean | IndicativeContent$subjectArgs<ExtArgs>
    LearningOutcome?: boolean | LearningOutcomeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicativeContent"]>



  export type IndicativeContentSelectScalar = {
    id?: boolean
    learningOutcomeId?: boolean
    content?: boolean
  }

  export type IndicativeContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "learningOutcomeId" | "content", ExtArgs["result"]["indicativeContent"]>
  export type IndicativeContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | IndicativeContent$subjectArgs<ExtArgs>
    LearningOutcome?: boolean | LearningOutcomeDefaultArgs<ExtArgs>
  }

  export type $IndicativeContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicativeContent"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      LearningOutcome: Prisma.$LearningOutcomePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      learningOutcomeId: string
      content: string
    }, ExtArgs["result"]["indicativeContent"]>
    composites: {}
  }

  type IndicativeContentGetPayload<S extends boolean | null | undefined | IndicativeContentDefaultArgs> = $Result.GetResult<Prisma.$IndicativeContentPayload, S>

  type IndicativeContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicativeContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicativeContentCountAggregateInputType | true
    }

  export interface IndicativeContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicativeContent'], meta: { name: 'IndicativeContent' } }
    /**
     * Find zero or one IndicativeContent that matches the filter.
     * @param {IndicativeContentFindUniqueArgs} args - Arguments to find a IndicativeContent
     * @example
     * // Get one IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicativeContentFindUniqueArgs>(args: SelectSubset<T, IndicativeContentFindUniqueArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one IndicativeContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicativeContentFindUniqueOrThrowArgs} args - Arguments to find a IndicativeContent
     * @example
     * // Get one IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicativeContentFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicativeContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first IndicativeContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentFindFirstArgs} args - Arguments to find a IndicativeContent
     * @example
     * // Get one IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicativeContentFindFirstArgs>(args?: SelectSubset<T, IndicativeContentFindFirstArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first IndicativeContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentFindFirstOrThrowArgs} args - Arguments to find a IndicativeContent
     * @example
     * // Get one IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicativeContentFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicativeContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IndicativeContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicativeContents
     * const indicativeContents = await prisma.indicativeContent.findMany()
     * 
     * // Get first 10 IndicativeContents
     * const indicativeContents = await prisma.indicativeContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicativeContentWithIdOnly = await prisma.indicativeContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicativeContentFindManyArgs>(args?: SelectSubset<T, IndicativeContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a IndicativeContent.
     * @param {IndicativeContentCreateArgs} args - Arguments to create a IndicativeContent.
     * @example
     * // Create one IndicativeContent
     * const IndicativeContent = await prisma.indicativeContent.create({
     *   data: {
     *     // ... data to create a IndicativeContent
     *   }
     * })
     * 
     */
    create<T extends IndicativeContentCreateArgs>(args: SelectSubset<T, IndicativeContentCreateArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many IndicativeContents.
     * @param {IndicativeContentCreateManyArgs} args - Arguments to create many IndicativeContents.
     * @example
     * // Create many IndicativeContents
     * const indicativeContent = await prisma.indicativeContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicativeContentCreateManyArgs>(args?: SelectSubset<T, IndicativeContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IndicativeContent.
     * @param {IndicativeContentDeleteArgs} args - Arguments to delete one IndicativeContent.
     * @example
     * // Delete one IndicativeContent
     * const IndicativeContent = await prisma.indicativeContent.delete({
     *   where: {
     *     // ... filter to delete one IndicativeContent
     *   }
     * })
     * 
     */
    delete<T extends IndicativeContentDeleteArgs>(args: SelectSubset<T, IndicativeContentDeleteArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one IndicativeContent.
     * @param {IndicativeContentUpdateArgs} args - Arguments to update one IndicativeContent.
     * @example
     * // Update one IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicativeContentUpdateArgs>(args: SelectSubset<T, IndicativeContentUpdateArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more IndicativeContents.
     * @param {IndicativeContentDeleteManyArgs} args - Arguments to filter IndicativeContents to delete.
     * @example
     * // Delete a few IndicativeContents
     * const { count } = await prisma.indicativeContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicativeContentDeleteManyArgs>(args?: SelectSubset<T, IndicativeContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicativeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicativeContents
     * const indicativeContent = await prisma.indicativeContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicativeContentUpdateManyArgs>(args: SelectSubset<T, IndicativeContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicativeContent.
     * @param {IndicativeContentUpsertArgs} args - Arguments to update or create a IndicativeContent.
     * @example
     * // Update or create a IndicativeContent
     * const indicativeContent = await prisma.indicativeContent.upsert({
     *   create: {
     *     // ... data to create a IndicativeContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicativeContent we want to update
     *   }
     * })
     */
    upsert<T extends IndicativeContentUpsertArgs>(args: SelectSubset<T, IndicativeContentUpsertArgs<ExtArgs>>): Prisma__IndicativeContentClient<$Result.GetResult<Prisma.$IndicativeContentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IndicativeContents that matches the filter.
     * @param {IndicativeContentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const indicativeContent = await prisma.indicativeContent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IndicativeContentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IndicativeContent.
     * @param {IndicativeContentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const indicativeContent = await prisma.indicativeContent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IndicativeContentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IndicativeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentCountArgs} args - Arguments to filter IndicativeContents to count.
     * @example
     * // Count the number of IndicativeContents
     * const count = await prisma.indicativeContent.count({
     *   where: {
     *     // ... the filter for the IndicativeContents we want to count
     *   }
     * })
    **/
    count<T extends IndicativeContentCountArgs>(
      args?: Subset<T, IndicativeContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicativeContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicativeContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicativeContentAggregateArgs>(args: Subset<T, IndicativeContentAggregateArgs>): Prisma.PrismaPromise<GetIndicativeContentAggregateType<T>>

    /**
     * Group by IndicativeContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicativeContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicativeContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicativeContentGroupByArgs['orderBy'] }
        : { orderBy?: IndicativeContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicativeContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicativeContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicativeContent model
   */
  readonly fields: IndicativeContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicativeContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicativeContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends IndicativeContent$subjectArgs<ExtArgs> = {}>(args?: Subset<T, IndicativeContent$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    LearningOutcome<T extends LearningOutcomeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningOutcomeDefaultArgs<ExtArgs>>): Prisma__LearningOutcomeClient<$Result.GetResult<Prisma.$LearningOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicativeContent model
   */ 
  interface IndicativeContentFieldRefs {
    readonly id: FieldRef<"IndicativeContent", 'String'>
    readonly learningOutcomeId: FieldRef<"IndicativeContent", 'String'>
    readonly content: FieldRef<"IndicativeContent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IndicativeContent findUnique
   */
  export type IndicativeContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter, which IndicativeContent to fetch.
     */
    where: IndicativeContentWhereUniqueInput
  }

  /**
   * IndicativeContent findUniqueOrThrow
   */
  export type IndicativeContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter, which IndicativeContent to fetch.
     */
    where: IndicativeContentWhereUniqueInput
  }

  /**
   * IndicativeContent findFirst
   */
  export type IndicativeContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter, which IndicativeContent to fetch.
     */
    where?: IndicativeContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicativeContents to fetch.
     */
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicativeContents.
     */
    cursor?: IndicativeContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicativeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicativeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicativeContents.
     */
    distinct?: IndicativeContentScalarFieldEnum | IndicativeContentScalarFieldEnum[]
  }

  /**
   * IndicativeContent findFirstOrThrow
   */
  export type IndicativeContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter, which IndicativeContent to fetch.
     */
    where?: IndicativeContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicativeContents to fetch.
     */
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicativeContents.
     */
    cursor?: IndicativeContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicativeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicativeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicativeContents.
     */
    distinct?: IndicativeContentScalarFieldEnum | IndicativeContentScalarFieldEnum[]
  }

  /**
   * IndicativeContent findMany
   */
  export type IndicativeContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter, which IndicativeContents to fetch.
     */
    where?: IndicativeContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicativeContents to fetch.
     */
    orderBy?: IndicativeContentOrderByWithRelationInput | IndicativeContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicativeContents.
     */
    cursor?: IndicativeContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicativeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicativeContents.
     */
    skip?: number
    distinct?: IndicativeContentScalarFieldEnum | IndicativeContentScalarFieldEnum[]
  }

  /**
   * IndicativeContent create
   */
  export type IndicativeContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicativeContent.
     */
    data: XOR<IndicativeContentCreateInput, IndicativeContentUncheckedCreateInput>
  }

  /**
   * IndicativeContent createMany
   */
  export type IndicativeContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicativeContents.
     */
    data: IndicativeContentCreateManyInput | IndicativeContentCreateManyInput[]
  }

  /**
   * IndicativeContent update
   */
  export type IndicativeContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicativeContent.
     */
    data: XOR<IndicativeContentUpdateInput, IndicativeContentUncheckedUpdateInput>
    /**
     * Choose, which IndicativeContent to update.
     */
    where: IndicativeContentWhereUniqueInput
  }

  /**
   * IndicativeContent updateMany
   */
  export type IndicativeContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicativeContents.
     */
    data: XOR<IndicativeContentUpdateManyMutationInput, IndicativeContentUncheckedUpdateManyInput>
    /**
     * Filter which IndicativeContents to update
     */
    where?: IndicativeContentWhereInput
    /**
     * Limit how many IndicativeContents to update.
     */
    limit?: number
  }

  /**
   * IndicativeContent upsert
   */
  export type IndicativeContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicativeContent to update in case it exists.
     */
    where: IndicativeContentWhereUniqueInput
    /**
     * In case the IndicativeContent found by the `where` argument doesn't exist, create a new IndicativeContent with this data.
     */
    create: XOR<IndicativeContentCreateInput, IndicativeContentUncheckedCreateInput>
    /**
     * In case the IndicativeContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicativeContentUpdateInput, IndicativeContentUncheckedUpdateInput>
  }

  /**
   * IndicativeContent delete
   */
  export type IndicativeContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
    /**
     * Filter which IndicativeContent to delete.
     */
    where: IndicativeContentWhereUniqueInput
  }

  /**
   * IndicativeContent deleteMany
   */
  export type IndicativeContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicativeContents to delete
     */
    where?: IndicativeContentWhereInput
    /**
     * Limit how many IndicativeContents to delete.
     */
    limit?: number
  }

  /**
   * IndicativeContent findRaw
   */
  export type IndicativeContentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IndicativeContent aggregateRaw
   */
  export type IndicativeContentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IndicativeContent.subject
   */
  export type IndicativeContent$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * IndicativeContent without action
   */
  export type IndicativeContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicativeContent
     */
    select?: IndicativeContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicativeContent
     */
    omit?: IndicativeContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicativeContentInclude<ExtArgs> | null
  }


  /**
   * Model Knowledge
   */

  export type AggregateKnowledge = {
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  export type KnowledgeMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeCountAggregateOutputType = {
    id: number
    SubjectId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeMinAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeCountAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledge to aggregate.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Knowledges
    **/
    _count?: true | KnowledgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeMaxAggregateInputType
  }

  export type GetKnowledgeAggregateType<T extends KnowledgeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledge[P]>
      : GetScalarType<T[P], AggregateKnowledge[P]>
  }




  export type KnowledgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeWhereInput
    orderBy?: KnowledgeOrderByWithAggregationInput | KnowledgeOrderByWithAggregationInput[]
    by: KnowledgeScalarFieldEnum[] | KnowledgeScalarFieldEnum
    having?: KnowledgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeCountAggregateInputType | true
    _min?: KnowledgeMinAggregateInputType
    _max?: KnowledgeMaxAggregateInputType
  }

  export type KnowledgeGroupByOutputType = {
    id: string
    SubjectId: string | null
    description: string
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  type GetKnowledgeGroupByPayload<T extends KnowledgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | Knowledge$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["knowledge"]>



  export type KnowledgeSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledge"]>
  export type KnowledgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Knowledge$subjectArgs<ExtArgs>
  }

  export type $KnowledgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Knowledge"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string | null
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledge"]>
    composites: {}
  }

  type KnowledgeGetPayload<S extends boolean | null | undefined | KnowledgeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgePayload, S>

  type KnowledgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeCountAggregateInputType | true
    }

  export interface KnowledgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Knowledge'], meta: { name: 'Knowledge' } }
    /**
     * Find zero or one Knowledge that matches the filter.
     * @param {KnowledgeFindUniqueArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeFindUniqueArgs>(args: SelectSubset<T, KnowledgeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Knowledge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeFindUniqueOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Knowledge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeFindFirstArgs>(args?: SelectSubset<T, KnowledgeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Knowledge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Knowledges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Knowledges
     * const knowledges = await prisma.knowledge.findMany()
     * 
     * // Get first 10 Knowledges
     * const knowledges = await prisma.knowledge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeWithIdOnly = await prisma.knowledge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeFindManyArgs>(args?: SelectSubset<T, KnowledgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Knowledge.
     * @param {KnowledgeCreateArgs} args - Arguments to create a Knowledge.
     * @example
     * // Create one Knowledge
     * const Knowledge = await prisma.knowledge.create({
     *   data: {
     *     // ... data to create a Knowledge
     *   }
     * })
     * 
     */
    create<T extends KnowledgeCreateArgs>(args: SelectSubset<T, KnowledgeCreateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Knowledges.
     * @param {KnowledgeCreateManyArgs} args - Arguments to create many Knowledges.
     * @example
     * // Create many Knowledges
     * const knowledge = await prisma.knowledge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeCreateManyArgs>(args?: SelectSubset<T, KnowledgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Knowledge.
     * @param {KnowledgeDeleteArgs} args - Arguments to delete one Knowledge.
     * @example
     * // Delete one Knowledge
     * const Knowledge = await prisma.knowledge.delete({
     *   where: {
     *     // ... filter to delete one Knowledge
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeDeleteArgs>(args: SelectSubset<T, KnowledgeDeleteArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Knowledge.
     * @param {KnowledgeUpdateArgs} args - Arguments to update one Knowledge.
     * @example
     * // Update one Knowledge
     * const knowledge = await prisma.knowledge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeUpdateArgs>(args: SelectSubset<T, KnowledgeUpdateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Knowledges.
     * @param {KnowledgeDeleteManyArgs} args - Arguments to filter Knowledges to delete.
     * @example
     * // Delete a few Knowledges
     * const { count } = await prisma.knowledge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Knowledges
     * const knowledge = await prisma.knowledge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeUpdateManyArgs>(args: SelectSubset<T, KnowledgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Knowledge.
     * @param {KnowledgeUpsertArgs} args - Arguments to update or create a Knowledge.
     * @example
     * // Update or create a Knowledge
     * const knowledge = await prisma.knowledge.upsert({
     *   create: {
     *     // ... data to create a Knowledge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Knowledge we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeUpsertArgs>(args: SelectSubset<T, KnowledgeUpsertArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Knowledges that matches the filter.
     * @param {KnowledgeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const knowledge = await prisma.knowledge.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: KnowledgeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Knowledge.
     * @param {KnowledgeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const knowledge = await prisma.knowledge.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: KnowledgeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCountArgs} args - Arguments to filter Knowledges to count.
     * @example
     * // Count the number of Knowledges
     * const count = await prisma.knowledge.count({
     *   where: {
     *     // ... the filter for the Knowledges we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeCountArgs>(
      args?: Subset<T, KnowledgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeAggregateArgs>(args: Subset<T, KnowledgeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeAggregateType<T>>

    /**
     * Group by Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Knowledge model
   */
  readonly fields: KnowledgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Knowledge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Knowledge$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Knowledge$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Knowledge model
   */ 
  interface KnowledgeFieldRefs {
    readonly id: FieldRef<"Knowledge", 'String'>
    readonly SubjectId: FieldRef<"Knowledge", 'String'>
    readonly description: FieldRef<"Knowledge", 'String'>
    readonly createdAt: FieldRef<"Knowledge", 'DateTime'>
    readonly updatedAt: FieldRef<"Knowledge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Knowledge findUnique
   */
  export type KnowledgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findUniqueOrThrow
   */
  export type KnowledgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findFirst
   */
  export type KnowledgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findFirstOrThrow
   */
  export type KnowledgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findMany
   */
  export type KnowledgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledges to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge create
   */
  export type KnowledgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Knowledge.
     */
    data: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
  }

  /**
   * Knowledge createMany
   */
  export type KnowledgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Knowledges.
     */
    data: KnowledgeCreateManyInput | KnowledgeCreateManyInput[]
  }

  /**
   * Knowledge update
   */
  export type KnowledgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Knowledge.
     */
    data: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
    /**
     * Choose, which Knowledge to update.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge updateMany
   */
  export type KnowledgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Knowledges.
     */
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which Knowledges to update
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to update.
     */
    limit?: number
  }

  /**
   * Knowledge upsert
   */
  export type KnowledgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Knowledge to update in case it exists.
     */
    where: KnowledgeWhereUniqueInput
    /**
     * In case the Knowledge found by the `where` argument doesn't exist, create a new Knowledge with this data.
     */
    create: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
    /**
     * In case the Knowledge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
  }

  /**
   * Knowledge delete
   */
  export type KnowledgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter which Knowledge to delete.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge deleteMany
   */
  export type KnowledgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledges to delete
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to delete.
     */
    limit?: number
  }

  /**
   * Knowledge findRaw
   */
  export type KnowledgeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Knowledge aggregateRaw
   */
  export type KnowledgeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Knowledge.subject
   */
  export type Knowledge$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Knowledge without action
   */
  export type KnowledgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    SubjectId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    SubjectId: string | null
    description: string
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | Skill$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>



  export type SkillSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Skill$subjectArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string | null
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * @param {SkillFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const skill = await prisma.skill.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SkillFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Skill.
     * @param {SkillAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const skill = await prisma.skill.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SkillAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Skill$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Skill$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly SubjectId: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill findRaw
   */
  export type SkillFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Skill aggregateRaw
   */
  export type SkillAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Skill.subject
   */
  export type Skill$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model Attitude
   */

  export type AggregateAttitude = {
    _count: AttitudeCountAggregateOutputType | null
    _min: AttitudeMinAggregateOutputType | null
    _max: AttitudeMaxAggregateOutputType | null
  }

  export type AttitudeMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttitudeMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttitudeCountAggregateOutputType = {
    id: number
    SubjectId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttitudeMinAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttitudeMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttitudeCountAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttitudeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attitude to aggregate.
     */
    where?: AttitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attitudes to fetch.
     */
    orderBy?: AttitudeOrderByWithRelationInput | AttitudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attitudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attitudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attitudes
    **/
    _count?: true | AttitudeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttitudeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttitudeMaxAggregateInputType
  }

  export type GetAttitudeAggregateType<T extends AttitudeAggregateArgs> = {
        [P in keyof T & keyof AggregateAttitude]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttitude[P]>
      : GetScalarType<T[P], AggregateAttitude[P]>
  }




  export type AttitudeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttitudeWhereInput
    orderBy?: AttitudeOrderByWithAggregationInput | AttitudeOrderByWithAggregationInput[]
    by: AttitudeScalarFieldEnum[] | AttitudeScalarFieldEnum
    having?: AttitudeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttitudeCountAggregateInputType | true
    _min?: AttitudeMinAggregateInputType
    _max?: AttitudeMaxAggregateInputType
  }

  export type AttitudeGroupByOutputType = {
    id: string
    SubjectId: string | null
    description: string
    createdAt: Date
    updatedAt: Date
    _count: AttitudeCountAggregateOutputType | null
    _min: AttitudeMinAggregateOutputType | null
    _max: AttitudeMaxAggregateOutputType | null
  }

  type GetAttitudeGroupByPayload<T extends AttitudeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttitudeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttitudeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttitudeGroupByOutputType[P]>
            : GetScalarType<T[P], AttitudeGroupByOutputType[P]>
        }
      >
    >


  export type AttitudeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | Attitude$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["attitude"]>



  export type AttitudeSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttitudeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["attitude"]>
  export type AttitudeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Attitude$subjectArgs<ExtArgs>
  }

  export type $AttitudePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attitude"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string | null
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attitude"]>
    composites: {}
  }

  type AttitudeGetPayload<S extends boolean | null | undefined | AttitudeDefaultArgs> = $Result.GetResult<Prisma.$AttitudePayload, S>

  type AttitudeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttitudeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttitudeCountAggregateInputType | true
    }

  export interface AttitudeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attitude'], meta: { name: 'Attitude' } }
    /**
     * Find zero or one Attitude that matches the filter.
     * @param {AttitudeFindUniqueArgs} args - Arguments to find a Attitude
     * @example
     * // Get one Attitude
     * const attitude = await prisma.attitude.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttitudeFindUniqueArgs>(args: SelectSubset<T, AttitudeFindUniqueArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Attitude that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttitudeFindUniqueOrThrowArgs} args - Arguments to find a Attitude
     * @example
     * // Get one Attitude
     * const attitude = await prisma.attitude.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttitudeFindUniqueOrThrowArgs>(args: SelectSubset<T, AttitudeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Attitude that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeFindFirstArgs} args - Arguments to find a Attitude
     * @example
     * // Get one Attitude
     * const attitude = await prisma.attitude.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttitudeFindFirstArgs>(args?: SelectSubset<T, AttitudeFindFirstArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Attitude that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeFindFirstOrThrowArgs} args - Arguments to find a Attitude
     * @example
     * // Get one Attitude
     * const attitude = await prisma.attitude.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttitudeFindFirstOrThrowArgs>(args?: SelectSubset<T, AttitudeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Attitudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attitudes
     * const attitudes = await prisma.attitude.findMany()
     * 
     * // Get first 10 Attitudes
     * const attitudes = await prisma.attitude.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attitudeWithIdOnly = await prisma.attitude.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttitudeFindManyArgs>(args?: SelectSubset<T, AttitudeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Attitude.
     * @param {AttitudeCreateArgs} args - Arguments to create a Attitude.
     * @example
     * // Create one Attitude
     * const Attitude = await prisma.attitude.create({
     *   data: {
     *     // ... data to create a Attitude
     *   }
     * })
     * 
     */
    create<T extends AttitudeCreateArgs>(args: SelectSubset<T, AttitudeCreateArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Attitudes.
     * @param {AttitudeCreateManyArgs} args - Arguments to create many Attitudes.
     * @example
     * // Create many Attitudes
     * const attitude = await prisma.attitude.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttitudeCreateManyArgs>(args?: SelectSubset<T, AttitudeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attitude.
     * @param {AttitudeDeleteArgs} args - Arguments to delete one Attitude.
     * @example
     * // Delete one Attitude
     * const Attitude = await prisma.attitude.delete({
     *   where: {
     *     // ... filter to delete one Attitude
     *   }
     * })
     * 
     */
    delete<T extends AttitudeDeleteArgs>(args: SelectSubset<T, AttitudeDeleteArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Attitude.
     * @param {AttitudeUpdateArgs} args - Arguments to update one Attitude.
     * @example
     * // Update one Attitude
     * const attitude = await prisma.attitude.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttitudeUpdateArgs>(args: SelectSubset<T, AttitudeUpdateArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Attitudes.
     * @param {AttitudeDeleteManyArgs} args - Arguments to filter Attitudes to delete.
     * @example
     * // Delete a few Attitudes
     * const { count } = await prisma.attitude.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttitudeDeleteManyArgs>(args?: SelectSubset<T, AttitudeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attitudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attitudes
     * const attitude = await prisma.attitude.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttitudeUpdateManyArgs>(args: SelectSubset<T, AttitudeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attitude.
     * @param {AttitudeUpsertArgs} args - Arguments to update or create a Attitude.
     * @example
     * // Update or create a Attitude
     * const attitude = await prisma.attitude.upsert({
     *   create: {
     *     // ... data to create a Attitude
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attitude we want to update
     *   }
     * })
     */
    upsert<T extends AttitudeUpsertArgs>(args: SelectSubset<T, AttitudeUpsertArgs<ExtArgs>>): Prisma__AttitudeClient<$Result.GetResult<Prisma.$AttitudePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Attitudes that matches the filter.
     * @param {AttitudeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attitude = await prisma.attitude.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttitudeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attitude.
     * @param {AttitudeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attitude = await prisma.attitude.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttitudeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attitudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeCountArgs} args - Arguments to filter Attitudes to count.
     * @example
     * // Count the number of Attitudes
     * const count = await prisma.attitude.count({
     *   where: {
     *     // ... the filter for the Attitudes we want to count
     *   }
     * })
    **/
    count<T extends AttitudeCountArgs>(
      args?: Subset<T, AttitudeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttitudeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attitude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttitudeAggregateArgs>(args: Subset<T, AttitudeAggregateArgs>): Prisma.PrismaPromise<GetAttitudeAggregateType<T>>

    /**
     * Group by Attitude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttitudeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttitudeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttitudeGroupByArgs['orderBy'] }
        : { orderBy?: AttitudeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttitudeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttitudeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attitude model
   */
  readonly fields: AttitudeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attitude.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttitudeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Attitude$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Attitude$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attitude model
   */ 
  interface AttitudeFieldRefs {
    readonly id: FieldRef<"Attitude", 'String'>
    readonly SubjectId: FieldRef<"Attitude", 'String'>
    readonly description: FieldRef<"Attitude", 'String'>
    readonly createdAt: FieldRef<"Attitude", 'DateTime'>
    readonly updatedAt: FieldRef<"Attitude", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attitude findUnique
   */
  export type AttitudeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter, which Attitude to fetch.
     */
    where: AttitudeWhereUniqueInput
  }

  /**
   * Attitude findUniqueOrThrow
   */
  export type AttitudeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter, which Attitude to fetch.
     */
    where: AttitudeWhereUniqueInput
  }

  /**
   * Attitude findFirst
   */
  export type AttitudeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter, which Attitude to fetch.
     */
    where?: AttitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attitudes to fetch.
     */
    orderBy?: AttitudeOrderByWithRelationInput | AttitudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attitudes.
     */
    cursor?: AttitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attitudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attitudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attitudes.
     */
    distinct?: AttitudeScalarFieldEnum | AttitudeScalarFieldEnum[]
  }

  /**
   * Attitude findFirstOrThrow
   */
  export type AttitudeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter, which Attitude to fetch.
     */
    where?: AttitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attitudes to fetch.
     */
    orderBy?: AttitudeOrderByWithRelationInput | AttitudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attitudes.
     */
    cursor?: AttitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attitudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attitudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attitudes.
     */
    distinct?: AttitudeScalarFieldEnum | AttitudeScalarFieldEnum[]
  }

  /**
   * Attitude findMany
   */
  export type AttitudeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter, which Attitudes to fetch.
     */
    where?: AttitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attitudes to fetch.
     */
    orderBy?: AttitudeOrderByWithRelationInput | AttitudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attitudes.
     */
    cursor?: AttitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attitudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attitudes.
     */
    skip?: number
    distinct?: AttitudeScalarFieldEnum | AttitudeScalarFieldEnum[]
  }

  /**
   * Attitude create
   */
  export type AttitudeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * The data needed to create a Attitude.
     */
    data: XOR<AttitudeCreateInput, AttitudeUncheckedCreateInput>
  }

  /**
   * Attitude createMany
   */
  export type AttitudeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attitudes.
     */
    data: AttitudeCreateManyInput | AttitudeCreateManyInput[]
  }

  /**
   * Attitude update
   */
  export type AttitudeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * The data needed to update a Attitude.
     */
    data: XOR<AttitudeUpdateInput, AttitudeUncheckedUpdateInput>
    /**
     * Choose, which Attitude to update.
     */
    where: AttitudeWhereUniqueInput
  }

  /**
   * Attitude updateMany
   */
  export type AttitudeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attitudes.
     */
    data: XOR<AttitudeUpdateManyMutationInput, AttitudeUncheckedUpdateManyInput>
    /**
     * Filter which Attitudes to update
     */
    where?: AttitudeWhereInput
    /**
     * Limit how many Attitudes to update.
     */
    limit?: number
  }

  /**
   * Attitude upsert
   */
  export type AttitudeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * The filter to search for the Attitude to update in case it exists.
     */
    where: AttitudeWhereUniqueInput
    /**
     * In case the Attitude found by the `where` argument doesn't exist, create a new Attitude with this data.
     */
    create: XOR<AttitudeCreateInput, AttitudeUncheckedCreateInput>
    /**
     * In case the Attitude was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttitudeUpdateInput, AttitudeUncheckedUpdateInput>
  }

  /**
   * Attitude delete
   */
  export type AttitudeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
    /**
     * Filter which Attitude to delete.
     */
    where: AttitudeWhereUniqueInput
  }

  /**
   * Attitude deleteMany
   */
  export type AttitudeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attitudes to delete
     */
    where?: AttitudeWhereInput
    /**
     * Limit how many Attitudes to delete.
     */
    limit?: number
  }

  /**
   * Attitude findRaw
   */
  export type AttitudeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attitude aggregateRaw
   */
  export type AttitudeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attitude.subject
   */
  export type Attitude$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Attitude without action
   */
  export type AttitudeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attitude
     */
    select?: AttitudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attitude
     */
    omit?: AttitudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttitudeInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    category: $Enums.ResourceType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    category: $Enums.ResourceType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    SubjectId: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    SubjectId?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    SubjectId?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    SubjectId: string
    category: $Enums.ResourceType | null
    description: string
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | Resource$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>



  export type ResourceSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Resource$subjectArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string
      category: $Enums.ResourceType | null
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * @param {ResourceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const resource = await prisma.resource.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ResourceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Resource.
     * @param {ResourceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const resource = await prisma.resource.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ResourceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Resource$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Resource$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly SubjectId: FieldRef<"Resource", 'String'>
    readonly category: FieldRef<"Resource", 'ResourceType'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource findRaw
   */
  export type ResourceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Resource aggregateRaw
   */
  export type ResourceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Resource.subject
   */
  export type Resource$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Competence
   */

  export type AggregateCompetence = {
    _count: CompetenceCountAggregateOutputType | null
    _min: CompetenceMinAggregateOutputType | null
    _max: CompetenceMaxAggregateOutputType | null
  }

  export type CompetenceMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetenceMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetenceCountAggregateOutputType = {
    id: number
    SubjectId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompetenceMinAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetenceMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetenceCountAggregateInputType = {
    id?: true
    SubjectId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompetenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competence to aggregate.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Competences
    **/
    _count?: true | CompetenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetenceMaxAggregateInputType
  }

  export type GetCompetenceAggregateType<T extends CompetenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetence[P]>
      : GetScalarType<T[P], AggregateCompetence[P]>
  }




  export type CompetenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetenceWhereInput
    orderBy?: CompetenceOrderByWithAggregationInput | CompetenceOrderByWithAggregationInput[]
    by: CompetenceScalarFieldEnum[] | CompetenceScalarFieldEnum
    having?: CompetenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetenceCountAggregateInputType | true
    _min?: CompetenceMinAggregateInputType
    _max?: CompetenceMaxAggregateInputType
  }

  export type CompetenceGroupByOutputType = {
    id: string
    SubjectId: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CompetenceCountAggregateOutputType | null
    _min: CompetenceMinAggregateOutputType | null
    _max: CompetenceMaxAggregateOutputType | null
  }

  type GetCompetenceGroupByPayload<T extends CompetenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetenceGroupByOutputType[P]>
            : GetScalarType<T[P], CompetenceGroupByOutputType[P]>
        }
      >
    >


  export type CompetenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PerformanceCriteria?: boolean | Competence$PerformanceCriteriaArgs<ExtArgs>
    subject?: boolean | Competence$subjectArgs<ExtArgs>
    _count?: boolean | CompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competence"]>



  export type CompetenceSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompetenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["competence"]>
  export type CompetenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PerformanceCriteria?: boolean | Competence$PerformanceCriteriaArgs<ExtArgs>
    subject?: boolean | Competence$subjectArgs<ExtArgs>
    _count?: boolean | CompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompetencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Competence"
    objects: {
      PerformanceCriteria: Prisma.$PerformanceCriteriaPayload<ExtArgs>[]
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["competence"]>
    composites: {}
  }

  type CompetenceGetPayload<S extends boolean | null | undefined | CompetenceDefaultArgs> = $Result.GetResult<Prisma.$CompetencePayload, S>

  type CompetenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompetenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompetenceCountAggregateInputType | true
    }

  export interface CompetenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Competence'], meta: { name: 'Competence' } }
    /**
     * Find zero or one Competence that matches the filter.
     * @param {CompetenceFindUniqueArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetenceFindUniqueArgs>(args: SelectSubset<T, CompetenceFindUniqueArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Competence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompetenceFindUniqueOrThrowArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetenceFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Competence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindFirstArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetenceFindFirstArgs>(args?: SelectSubset<T, CompetenceFindFirstArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Competence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindFirstOrThrowArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetenceFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Competences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Competences
     * const competences = await prisma.competence.findMany()
     * 
     * // Get first 10 Competences
     * const competences = await prisma.competence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competenceWithIdOnly = await prisma.competence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetenceFindManyArgs>(args?: SelectSubset<T, CompetenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Competence.
     * @param {CompetenceCreateArgs} args - Arguments to create a Competence.
     * @example
     * // Create one Competence
     * const Competence = await prisma.competence.create({
     *   data: {
     *     // ... data to create a Competence
     *   }
     * })
     * 
     */
    create<T extends CompetenceCreateArgs>(args: SelectSubset<T, CompetenceCreateArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Competences.
     * @param {CompetenceCreateManyArgs} args - Arguments to create many Competences.
     * @example
     * // Create many Competences
     * const competence = await prisma.competence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetenceCreateManyArgs>(args?: SelectSubset<T, CompetenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Competence.
     * @param {CompetenceDeleteArgs} args - Arguments to delete one Competence.
     * @example
     * // Delete one Competence
     * const Competence = await prisma.competence.delete({
     *   where: {
     *     // ... filter to delete one Competence
     *   }
     * })
     * 
     */
    delete<T extends CompetenceDeleteArgs>(args: SelectSubset<T, CompetenceDeleteArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Competence.
     * @param {CompetenceUpdateArgs} args - Arguments to update one Competence.
     * @example
     * // Update one Competence
     * const competence = await prisma.competence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetenceUpdateArgs>(args: SelectSubset<T, CompetenceUpdateArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Competences.
     * @param {CompetenceDeleteManyArgs} args - Arguments to filter Competences to delete.
     * @example
     * // Delete a few Competences
     * const { count } = await prisma.competence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetenceDeleteManyArgs>(args?: SelectSubset<T, CompetenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Competences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Competences
     * const competence = await prisma.competence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetenceUpdateManyArgs>(args: SelectSubset<T, CompetenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Competence.
     * @param {CompetenceUpsertArgs} args - Arguments to update or create a Competence.
     * @example
     * // Update or create a Competence
     * const competence = await prisma.competence.upsert({
     *   create: {
     *     // ... data to create a Competence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Competence we want to update
     *   }
     * })
     */
    upsert<T extends CompetenceUpsertArgs>(args: SelectSubset<T, CompetenceUpsertArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Competences that matches the filter.
     * @param {CompetenceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const competence = await prisma.competence.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CompetenceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Competence.
     * @param {CompetenceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const competence = await prisma.competence.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CompetenceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Competences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceCountArgs} args - Arguments to filter Competences to count.
     * @example
     * // Count the number of Competences
     * const count = await prisma.competence.count({
     *   where: {
     *     // ... the filter for the Competences we want to count
     *   }
     * })
    **/
    count<T extends CompetenceCountArgs>(
      args?: Subset<T, CompetenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Competence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetenceAggregateArgs>(args: Subset<T, CompetenceAggregateArgs>): Prisma.PrismaPromise<GetCompetenceAggregateType<T>>

    /**
     * Group by Competence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetenceGroupByArgs['orderBy'] }
        : { orderBy?: CompetenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Competence model
   */
  readonly fields: CompetenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Competence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PerformanceCriteria<T extends Competence$PerformanceCriteriaArgs<ExtArgs> = {}>(args?: Subset<T, Competence$PerformanceCriteriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    subject<T extends Competence$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Competence$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Competence model
   */ 
  interface CompetenceFieldRefs {
    readonly id: FieldRef<"Competence", 'String'>
    readonly SubjectId: FieldRef<"Competence", 'String'>
    readonly description: FieldRef<"Competence", 'String'>
    readonly createdAt: FieldRef<"Competence", 'DateTime'>
    readonly updatedAt: FieldRef<"Competence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Competence findUnique
   */
  export type CompetenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence findUniqueOrThrow
   */
  export type CompetenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence findFirst
   */
  export type CompetenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competences.
     */
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence findFirstOrThrow
   */
  export type CompetenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competences.
     */
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence findMany
   */
  export type CompetenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competences to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence create
   */
  export type CompetenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Competence.
     */
    data: XOR<CompetenceCreateInput, CompetenceUncheckedCreateInput>
  }

  /**
   * Competence createMany
   */
  export type CompetenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Competences.
     */
    data: CompetenceCreateManyInput | CompetenceCreateManyInput[]
  }

  /**
   * Competence update
   */
  export type CompetenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Competence.
     */
    data: XOR<CompetenceUpdateInput, CompetenceUncheckedUpdateInput>
    /**
     * Choose, which Competence to update.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence updateMany
   */
  export type CompetenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Competences.
     */
    data: XOR<CompetenceUpdateManyMutationInput, CompetenceUncheckedUpdateManyInput>
    /**
     * Filter which Competences to update
     */
    where?: CompetenceWhereInput
    /**
     * Limit how many Competences to update.
     */
    limit?: number
  }

  /**
   * Competence upsert
   */
  export type CompetenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Competence to update in case it exists.
     */
    where: CompetenceWhereUniqueInput
    /**
     * In case the Competence found by the `where` argument doesn't exist, create a new Competence with this data.
     */
    create: XOR<CompetenceCreateInput, CompetenceUncheckedCreateInput>
    /**
     * In case the Competence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetenceUpdateInput, CompetenceUncheckedUpdateInput>
  }

  /**
   * Competence delete
   */
  export type CompetenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter which Competence to delete.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence deleteMany
   */
  export type CompetenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competences to delete
     */
    where?: CompetenceWhereInput
    /**
     * Limit how many Competences to delete.
     */
    limit?: number
  }

  /**
   * Competence findRaw
   */
  export type CompetenceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Competence aggregateRaw
   */
  export type CompetenceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Competence.PerformanceCriteria
   */
  export type Competence$PerformanceCriteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    where?: PerformanceCriteriaWhereInput
    orderBy?: PerformanceCriteriaOrderByWithRelationInput | PerformanceCriteriaOrderByWithRelationInput[]
    cursor?: PerformanceCriteriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceCriteriaScalarFieldEnum | PerformanceCriteriaScalarFieldEnum[]
  }

  /**
   * Competence.subject
   */
  export type Competence$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Competence without action
   */
  export type CompetenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceCriteria
   */

  export type AggregatePerformanceCriteria = {
    _count: PerformanceCriteriaCountAggregateOutputType | null
    _min: PerformanceCriteriaMinAggregateOutputType | null
    _max: PerformanceCriteriaMaxAggregateOutputType | null
  }

  export type PerformanceCriteriaMinAggregateOutputType = {
    id: string | null
    competenceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceCriteriaMaxAggregateOutputType = {
    id: string | null
    competenceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceCriteriaCountAggregateOutputType = {
    id: number
    competenceId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceCriteriaMinAggregateInputType = {
    id?: true
    competenceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceCriteriaMaxAggregateInputType = {
    id?: true
    competenceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceCriteriaCountAggregateInputType = {
    id?: true
    competenceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceCriteriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceCriteria to aggregate.
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCriteria to fetch.
     */
    orderBy?: PerformanceCriteriaOrderByWithRelationInput | PerformanceCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceCriteria
    **/
    _count?: true | PerformanceCriteriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceCriteriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceCriteriaMaxAggregateInputType
  }

  export type GetPerformanceCriteriaAggregateType<T extends PerformanceCriteriaAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceCriteria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceCriteria[P]>
      : GetScalarType<T[P], AggregatePerformanceCriteria[P]>
  }




  export type PerformanceCriteriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCriteriaWhereInput
    orderBy?: PerformanceCriteriaOrderByWithAggregationInput | PerformanceCriteriaOrderByWithAggregationInput[]
    by: PerformanceCriteriaScalarFieldEnum[] | PerformanceCriteriaScalarFieldEnum
    having?: PerformanceCriteriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceCriteriaCountAggregateInputType | true
    _min?: PerformanceCriteriaMinAggregateInputType
    _max?: PerformanceCriteriaMaxAggregateInputType
  }

  export type PerformanceCriteriaGroupByOutputType = {
    id: string
    competenceId: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: PerformanceCriteriaCountAggregateOutputType | null
    _min: PerformanceCriteriaMinAggregateOutputType | null
    _max: PerformanceCriteriaMaxAggregateOutputType | null
  }

  type GetPerformanceCriteriaGroupByPayload<T extends PerformanceCriteriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceCriteriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceCriteriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceCriteriaGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceCriteriaGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceCriteriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competenceId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    competence?: boolean | PerformanceCriteria$competenceArgs<ExtArgs>
  }, ExtArgs["result"]["performanceCriteria"]>



  export type PerformanceCriteriaSelectScalar = {
    id?: boolean
    competenceId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceCriteriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "competenceId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceCriteria"]>
  export type PerformanceCriteriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competence?: boolean | PerformanceCriteria$competenceArgs<ExtArgs>
  }

  export type $PerformanceCriteriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceCriteria"
    objects: {
      competence: Prisma.$CompetencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      competenceId: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceCriteria"]>
    composites: {}
  }

  type PerformanceCriteriaGetPayload<S extends boolean | null | undefined | PerformanceCriteriaDefaultArgs> = $Result.GetResult<Prisma.$PerformanceCriteriaPayload, S>

  type PerformanceCriteriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceCriteriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceCriteriaCountAggregateInputType | true
    }

  export interface PerformanceCriteriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceCriteria'], meta: { name: 'PerformanceCriteria' } }
    /**
     * Find zero or one PerformanceCriteria that matches the filter.
     * @param {PerformanceCriteriaFindUniqueArgs} args - Arguments to find a PerformanceCriteria
     * @example
     * // Get one PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceCriteriaFindUniqueArgs>(args: SelectSubset<T, PerformanceCriteriaFindUniqueArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PerformanceCriteria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceCriteriaFindUniqueOrThrowArgs} args - Arguments to find a PerformanceCriteria
     * @example
     * // Get one PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceCriteriaFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceCriteriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PerformanceCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaFindFirstArgs} args - Arguments to find a PerformanceCriteria
     * @example
     * // Get one PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceCriteriaFindFirstArgs>(args?: SelectSubset<T, PerformanceCriteriaFindFirstArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PerformanceCriteria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaFindFirstOrThrowArgs} args - Arguments to find a PerformanceCriteria
     * @example
     * // Get one PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceCriteriaFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceCriteriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PerformanceCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findMany()
     * 
     * // Get first 10 PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceCriteriaWithIdOnly = await prisma.performanceCriteria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceCriteriaFindManyArgs>(args?: SelectSubset<T, PerformanceCriteriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PerformanceCriteria.
     * @param {PerformanceCriteriaCreateArgs} args - Arguments to create a PerformanceCriteria.
     * @example
     * // Create one PerformanceCriteria
     * const PerformanceCriteria = await prisma.performanceCriteria.create({
     *   data: {
     *     // ... data to create a PerformanceCriteria
     *   }
     * })
     * 
     */
    create<T extends PerformanceCriteriaCreateArgs>(args: SelectSubset<T, PerformanceCriteriaCreateArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PerformanceCriteria.
     * @param {PerformanceCriteriaCreateManyArgs} args - Arguments to create many PerformanceCriteria.
     * @example
     * // Create many PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceCriteriaCreateManyArgs>(args?: SelectSubset<T, PerformanceCriteriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceCriteria.
     * @param {PerformanceCriteriaDeleteArgs} args - Arguments to delete one PerformanceCriteria.
     * @example
     * // Delete one PerformanceCriteria
     * const PerformanceCriteria = await prisma.performanceCriteria.delete({
     *   where: {
     *     // ... filter to delete one PerformanceCriteria
     *   }
     * })
     * 
     */
    delete<T extends PerformanceCriteriaDeleteArgs>(args: SelectSubset<T, PerformanceCriteriaDeleteArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PerformanceCriteria.
     * @param {PerformanceCriteriaUpdateArgs} args - Arguments to update one PerformanceCriteria.
     * @example
     * // Update one PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceCriteriaUpdateArgs>(args: SelectSubset<T, PerformanceCriteriaUpdateArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PerformanceCriteria.
     * @param {PerformanceCriteriaDeleteManyArgs} args - Arguments to filter PerformanceCriteria to delete.
     * @example
     * // Delete a few PerformanceCriteria
     * const { count } = await prisma.performanceCriteria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceCriteriaDeleteManyArgs>(args?: SelectSubset<T, PerformanceCriteriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceCriteriaUpdateManyArgs>(args: SelectSubset<T, PerformanceCriteriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceCriteria.
     * @param {PerformanceCriteriaUpsertArgs} args - Arguments to update or create a PerformanceCriteria.
     * @example
     * // Update or create a PerformanceCriteria
     * const performanceCriteria = await prisma.performanceCriteria.upsert({
     *   create: {
     *     // ... data to create a PerformanceCriteria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceCriteria we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceCriteriaUpsertArgs>(args: SelectSubset<T, PerformanceCriteriaUpsertArgs<ExtArgs>>): Prisma__PerformanceCriteriaClient<$Result.GetResult<Prisma.$PerformanceCriteriaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PerformanceCriteria that matches the filter.
     * @param {PerformanceCriteriaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const performanceCriteria = await prisma.performanceCriteria.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PerformanceCriteriaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PerformanceCriteria.
     * @param {PerformanceCriteriaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const performanceCriteria = await prisma.performanceCriteria.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PerformanceCriteriaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PerformanceCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaCountArgs} args - Arguments to filter PerformanceCriteria to count.
     * @example
     * // Count the number of PerformanceCriteria
     * const count = await prisma.performanceCriteria.count({
     *   where: {
     *     // ... the filter for the PerformanceCriteria we want to count
     *   }
     * })
    **/
    count<T extends PerformanceCriteriaCountArgs>(
      args?: Subset<T, PerformanceCriteriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceCriteriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceCriteriaAggregateArgs>(args: Subset<T, PerformanceCriteriaAggregateArgs>): Prisma.PrismaPromise<GetPerformanceCriteriaAggregateType<T>>

    /**
     * Group by PerformanceCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCriteriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceCriteriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceCriteriaGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceCriteriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceCriteriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceCriteriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceCriteria model
   */
  readonly fields: PerformanceCriteriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceCriteria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceCriteriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    competence<T extends PerformanceCriteria$competenceArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceCriteria$competenceArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceCriteria model
   */ 
  interface PerformanceCriteriaFieldRefs {
    readonly id: FieldRef<"PerformanceCriteria", 'String'>
    readonly competenceId: FieldRef<"PerformanceCriteria", 'String'>
    readonly description: FieldRef<"PerformanceCriteria", 'String'>
    readonly createdAt: FieldRef<"PerformanceCriteria", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceCriteria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceCriteria findUnique
   */
  export type PerformanceCriteriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCriteria to fetch.
     */
    where: PerformanceCriteriaWhereUniqueInput
  }

  /**
   * PerformanceCriteria findUniqueOrThrow
   */
  export type PerformanceCriteriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCriteria to fetch.
     */
    where: PerformanceCriteriaWhereUniqueInput
  }

  /**
   * PerformanceCriteria findFirst
   */
  export type PerformanceCriteriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCriteria to fetch.
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCriteria to fetch.
     */
    orderBy?: PerformanceCriteriaOrderByWithRelationInput | PerformanceCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceCriteria.
     */
    cursor?: PerformanceCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceCriteria.
     */
    distinct?: PerformanceCriteriaScalarFieldEnum | PerformanceCriteriaScalarFieldEnum[]
  }

  /**
   * PerformanceCriteria findFirstOrThrow
   */
  export type PerformanceCriteriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCriteria to fetch.
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCriteria to fetch.
     */
    orderBy?: PerformanceCriteriaOrderByWithRelationInput | PerformanceCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceCriteria.
     */
    cursor?: PerformanceCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceCriteria.
     */
    distinct?: PerformanceCriteriaScalarFieldEnum | PerformanceCriteriaScalarFieldEnum[]
  }

  /**
   * PerformanceCriteria findMany
   */
  export type PerformanceCriteriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCriteria to fetch.
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCriteria to fetch.
     */
    orderBy?: PerformanceCriteriaOrderByWithRelationInput | PerformanceCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceCriteria.
     */
    cursor?: PerformanceCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCriteria.
     */
    skip?: number
    distinct?: PerformanceCriteriaScalarFieldEnum | PerformanceCriteriaScalarFieldEnum[]
  }

  /**
   * PerformanceCriteria create
   */
  export type PerformanceCriteriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceCriteria.
     */
    data: XOR<PerformanceCriteriaCreateInput, PerformanceCriteriaUncheckedCreateInput>
  }

  /**
   * PerformanceCriteria createMany
   */
  export type PerformanceCriteriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceCriteria.
     */
    data: PerformanceCriteriaCreateManyInput | PerformanceCriteriaCreateManyInput[]
  }

  /**
   * PerformanceCriteria update
   */
  export type PerformanceCriteriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceCriteria.
     */
    data: XOR<PerformanceCriteriaUpdateInput, PerformanceCriteriaUncheckedUpdateInput>
    /**
     * Choose, which PerformanceCriteria to update.
     */
    where: PerformanceCriteriaWhereUniqueInput
  }

  /**
   * PerformanceCriteria updateMany
   */
  export type PerformanceCriteriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceCriteria.
     */
    data: XOR<PerformanceCriteriaUpdateManyMutationInput, PerformanceCriteriaUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceCriteria to update
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * Limit how many PerformanceCriteria to update.
     */
    limit?: number
  }

  /**
   * PerformanceCriteria upsert
   */
  export type PerformanceCriteriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceCriteria to update in case it exists.
     */
    where: PerformanceCriteriaWhereUniqueInput
    /**
     * In case the PerformanceCriteria found by the `where` argument doesn't exist, create a new PerformanceCriteria with this data.
     */
    create: XOR<PerformanceCriteriaCreateInput, PerformanceCriteriaUncheckedCreateInput>
    /**
     * In case the PerformanceCriteria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceCriteriaUpdateInput, PerformanceCriteriaUncheckedUpdateInput>
  }

  /**
   * PerformanceCriteria delete
   */
  export type PerformanceCriteriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
    /**
     * Filter which PerformanceCriteria to delete.
     */
    where: PerformanceCriteriaWhereUniqueInput
  }

  /**
   * PerformanceCriteria deleteMany
   */
  export type PerformanceCriteriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceCriteria to delete
     */
    where?: PerformanceCriteriaWhereInput
    /**
     * Limit how many PerformanceCriteria to delete.
     */
    limit?: number
  }

  /**
   * PerformanceCriteria findRaw
   */
  export type PerformanceCriteriaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PerformanceCriteria aggregateRaw
   */
  export type PerformanceCriteriaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PerformanceCriteria.competence
   */
  export type PerformanceCriteria$competenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competence
     */
    omit?: CompetenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    where?: CompetenceWhereInput
  }

  /**
   * PerformanceCriteria without action
   */
  export type PerformanceCriteriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCriteria
     */
    select?: PerformanceCriteriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCriteria
     */
    omit?: PerformanceCriteriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCriteriaInclude<ExtArgs> | null
  }


  /**
   * Model Assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    type: $Enums.AssessmentType | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: string | null
    SubjectId: string | null
    type: $Enums.AssessmentType | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    SubjectId: number
    type: number
    method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssessmentMinAggregateInputType = {
    id?: true
    SubjectId?: true
    type?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    SubjectId?: true
    type?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    SubjectId?: true
    type?: true
    method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessment to aggregate.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type AssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithAggregationInput | AssessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: AssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: string
    SubjectId: string
    type: $Enums.AssessmentType | null
    method: string
    createdAt: Date
    updatedAt: Date
    _count: AssessmentCountAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends AssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    SubjectId?: boolean
    type?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | Assessment$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>



  export type AssessmentSelectScalar = {
    id?: boolean
    SubjectId?: boolean
    type?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "SubjectId" | "type" | "method" | "createdAt" | "updatedAt", ExtArgs["result"]["assessment"]>
  export type AssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Assessment$subjectArgs<ExtArgs>
  }

  export type $AssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessment"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      SubjectId: string
      type: $Enums.AssessmentType | null
      method: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type AssessmentGetPayload<S extends boolean | null | undefined | AssessmentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentPayload, S>

  type AssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface AssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessment'], meta: { name: 'Assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {AssessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentFindUniqueArgs>(args: SelectSubset<T, AssessmentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentFindFirstArgs>(args?: SelectSubset<T, AssessmentFindFirstArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentFindManyArgs>(args?: SelectSubset<T, AssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Assessment.
     * @param {AssessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends AssessmentCreateArgs>(args: SelectSubset<T, AssessmentCreateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Assessments.
     * @param {AssessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentCreateManyArgs>(args?: SelectSubset<T, AssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assessment.
     * @param {AssessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends AssessmentDeleteArgs>(args: SelectSubset<T, AssessmentDeleteArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Assessment.
     * @param {AssessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentUpdateArgs>(args: SelectSubset<T, AssessmentUpdateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentDeleteManyArgs>(args?: SelectSubset<T, AssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentUpdateManyArgs>(args: SelectSubset<T, AssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assessment.
     * @param {AssessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentUpsertArgs>(args: SelectSubset<T, AssessmentUpsertArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Assessments that matches the filter.
     * @param {AssessmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const assessment = await prisma.assessment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AssessmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Assessment.
     * @param {AssessmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const assessment = await prisma.assessment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AssessmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentCountArgs>(
      args?: Subset<T, AssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessment model
   */
  readonly fields: AssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Assessment$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assessment model
   */ 
  interface AssessmentFieldRefs {
    readonly id: FieldRef<"Assessment", 'String'>
    readonly SubjectId: FieldRef<"Assessment", 'String'>
    readonly type: FieldRef<"Assessment", 'AssessmentType'>
    readonly method: FieldRef<"Assessment", 'String'>
    readonly createdAt: FieldRef<"Assessment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assessment findUnique
   */
  export type AssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findUniqueOrThrow
   */
  export type AssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findFirst
   */
  export type AssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findFirstOrThrow
   */
  export type AssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findMany
   */
  export type AssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment create
   */
  export type AssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessment.
     */
    data: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
  }

  /**
   * Assessment createMany
   */
  export type AssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
  }

  /**
   * Assessment update
   */
  export type AssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessment.
     */
    data: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
    /**
     * Choose, which Assessment to update.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment updateMany
   */
  export type AssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
    /**
     * Limit how many Assessments to update.
     */
    limit?: number
  }

  /**
   * Assessment upsert
   */
  export type AssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessment to update in case it exists.
     */
    where: AssessmentWhereUniqueInput
    /**
     * In case the Assessment found by the `where` argument doesn't exist, create a new Assessment with this data.
     */
    create: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
    /**
     * In case the Assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
  }

  /**
   * Assessment delete
   */
  export type AssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter which Assessment to delete.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment deleteMany
   */
  export type AssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentWhereInput
    /**
     * Limit how many Assessments to delete.
     */
    limit?: number
  }

  /**
   * Assessment findRaw
   */
  export type AssessmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Assessment aggregateRaw
   */
  export type AssessmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Assessment.subject
   */
  export type Assessment$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Assessment without action
   */
  export type AssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subjectId: string | null
    fileId: string | null
    content: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subjectId: string | null
    fileId: string | null
    content: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    userId: number
    subjectId: number
    seenBy: number
    commentsIds: number
    fileId: number
    content: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    userId?: true
    subjectId?: true
    fileId?: true
    content?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    userId?: true
    subjectId?: true
    fileId?: true
    content?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    userId?: true
    subjectId?: true
    seenBy?: true
    commentsIds?: true
    fileId?: true
    content?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    userId: string
    subjectId: string
    seenBy: string[]
    commentsIds: string[]
    fileId: string | null
    content: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subjectId?: boolean
    seenBy?: boolean
    commentsIds?: boolean
    fileId?: boolean
    content?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>



  export type NoteSelectScalar = {
    id?: boolean
    userId?: boolean
    subjectId?: boolean
    seenBy?: boolean
    commentsIds?: boolean
    fileId?: boolean
    content?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subjectId" | "seenBy" | "commentsIds" | "fileId" | "content" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      Subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subjectId: string
      seenBy: string[]
      commentsIds: string[]
      fileId: string | null
      content: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * @param {NoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const note = await prisma.note.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NoteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Note.
     * @param {NoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const note = await prisma.note.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NoteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly userId: FieldRef<"Note", 'String'>
    readonly subjectId: FieldRef<"Note", 'String'>
    readonly seenBy: FieldRef<"Note", 'String[]'>
    readonly commentsIds: FieldRef<"Note", 'String[]'>
    readonly fileId: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly description: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note findRaw
   */
  export type NoteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Note aggregateRaw
   */
  export type NoteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    teacherId: number
    subjectId: number
    classId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelMinAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    teacherId: string
    subjectId: string
    classId: string
    createdAt: Date
    updatedAt: Date
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Model$classArgs<ExtArgs>
    Subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>



  export type ModelSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "subjectId" | "classId" | "createdAt" | "updatedAt", ExtArgs["result"]["model"]>
  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Model$classArgs<ExtArgs>
    Subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      Subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      subjectId: string
      classId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Models that matches the filter.
     * @param {ModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const model = await prisma.model.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ModelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Model.
     * @param {ModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const model = await prisma.model.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Model$classArgs<ExtArgs> = {}>(args?: Subset<T, Model$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */ 
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly teacherId: FieldRef<"Model", 'String'>
    readonly subjectId: FieldRef<"Model", 'String'>
    readonly classId: FieldRef<"Model", 'String'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to delete.
     */
    limit?: number
  }

  /**
   * Model findRaw
   */
  export type ModelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model aggregateRaw
   */
  export type ModelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Model.class
   */
  export type Model$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    password: 'password',
    username: 'username',
    bio: 'bio',
    age: 'age',
    disabled: 'disabled',
    gender: 'gender',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AuthenticatorScalarFieldEnum: {
    credentialID: 'credentialID',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    credentialPublicKey: 'credentialPublicKey',
    counter: 'counter',
    credentialDeviceType: 'credentialDeviceType',
    credentialBackedUp: 'credentialBackedUp',
    transports: 'transports'
  };

  export type AuthenticatorScalarFieldEnum = (typeof AuthenticatorScalarFieldEnum)[keyof typeof AuthenticatorScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    description: 'description',
    symbol: 'symbol',
    disabled: 'disabled',
    roles: 'roles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const SectorScalarFieldEnum: {
    id: 'id',
    educationId: 'educationId',
    username: 'username',
    name: 'name',
    description: 'description',
    symbol: 'symbol',
    disabled: 'disabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectorScalarFieldEnum = (typeof SectorScalarFieldEnum)[keyof typeof SectorScalarFieldEnum]


  export const TradeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    description: 'description',
    sectorId: 'sectorId',
    limitClasses: 'limitClasses',
    symbol: 'symbol',
    disabled: 'disabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradeScalarFieldEnum = (typeof TradeScalarFieldEnum)[keyof typeof TradeScalarFieldEnum]


  export const ClassRoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    description: 'description',
    symbol: 'symbol',
    disabled: 'disabled',
    ClassRoomType: 'ClassRoomType',
    sectorId: 'sectorId',
    tradeId: 'tradeId',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassRoomScalarFieldEnum = (typeof ClassRoomScalarFieldEnum)[keyof typeof ClassRoomScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    description: 'description',
    code: 'code',
    symbol: 'symbol',
    disabled: 'disabled',
    sectorId: 'sectorId',
    tradeId: 'tradeId',
    classRoomId: 'classRoomId',
    userId: 'userId',
    classType: 'classType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SubClassScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubClassScalarFieldEnum = (typeof SubClassScalarFieldEnum)[keyof typeof SubClassScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subClassId: 'subClassId',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    classesId: 'classesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    file: 'file',
    content: 'content',
    role: 'role',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    classRoomId: 'classRoomId',
    classId: 'classId',
    code: 'code',
    sectorId: 'sectorId',
    tradeId: 'tradeId',
    subjectType: 'subjectType',
    curriculum: 'curriculum',
    copyright: 'copyright',
    learningHours: 'learningHours',
    issueDate: 'issueDate',
    purpose: 'purpose',
    symbol: 'symbol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const LearningOutcomeScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    learningHours: 'learningHours',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LearningOutcomeScalarFieldEnum = (typeof LearningOutcomeScalarFieldEnum)[keyof typeof LearningOutcomeScalarFieldEnum]


  export const IndicativeContentScalarFieldEnum: {
    id: 'id',
    learningOutcomeId: 'learningOutcomeId',
    content: 'content'
  };

  export type IndicativeContentScalarFieldEnum = (typeof IndicativeContentScalarFieldEnum)[keyof typeof IndicativeContentScalarFieldEnum]


  export const KnowledgeScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeScalarFieldEnum = (typeof KnowledgeScalarFieldEnum)[keyof typeof KnowledgeScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const AttitudeScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttitudeScalarFieldEnum = (typeof AttitudeScalarFieldEnum)[keyof typeof AttitudeScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const CompetenceScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompetenceScalarFieldEnum = (typeof CompetenceScalarFieldEnum)[keyof typeof CompetenceScalarFieldEnum]


  export const PerformanceCriteriaScalarFieldEnum: {
    id: 'id',
    competenceId: 'competenceId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceCriteriaScalarFieldEnum = (typeof PerformanceCriteriaScalarFieldEnum)[keyof typeof PerformanceCriteriaScalarFieldEnum]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    SubjectId: 'SubjectId',
    type: 'type',
    method: 'method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subjectId: 'subjectId',
    seenBy: 'seenBy',
    commentsIds: 'commentsIds',
    fileId: 'fileId',
    content: 'content',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ClassRoomType'
   */
  export type EnumClassRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassRoomType'>
    


  /**
   * Reference to a field of type 'ClassRoomType[]'
   */
  export type ListEnumClassRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassRoomType[]'>
    


  /**
   * Reference to a field of type 'ClassType'
   */
  export type EnumClassTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassType'>
    


  /**
   * Reference to a field of type 'ClassType[]'
   */
  export type ListEnumClassTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassType[]'>
    


  /**
   * Reference to a field of type 'PostRole'
   */
  export type EnumPostRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostRole'>
    


  /**
   * Reference to a field of type 'PostRole[]'
   */
  export type ListEnumPostRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostRole[]'>
    


  /**
   * Reference to a field of type 'SubjectType'
   */
  export type EnumSubjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubjectType'>
    


  /**
   * Reference to a field of type 'SubjectType[]'
   */
  export type ListEnumSubjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubjectType[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'AssessmentType'
   */
  export type EnumAssessmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentType'>
    


  /**
   * Reference to a field of type 'AssessmentType[]'
   */
  export type ListEnumAssessmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    password?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    age?: DateTimeNullableFilter<"User"> | Date | string | null
    disabled?: BoolFilter<"User"> | boolean
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Authenticator?: AuthenticatorListRelationFilter
    Student?: StudentListRelationFilter
    Teacher?: TeacherListRelationFilter
    Class?: ClassListRelationFilter
    Post?: PostListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    password?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    age?: SortOrder
    disabled?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    Authenticator?: AuthenticatorOrderByRelationAggregateInput
    Student?: StudentOrderByRelationAggregateInput
    Teacher?: TeacherOrderByRelationAggregateInput
    Class?: ClassOrderByRelationAggregateInput
    Post?: PostOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    password?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    age?: DateTimeNullableFilter<"User"> | Date | string | null
    disabled?: BoolFilter<"User"> | boolean
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Authenticator?: AuthenticatorListRelationFilter
    Student?: StudentListRelationFilter
    Teacher?: TeacherListRelationFilter
    Class?: ClassListRelationFilter
    Post?: PostListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    password?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    age?: SortOrder
    disabled?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    age?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    disabled?: BoolWithAggregatesFilter<"User"> | boolean
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AuthenticatorWhereInput = {
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthenticatorOrderByWithRelationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthenticatorWhereUniqueInput = Prisma.AtLeast<{
    credentialID?: string
    userId_credentialID?: AuthenticatorUserIdCredentialIDCompoundUniqueInput
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "credentialID" | "userId_credentialID">

  export type AuthenticatorOrderByWithAggregationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
    _count?: AuthenticatorCountOrderByAggregateInput
    _avg?: AuthenticatorAvgOrderByAggregateInput
    _max?: AuthenticatorMaxOrderByAggregateInput
    _min?: AuthenticatorMinOrderByAggregateInput
    _sum?: AuthenticatorSumOrderByAggregateInput
  }

  export type AuthenticatorScalarWhereWithAggregatesInput = {
    AND?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    OR?: AuthenticatorScalarWhereWithAggregatesInput[]
    NOT?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    credentialID?: StringWithAggregatesFilter<"Authenticator"> | string
    userId?: StringWithAggregatesFilter<"Authenticator"> | string
    providerAccountId?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialPublicKey?: StringWithAggregatesFilter<"Authenticator"> | string
    counter?: IntWithAggregatesFilter<"Authenticator"> | number
    credentialDeviceType?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialBackedUp?: BoolWithAggregatesFilter<"Authenticator"> | boolean
    transports?: StringNullableWithAggregatesFilter<"Authenticator"> | string | null
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: StringFilter<"Education"> | string
    name?: StringFilter<"Education"> | string
    username?: StringFilter<"Education"> | string
    description?: StringNullableFilter<"Education"> | string | null
    symbol?: StringNullableFilter<"Education"> | string | null
    disabled?: BoolFilter<"Education"> | boolean
    roles?: StringNullableListFilter<"Education">
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    Sector?: SectorListRelationFilter
    Trade?: TradeListRelationFilter
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Sector?: SectorOrderByRelationAggregateInput
    Trade?: TradeOrderByRelationAggregateInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    name?: StringFilter<"Education"> | string
    description?: StringNullableFilter<"Education"> | string | null
    symbol?: StringNullableFilter<"Education"> | string | null
    disabled?: BoolFilter<"Education"> | boolean
    roles?: StringNullableListFilter<"Education">
    createdAt?: DateTimeFilter<"Education"> | Date | string
    updatedAt?: DateTimeFilter<"Education"> | Date | string
    Sector?: SectorListRelationFilter
    Trade?: TradeListRelationFilter
  }, "id" | "username">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Education"> | string
    name?: StringWithAggregatesFilter<"Education"> | string
    username?: StringWithAggregatesFilter<"Education"> | string
    description?: StringNullableWithAggregatesFilter<"Education"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"Education"> | string | null
    disabled?: BoolWithAggregatesFilter<"Education"> | boolean
    roles?: StringNullableListFilter<"Education">
    createdAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Education"> | Date | string
  }

  export type SectorWhereInput = {
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    id?: StringFilter<"Sector"> | string
    educationId?: StringFilter<"Sector"> | string
    username?: StringFilter<"Sector"> | string
    name?: StringFilter<"Sector"> | string
    description?: StringNullableFilter<"Sector"> | string | null
    symbol?: StringNullableFilter<"Sector"> | string | null
    disabled?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    ClassRoom?: ClassRoomListRelationFilter
    Class?: ClassListRelationFilter
  }

  export type SectorOrderByWithRelationInput = {
    id?: SortOrder
    educationId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    education?: EducationOrderByWithRelationInput
    ClassRoom?: ClassRoomOrderByRelationAggregateInput
    Class?: ClassOrderByRelationAggregateInput
  }

  export type SectorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    educationId?: StringFilter<"Sector"> | string
    name?: StringFilter<"Sector"> | string
    description?: StringNullableFilter<"Sector"> | string | null
    symbol?: StringNullableFilter<"Sector"> | string | null
    disabled?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    ClassRoom?: ClassRoomListRelationFilter
    Class?: ClassListRelationFilter
  }, "id" | "username">

  export type SectorOrderByWithAggregationInput = {
    id?: SortOrder
    educationId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectorCountOrderByAggregateInput
    _max?: SectorMaxOrderByAggregateInput
    _min?: SectorMinOrderByAggregateInput
  }

  export type SectorScalarWhereWithAggregatesInput = {
    AND?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    OR?: SectorScalarWhereWithAggregatesInput[]
    NOT?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sector"> | string
    educationId?: StringWithAggregatesFilter<"Sector"> | string
    username?: StringWithAggregatesFilter<"Sector"> | string
    name?: StringWithAggregatesFilter<"Sector"> | string
    description?: StringNullableWithAggregatesFilter<"Sector"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"Sector"> | string | null
    disabled?: BoolWithAggregatesFilter<"Sector"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Sector"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sector"> | Date | string
  }

  export type TradeWhereInput = {
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    id?: StringFilter<"Trade"> | string
    name?: StringFilter<"Trade"> | string
    username?: StringFilter<"Trade"> | string
    description?: StringNullableFilter<"Trade"> | string | null
    sectorId?: StringFilter<"Trade"> | string
    limitClasses?: IntFilter<"Trade"> | number
    symbol?: StringNullableFilter<"Trade"> | string | null
    disabled?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
    sector?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    ClassRoom?: ClassRoomListRelationFilter
    Class?: ClassListRelationFilter
  }

  export type TradeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    sectorId?: SortOrder
    limitClasses?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sector?: EducationOrderByWithRelationInput
    ClassRoom?: ClassRoomOrderByRelationAggregateInput
    Class?: ClassOrderByRelationAggregateInput
  }

  export type TradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    name?: StringFilter<"Trade"> | string
    description?: StringNullableFilter<"Trade"> | string | null
    sectorId?: StringFilter<"Trade"> | string
    limitClasses?: IntFilter<"Trade"> | number
    symbol?: StringNullableFilter<"Trade"> | string | null
    disabled?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
    sector?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    ClassRoom?: ClassRoomListRelationFilter
    Class?: ClassListRelationFilter
  }, "id" | "username">

  export type TradeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    sectorId?: SortOrder
    limitClasses?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradeCountOrderByAggregateInput
    _avg?: TradeAvgOrderByAggregateInput
    _max?: TradeMaxOrderByAggregateInput
    _min?: TradeMinOrderByAggregateInput
    _sum?: TradeSumOrderByAggregateInput
  }

  export type TradeScalarWhereWithAggregatesInput = {
    AND?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    OR?: TradeScalarWhereWithAggregatesInput[]
    NOT?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trade"> | string
    name?: StringWithAggregatesFilter<"Trade"> | string
    username?: StringWithAggregatesFilter<"Trade"> | string
    description?: StringNullableWithAggregatesFilter<"Trade"> | string | null
    sectorId?: StringWithAggregatesFilter<"Trade"> | string
    limitClasses?: IntWithAggregatesFilter<"Trade"> | number
    symbol?: StringNullableWithAggregatesFilter<"Trade"> | string | null
    disabled?: BoolWithAggregatesFilter<"Trade"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
  }

  export type ClassRoomWhereInput = {
    AND?: ClassRoomWhereInput | ClassRoomWhereInput[]
    OR?: ClassRoomWhereInput[]
    NOT?: ClassRoomWhereInput | ClassRoomWhereInput[]
    id?: StringFilter<"ClassRoom"> | string
    name?: StringFilter<"ClassRoom"> | string
    username?: StringFilter<"ClassRoom"> | string
    description?: StringNullableFilter<"ClassRoom"> | string | null
    symbol?: StringNullableFilter<"ClassRoom"> | string | null
    disabled?: BoolFilter<"ClassRoom"> | boolean
    ClassRoomType?: EnumClassRoomTypeFilter<"ClassRoom"> | $Enums.ClassRoomType
    sectorId?: StringNullableFilter<"ClassRoom"> | string | null
    tradeId?: StringNullableFilter<"ClassRoom"> | string | null
    code?: StringNullableFilter<"ClassRoom"> | string | null
    createdAt?: DateTimeFilter<"ClassRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ClassRoom"> | Date | string
    trade?: XOR<TradeNullableScalarRelationFilter, TradeWhereInput> | null
    sector?: XOR<SectorNullableScalarRelationFilter, SectorWhereInput> | null
    Class?: ClassListRelationFilter
    Subject?: SubjectListRelationFilter
  }

  export type ClassRoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    ClassRoomType?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trade?: TradeOrderByWithRelationInput
    sector?: SectorOrderByWithRelationInput
    Class?: ClassOrderByRelationAggregateInput
    Subject?: SubjectOrderByRelationAggregateInput
  }

  export type ClassRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    code?: string
    AND?: ClassRoomWhereInput | ClassRoomWhereInput[]
    OR?: ClassRoomWhereInput[]
    NOT?: ClassRoomWhereInput | ClassRoomWhereInput[]
    name?: StringFilter<"ClassRoom"> | string
    description?: StringNullableFilter<"ClassRoom"> | string | null
    symbol?: StringNullableFilter<"ClassRoom"> | string | null
    disabled?: BoolFilter<"ClassRoom"> | boolean
    ClassRoomType?: EnumClassRoomTypeFilter<"ClassRoom"> | $Enums.ClassRoomType
    sectorId?: StringNullableFilter<"ClassRoom"> | string | null
    tradeId?: StringNullableFilter<"ClassRoom"> | string | null
    createdAt?: DateTimeFilter<"ClassRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ClassRoom"> | Date | string
    trade?: XOR<TradeNullableScalarRelationFilter, TradeWhereInput> | null
    sector?: XOR<SectorNullableScalarRelationFilter, SectorWhereInput> | null
    Class?: ClassListRelationFilter
    Subject?: SubjectListRelationFilter
  }, "id" | "username" | "code">

  export type ClassRoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    ClassRoomType?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassRoomCountOrderByAggregateInput
    _max?: ClassRoomMaxOrderByAggregateInput
    _min?: ClassRoomMinOrderByAggregateInput
  }

  export type ClassRoomScalarWhereWithAggregatesInput = {
    AND?: ClassRoomScalarWhereWithAggregatesInput | ClassRoomScalarWhereWithAggregatesInput[]
    OR?: ClassRoomScalarWhereWithAggregatesInput[]
    NOT?: ClassRoomScalarWhereWithAggregatesInput | ClassRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassRoom"> | string
    name?: StringWithAggregatesFilter<"ClassRoom"> | string
    username?: StringWithAggregatesFilter<"ClassRoom"> | string
    description?: StringNullableWithAggregatesFilter<"ClassRoom"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"ClassRoom"> | string | null
    disabled?: BoolWithAggregatesFilter<"ClassRoom"> | boolean
    ClassRoomType?: EnumClassRoomTypeWithAggregatesFilter<"ClassRoom"> | $Enums.ClassRoomType
    sectorId?: StringNullableWithAggregatesFilter<"ClassRoom"> | string | null
    tradeId?: StringNullableWithAggregatesFilter<"ClassRoom"> | string | null
    code?: StringNullableWithAggregatesFilter<"ClassRoom"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClassRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassRoom"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    username?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    code?: StringFilter<"Class"> | string
    symbol?: StringNullableFilter<"Class"> | string | null
    disabled?: BoolFilter<"Class"> | boolean
    sectorId?: StringNullableFilter<"Class"> | string | null
    tradeId?: StringNullableFilter<"Class"> | string | null
    classRoomId?: StringNullableFilter<"Class"> | string | null
    userId?: StringFilter<"Class"> | string
    classType?: EnumClassTypeNullableFilter<"Class"> | $Enums.ClassType | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    Student?: StudentListRelationFilter
    SubClass?: SubClassListRelationFilter
    trade?: XOR<TradeNullableScalarRelationFilter, TradeWhereInput> | null
    sector?: XOR<SectorNullableScalarRelationFilter, SectorWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    classTeacher?: XOR<ClassRoomNullableScalarRelationFilter, ClassRoomWhereInput> | null
    Post?: PostListRelationFilter
    Subject?: SubjectListRelationFilter
    Model?: ModelListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    classRoomId?: SortOrder
    userId?: SortOrder
    classType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Student?: StudentOrderByRelationAggregateInput
    SubClass?: SubClassOrderByRelationAggregateInput
    trade?: TradeOrderByWithRelationInput
    sector?: SectorOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    classTeacher?: ClassRoomOrderByWithRelationInput
    Post?: PostOrderByRelationAggregateInput
    Subject?: SubjectOrderByRelationAggregateInput
    Model?: ModelOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    code?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    symbol?: StringNullableFilter<"Class"> | string | null
    disabled?: BoolFilter<"Class"> | boolean
    sectorId?: StringNullableFilter<"Class"> | string | null
    tradeId?: StringNullableFilter<"Class"> | string | null
    classRoomId?: StringNullableFilter<"Class"> | string | null
    userId?: StringFilter<"Class"> | string
    classType?: EnumClassTypeNullableFilter<"Class"> | $Enums.ClassType | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    Student?: StudentListRelationFilter
    SubClass?: SubClassListRelationFilter
    trade?: XOR<TradeNullableScalarRelationFilter, TradeWhereInput> | null
    sector?: XOR<SectorNullableScalarRelationFilter, SectorWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    classTeacher?: XOR<ClassRoomNullableScalarRelationFilter, ClassRoomWhereInput> | null
    Post?: PostListRelationFilter
    Subject?: SubjectListRelationFilter
    Model?: ModelListRelationFilter
  }, "id" | "username" | "code">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    classRoomId?: SortOrder
    userId?: SortOrder
    classType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    username?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    code?: StringWithAggregatesFilter<"Class"> | string
    symbol?: StringNullableWithAggregatesFilter<"Class"> | string | null
    disabled?: BoolWithAggregatesFilter<"Class"> | boolean
    sectorId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    tradeId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    classRoomId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    userId?: StringWithAggregatesFilter<"Class"> | string
    classType?: EnumClassTypeNullableWithAggregatesFilter<"Class"> | $Enums.ClassType | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type SubClassWhereInput = {
    AND?: SubClassWhereInput | SubClassWhereInput[]
    OR?: SubClassWhereInput[]
    NOT?: SubClassWhereInput | SubClassWhereInput[]
    id?: StringFilter<"SubClass"> | string
    classId?: StringFilter<"SubClass"> | string
    code?: StringFilter<"SubClass"> | string
    name?: StringFilter<"SubClass"> | string
    createdAt?: DateTimeFilter<"SubClass"> | Date | string
    updatedAt?: DateTimeFilter<"SubClass"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }

  export type SubClassOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type SubClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubClassWhereInput | SubClassWhereInput[]
    OR?: SubClassWhereInput[]
    NOT?: SubClassWhereInput | SubClassWhereInput[]
    classId?: StringFilter<"SubClass"> | string
    code?: StringFilter<"SubClass"> | string
    name?: StringFilter<"SubClass"> | string
    createdAt?: DateTimeFilter<"SubClass"> | Date | string
    updatedAt?: DateTimeFilter<"SubClass"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }, "id">

  export type SubClassOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubClassCountOrderByAggregateInput
    _max?: SubClassMaxOrderByAggregateInput
    _min?: SubClassMinOrderByAggregateInput
  }

  export type SubClassScalarWhereWithAggregatesInput = {
    AND?: SubClassScalarWhereWithAggregatesInput | SubClassScalarWhereWithAggregatesInput[]
    OR?: SubClassScalarWhereWithAggregatesInput[]
    NOT?: SubClassScalarWhereWithAggregatesInput | SubClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubClass"> | string
    classId?: StringWithAggregatesFilter<"SubClass"> | string
    code?: StringWithAggregatesFilter<"SubClass"> | string
    name?: StringWithAggregatesFilter<"SubClass"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubClass"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    subClassId?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subClassId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    userId?: StringFilter<"Student"> | string
    subClassId?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }, "id">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subClassId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    subClassId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    classId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    classesId?: StringNullableListFilter<"Teacher">
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    classesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    userId?: StringFilter<"Teacher"> | string
    classesId?: StringNullableListFilter<"Teacher">
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    classesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    classesId?: StringNullableListFilter<"Teacher">
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    file?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    role?: EnumPostRoleFilter<"Post"> | $Enums.PostRole
    classId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    file?: SortOrder
    content?: SortOrder
    role?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    userId?: StringFilter<"Post"> | string
    file?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    role?: EnumPostRoleFilter<"Post"> | $Enums.PostRole
    classId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    file?: SortOrder
    content?: SortOrder
    role?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    userId?: StringWithAggregatesFilter<"Post"> | string
    file?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    role?: EnumPostRoleWithAggregatesFilter<"Post"> | $Enums.PostRole
    classId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    classRoomId?: StringNullableFilter<"Subject"> | string | null
    classId?: StringNullableFilter<"Subject"> | string | null
    code?: StringFilter<"Subject"> | string
    sectorId?: StringNullableFilter<"Subject"> | string | null
    tradeId?: StringNullableFilter<"Subject"> | string | null
    subjectType?: EnumSubjectTypeNullableFilter<"Subject"> | $Enums.SubjectType | null
    curriculum?: StringNullableFilter<"Subject"> | string | null
    copyright?: StringNullableFilter<"Subject"> | string | null
    learningHours?: IntNullableFilter<"Subject"> | number | null
    issueDate?: DateTimeNullableFilter<"Subject"> | Date | string | null
    purpose?: StringNullableFilter<"Subject"> | string | null
    symbol?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    knowledge?: KnowledgeListRelationFilter
    Resource?: ResourceListRelationFilter
    Competence?: CompetenceListRelationFilter
    Assessment?: AssessmentListRelationFilter
    LearningOutcome?: LearningOutcomeListRelationFilter
    IndicativeContent?: IndicativeContentListRelationFilter
    Skill?: SkillListRelationFilter
    Attitude?: AttitudeListRelationFilter
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    classRoom?: XOR<ClassRoomNullableScalarRelationFilter, ClassRoomWhereInput> | null
    Note?: NoteListRelationFilter
    Model?: ModelListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    classRoomId?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    subjectType?: SortOrder
    curriculum?: SortOrder
    copyright?: SortOrder
    learningHours?: SortOrder
    issueDate?: SortOrder
    purpose?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    knowledge?: KnowledgeOrderByRelationAggregateInput
    Resource?: ResourceOrderByRelationAggregateInput
    Competence?: CompetenceOrderByRelationAggregateInput
    Assessment?: AssessmentOrderByRelationAggregateInput
    LearningOutcome?: LearningOutcomeOrderByRelationAggregateInput
    IndicativeContent?: IndicativeContentOrderByRelationAggregateInput
    Skill?: SkillOrderByRelationAggregateInput
    Attitude?: AttitudeOrderByRelationAggregateInput
    class?: ClassOrderByWithRelationInput
    classRoom?: ClassRoomOrderByWithRelationInput
    Note?: NoteOrderByRelationAggregateInput
    Model?: ModelOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    classRoomId?: StringNullableFilter<"Subject"> | string | null
    classId?: StringNullableFilter<"Subject"> | string | null
    sectorId?: StringNullableFilter<"Subject"> | string | null
    tradeId?: StringNullableFilter<"Subject"> | string | null
    subjectType?: EnumSubjectTypeNullableFilter<"Subject"> | $Enums.SubjectType | null
    curriculum?: StringNullableFilter<"Subject"> | string | null
    copyright?: StringNullableFilter<"Subject"> | string | null
    learningHours?: IntNullableFilter<"Subject"> | number | null
    issueDate?: DateTimeNullableFilter<"Subject"> | Date | string | null
    purpose?: StringNullableFilter<"Subject"> | string | null
    symbol?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    knowledge?: KnowledgeListRelationFilter
    Resource?: ResourceListRelationFilter
    Competence?: CompetenceListRelationFilter
    Assessment?: AssessmentListRelationFilter
    LearningOutcome?: LearningOutcomeListRelationFilter
    IndicativeContent?: IndicativeContentListRelationFilter
    Skill?: SkillListRelationFilter
    Attitude?: AttitudeListRelationFilter
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    classRoom?: XOR<ClassRoomNullableScalarRelationFilter, ClassRoomWhereInput> | null
    Note?: NoteListRelationFilter
    Model?: ModelListRelationFilter
  }, "id" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    classRoomId?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    subjectType?: SortOrder
    curriculum?: SortOrder
    copyright?: SortOrder
    learningHours?: SortOrder
    issueDate?: SortOrder
    purpose?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    classRoomId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    classId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    code?: StringWithAggregatesFilter<"Subject"> | string
    sectorId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    tradeId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    subjectType?: EnumSubjectTypeNullableWithAggregatesFilter<"Subject"> | $Enums.SubjectType | null
    curriculum?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    copyright?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    learningHours?: IntNullableWithAggregatesFilter<"Subject"> | number | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"Subject"> | Date | string | null
    purpose?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type LearningOutcomeWhereInput = {
    AND?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    OR?: LearningOutcomeWhereInput[]
    NOT?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    id?: StringFilter<"LearningOutcome"> | string
    SubjectId?: StringFilter<"LearningOutcome"> | string
    learningHours?: IntNullableFilter<"LearningOutcome"> | number | null
    description?: StringNullableFilter<"LearningOutcome"> | string | null
    createdAt?: DateTimeFilter<"LearningOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"LearningOutcome"> | Date | string
    indicativeContent?: IndicativeContentListRelationFilter
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type LearningOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    learningHours?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    indicativeContent?: IndicativeContentOrderByRelationAggregateInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type LearningOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    OR?: LearningOutcomeWhereInput[]
    NOT?: LearningOutcomeWhereInput | LearningOutcomeWhereInput[]
    SubjectId?: StringFilter<"LearningOutcome"> | string
    learningHours?: IntNullableFilter<"LearningOutcome"> | number | null
    description?: StringNullableFilter<"LearningOutcome"> | string | null
    createdAt?: DateTimeFilter<"LearningOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"LearningOutcome"> | Date | string
    indicativeContent?: IndicativeContentListRelationFilter
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type LearningOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    learningHours?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LearningOutcomeCountOrderByAggregateInput
    _avg?: LearningOutcomeAvgOrderByAggregateInput
    _max?: LearningOutcomeMaxOrderByAggregateInput
    _min?: LearningOutcomeMinOrderByAggregateInput
    _sum?: LearningOutcomeSumOrderByAggregateInput
  }

  export type LearningOutcomeScalarWhereWithAggregatesInput = {
    AND?: LearningOutcomeScalarWhereWithAggregatesInput | LearningOutcomeScalarWhereWithAggregatesInput[]
    OR?: LearningOutcomeScalarWhereWithAggregatesInput[]
    NOT?: LearningOutcomeScalarWhereWithAggregatesInput | LearningOutcomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningOutcome"> | string
    SubjectId?: StringWithAggregatesFilter<"LearningOutcome"> | string
    learningHours?: IntNullableWithAggregatesFilter<"LearningOutcome"> | number | null
    description?: StringNullableWithAggregatesFilter<"LearningOutcome"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LearningOutcome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningOutcome"> | Date | string
  }

  export type IndicativeContentWhereInput = {
    AND?: IndicativeContentWhereInput | IndicativeContentWhereInput[]
    OR?: IndicativeContentWhereInput[]
    NOT?: IndicativeContentWhereInput | IndicativeContentWhereInput[]
    id?: StringFilter<"IndicativeContent"> | string
    learningOutcomeId?: StringFilter<"IndicativeContent"> | string
    content?: StringFilter<"IndicativeContent"> | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    LearningOutcome?: XOR<LearningOutcomeScalarRelationFilter, LearningOutcomeWhereInput>
  }

  export type IndicativeContentOrderByWithRelationInput = {
    id?: SortOrder
    learningOutcomeId?: SortOrder
    content?: SortOrder
    subject?: SubjectOrderByWithRelationInput
    LearningOutcome?: LearningOutcomeOrderByWithRelationInput
  }

  export type IndicativeContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicativeContentWhereInput | IndicativeContentWhereInput[]
    OR?: IndicativeContentWhereInput[]
    NOT?: IndicativeContentWhereInput | IndicativeContentWhereInput[]
    learningOutcomeId?: StringFilter<"IndicativeContent"> | string
    content?: StringFilter<"IndicativeContent"> | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    LearningOutcome?: XOR<LearningOutcomeScalarRelationFilter, LearningOutcomeWhereInput>
  }, "id">

  export type IndicativeContentOrderByWithAggregationInput = {
    id?: SortOrder
    learningOutcomeId?: SortOrder
    content?: SortOrder
    _count?: IndicativeContentCountOrderByAggregateInput
    _max?: IndicativeContentMaxOrderByAggregateInput
    _min?: IndicativeContentMinOrderByAggregateInput
  }

  export type IndicativeContentScalarWhereWithAggregatesInput = {
    AND?: IndicativeContentScalarWhereWithAggregatesInput | IndicativeContentScalarWhereWithAggregatesInput[]
    OR?: IndicativeContentScalarWhereWithAggregatesInput[]
    NOT?: IndicativeContentScalarWhereWithAggregatesInput | IndicativeContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicativeContent"> | string
    learningOutcomeId?: StringWithAggregatesFilter<"IndicativeContent"> | string
    content?: StringWithAggregatesFilter<"IndicativeContent"> | string
  }

  export type KnowledgeWhereInput = {
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    id?: StringFilter<"Knowledge"> | string
    SubjectId?: StringNullableFilter<"Knowledge"> | string | null
    description?: StringFilter<"Knowledge"> | string
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type KnowledgeOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type KnowledgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    SubjectId?: StringNullableFilter<"Knowledge"> | string | null
    description?: StringFilter<"Knowledge"> | string
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type KnowledgeOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeCountOrderByAggregateInput
    _max?: KnowledgeMaxOrderByAggregateInput
    _min?: KnowledgeMinOrderByAggregateInput
  }

  export type KnowledgeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Knowledge"> | string
    SubjectId?: StringNullableWithAggregatesFilter<"Knowledge"> | string | null
    description?: StringWithAggregatesFilter<"Knowledge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    SubjectId?: StringNullableFilter<"Skill"> | string | null
    description?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    SubjectId?: StringNullableFilter<"Skill"> | string | null
    description?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    SubjectId?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    description?: StringWithAggregatesFilter<"Skill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type AttitudeWhereInput = {
    AND?: AttitudeWhereInput | AttitudeWhereInput[]
    OR?: AttitudeWhereInput[]
    NOT?: AttitudeWhereInput | AttitudeWhereInput[]
    id?: StringFilter<"Attitude"> | string
    SubjectId?: StringNullableFilter<"Attitude"> | string | null
    description?: StringFilter<"Attitude"> | string
    createdAt?: DateTimeFilter<"Attitude"> | Date | string
    updatedAt?: DateTimeFilter<"Attitude"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type AttitudeOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type AttitudeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttitudeWhereInput | AttitudeWhereInput[]
    OR?: AttitudeWhereInput[]
    NOT?: AttitudeWhereInput | AttitudeWhereInput[]
    SubjectId?: StringNullableFilter<"Attitude"> | string | null
    description?: StringFilter<"Attitude"> | string
    createdAt?: DateTimeFilter<"Attitude"> | Date | string
    updatedAt?: DateTimeFilter<"Attitude"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type AttitudeOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttitudeCountOrderByAggregateInput
    _max?: AttitudeMaxOrderByAggregateInput
    _min?: AttitudeMinOrderByAggregateInput
  }

  export type AttitudeScalarWhereWithAggregatesInput = {
    AND?: AttitudeScalarWhereWithAggregatesInput | AttitudeScalarWhereWithAggregatesInput[]
    OR?: AttitudeScalarWhereWithAggregatesInput[]
    NOT?: AttitudeScalarWhereWithAggregatesInput | AttitudeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attitude"> | string
    SubjectId?: StringNullableWithAggregatesFilter<"Attitude"> | string | null
    description?: StringWithAggregatesFilter<"Attitude"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attitude"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attitude"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    SubjectId?: StringFilter<"Resource"> | string
    category?: EnumResourceTypeNullableFilter<"Resource"> | $Enums.ResourceType | null
    description?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    SubjectId?: StringFilter<"Resource"> | string
    category?: EnumResourceTypeNullableFilter<"Resource"> | $Enums.ResourceType | null
    description?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    SubjectId?: StringWithAggregatesFilter<"Resource"> | string
    category?: EnumResourceTypeNullableWithAggregatesFilter<"Resource"> | $Enums.ResourceType | null
    description?: StringWithAggregatesFilter<"Resource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type CompetenceWhereInput = {
    AND?: CompetenceWhereInput | CompetenceWhereInput[]
    OR?: CompetenceWhereInput[]
    NOT?: CompetenceWhereInput | CompetenceWhereInput[]
    id?: StringFilter<"Competence"> | string
    SubjectId?: StringFilter<"Competence"> | string
    description?: StringFilter<"Competence"> | string
    createdAt?: DateTimeFilter<"Competence"> | Date | string
    updatedAt?: DateTimeFilter<"Competence"> | Date | string
    PerformanceCriteria?: PerformanceCriteriaListRelationFilter
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type CompetenceOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    PerformanceCriteria?: PerformanceCriteriaOrderByRelationAggregateInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type CompetenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompetenceWhereInput | CompetenceWhereInput[]
    OR?: CompetenceWhereInput[]
    NOT?: CompetenceWhereInput | CompetenceWhereInput[]
    SubjectId?: StringFilter<"Competence"> | string
    description?: StringFilter<"Competence"> | string
    createdAt?: DateTimeFilter<"Competence"> | Date | string
    updatedAt?: DateTimeFilter<"Competence"> | Date | string
    PerformanceCriteria?: PerformanceCriteriaListRelationFilter
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type CompetenceOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompetenceCountOrderByAggregateInput
    _max?: CompetenceMaxOrderByAggregateInput
    _min?: CompetenceMinOrderByAggregateInput
  }

  export type CompetenceScalarWhereWithAggregatesInput = {
    AND?: CompetenceScalarWhereWithAggregatesInput | CompetenceScalarWhereWithAggregatesInput[]
    OR?: CompetenceScalarWhereWithAggregatesInput[]
    NOT?: CompetenceScalarWhereWithAggregatesInput | CompetenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Competence"> | string
    SubjectId?: StringWithAggregatesFilter<"Competence"> | string
    description?: StringWithAggregatesFilter<"Competence"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Competence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Competence"> | Date | string
  }

  export type PerformanceCriteriaWhereInput = {
    AND?: PerformanceCriteriaWhereInput | PerformanceCriteriaWhereInput[]
    OR?: PerformanceCriteriaWhereInput[]
    NOT?: PerformanceCriteriaWhereInput | PerformanceCriteriaWhereInput[]
    id?: StringFilter<"PerformanceCriteria"> | string
    competenceId?: StringFilter<"PerformanceCriteria"> | string
    description?: StringFilter<"PerformanceCriteria"> | string
    createdAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
    competence?: XOR<CompetenceNullableScalarRelationFilter, CompetenceWhereInput> | null
  }

  export type PerformanceCriteriaOrderByWithRelationInput = {
    id?: SortOrder
    competenceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    competence?: CompetenceOrderByWithRelationInput
  }

  export type PerformanceCriteriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceCriteriaWhereInput | PerformanceCriteriaWhereInput[]
    OR?: PerformanceCriteriaWhereInput[]
    NOT?: PerformanceCriteriaWhereInput | PerformanceCriteriaWhereInput[]
    competenceId?: StringFilter<"PerformanceCriteria"> | string
    description?: StringFilter<"PerformanceCriteria"> | string
    createdAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
    competence?: XOR<CompetenceNullableScalarRelationFilter, CompetenceWhereInput> | null
  }, "id">

  export type PerformanceCriteriaOrderByWithAggregationInput = {
    id?: SortOrder
    competenceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceCriteriaCountOrderByAggregateInput
    _max?: PerformanceCriteriaMaxOrderByAggregateInput
    _min?: PerformanceCriteriaMinOrderByAggregateInput
  }

  export type PerformanceCriteriaScalarWhereWithAggregatesInput = {
    AND?: PerformanceCriteriaScalarWhereWithAggregatesInput | PerformanceCriteriaScalarWhereWithAggregatesInput[]
    OR?: PerformanceCriteriaScalarWhereWithAggregatesInput[]
    NOT?: PerformanceCriteriaScalarWhereWithAggregatesInput | PerformanceCriteriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceCriteria"> | string
    competenceId?: StringWithAggregatesFilter<"PerformanceCriteria"> | string
    description?: StringWithAggregatesFilter<"PerformanceCriteria"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceCriteria"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceCriteria"> | Date | string
  }

  export type AssessmentWhereInput = {
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    id?: StringFilter<"Assessment"> | string
    SubjectId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeNullableFilter<"Assessment"> | $Enums.AssessmentType | null
    method?: StringFilter<"Assessment"> | string
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type AssessmentOrderByWithRelationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type AssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    SubjectId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeNullableFilter<"Assessment"> | $Enums.AssessmentType | null
    method?: StringFilter<"Assessment"> | string
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type AssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssessmentCountOrderByAggregateInput
    _max?: AssessmentMaxOrderByAggregateInput
    _min?: AssessmentMinOrderByAggregateInput
  }

  export type AssessmentScalarWhereWithAggregatesInput = {
    AND?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    OR?: AssessmentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assessment"> | string
    SubjectId?: StringWithAggregatesFilter<"Assessment"> | string
    type?: EnumAssessmentTypeNullableWithAggregatesFilter<"Assessment"> | $Enums.AssessmentType | null
    method?: StringWithAggregatesFilter<"Assessment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    subjectId?: StringFilter<"Note"> | string
    seenBy?: StringNullableListFilter<"Note">
    commentsIds?: StringNullableListFilter<"Note">
    fileId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    description?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    Subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
    seenBy?: SortOrder
    commentsIds?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Subject?: SubjectOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    userId?: StringFilter<"Note"> | string
    subjectId?: StringFilter<"Note"> | string
    seenBy?: StringNullableListFilter<"Note">
    commentsIds?: StringNullableListFilter<"Note">
    fileId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    description?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    Subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
    seenBy?: SortOrder
    commentsIds?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    userId?: StringWithAggregatesFilter<"Note"> | string
    subjectId?: StringWithAggregatesFilter<"Note"> | string
    seenBy?: StringNullableListFilter<"Note">
    commentsIds?: StringNullableListFilter<"Note">
    fileId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    content?: StringWithAggregatesFilter<"Note"> | string
    description?: StringNullableWithAggregatesFilter<"Note"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    teacherId?: StringFilter<"Model"> | string
    subjectId?: StringFilter<"Model"> | string
    classId?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    Subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    Subject?: SubjectOrderByWithRelationInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    teacherId?: StringFilter<"Model"> | string
    subjectId?: StringFilter<"Model"> | string
    classId?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    Subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    teacherId?: StringWithAggregatesFilter<"Model"> | string
    subjectId?: StringWithAggregatesFilter<"Model"> | string
    classId?: StringWithAggregatesFilter<"Model"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorCreateInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
    user: UserCreateNestedOneWithoutAuthenticatorInput
  }

  export type AuthenticatorUncheckedCreateInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAuthenticatorNestedInput
  }

  export type AuthenticatorUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorCreateManyInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateManyMutationInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Sector?: SectorCreateNestedManyWithoutEducationInput
    Trade?: TradeCreateNestedManyWithoutSectorInput
  }

  export type EducationUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Sector?: SectorUncheckedCreateNestedManyWithoutEducationInput
    Trade?: TradeUncheckedCreateNestedManyWithoutSectorInput
  }

  export type EducationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sector?: SectorUpdateManyWithoutEducationNestedInput
    Trade?: TradeUpdateManyWithoutSectorNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sector?: SectorUncheckedUpdateManyWithoutEducationNestedInput
    Trade?: TradeUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type EducationCreateManyInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorCreateInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    education: EducationCreateNestedOneWithoutSectorInput
    ClassRoom?: ClassRoomCreateNestedManyWithoutSectorInput
    Class?: ClassCreateNestedManyWithoutSectorInput
  }

  export type SectorUncheckedCreateInput = {
    id?: string
    educationId: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutSectorInput
    Class?: ClassUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    education?: EducationUpdateOneRequiredWithoutSectorNestedInput
    ClassRoom?: ClassRoomUpdateManyWithoutSectorNestedInput
    Class?: ClassUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateInput = {
    educationId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutSectorNestedInput
    Class?: ClassUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type SectorCreateManyInput = {
    id?: string
    educationId: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorUncheckedUpdateManyInput = {
    educationId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sector: EducationCreateNestedOneWithoutTradeInput
    ClassRoom?: ClassRoomCreateNestedManyWithoutTradeInput
    Class?: ClassCreateNestedManyWithoutTradeInput
  }

  export type TradeUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    sectorId: string
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutTradeInput
    Class?: ClassUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EducationUpdateOneRequiredWithoutTradeNestedInput
    ClassRoom?: ClassRoomUpdateManyWithoutTradeNestedInput
    Class?: ClassUpdateManyWithoutTradeNestedInput
  }

  export type TradeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectorId?: StringFieldUpdateOperationsInput | string
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutTradeNestedInput
    Class?: ClassUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type TradeCreateManyInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    sectorId: string
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectorId?: StringFieldUpdateOperationsInput | string
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassRoomCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trade?: TradeCreateNestedOneWithoutClassRoomInput
    sector?: SectorCreateNestedOneWithoutClassRoomInput
    Class?: ClassCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trade?: TradeUpdateOneWithoutClassRoomNestedInput
    sector?: SectorUpdateOneWithoutClassRoomNestedInput
    Class?: ClassUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomCreateManyInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassRoomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassRoomUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutSubClassInput
  }

  export type SubClassUncheckedCreateInput = {
    id?: string
    classId: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubClassUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutSubClassNestedInput
  }

  export type SubClassUncheckedUpdateInput = {
    classId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassCreateManyInput = {
    id?: string
    classId: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubClassUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassUncheckedUpdateManyInput = {
    classId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    subClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    subClassId?: string | null
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    subClassId?: string | null
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateInput = {
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPostInput
    class?: ClassCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    userId: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPostNestedInput
    class?: ClassUpdateOneWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: string
    userId: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningOutcomeCreateInput = {
    id?: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    indicativeContent?: IndicativeContentCreateNestedManyWithoutLearningOutcomeInput
    subject?: SubjectCreateNestedOneWithoutLearningOutcomeInput
  }

  export type LearningOutcomeUncheckedCreateInput = {
    id?: string
    SubjectId: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    indicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutLearningOutcomeInput
  }

  export type LearningOutcomeUpdateInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicativeContent?: IndicativeContentUpdateManyWithoutLearningOutcomeNestedInput
    subject?: SubjectUpdateOneWithoutLearningOutcomeNestedInput
  }

  export type LearningOutcomeUncheckedUpdateInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicativeContent?: IndicativeContentUncheckedUpdateManyWithoutLearningOutcomeNestedInput
  }

  export type LearningOutcomeCreateManyInput = {
    id?: string
    SubjectId: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningOutcomeUpdateManyMutationInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningOutcomeUncheckedUpdateManyInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicativeContentCreateInput = {
    id?: string
    content: string
    subject?: SubjectCreateNestedOneWithoutIndicativeContentInput
    LearningOutcome: LearningOutcomeCreateNestedOneWithoutIndicativeContentInput
  }

  export type IndicativeContentUncheckedCreateInput = {
    id?: string
    learningOutcomeId: string
    content: string
  }

  export type IndicativeContentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneWithoutIndicativeContentNestedInput
    LearningOutcome?: LearningOutcomeUpdateOneRequiredWithoutIndicativeContentNestedInput
  }

  export type IndicativeContentUncheckedUpdateInput = {
    learningOutcomeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type IndicativeContentCreateManyInput = {
    id?: string
    learningOutcomeId: string
    content: string
  }

  export type IndicativeContentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type IndicativeContentUncheckedUpdateManyInput = {
    learningOutcomeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type KnowledgeCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutKnowledgeInput
  }

  export type KnowledgeUncheckedCreateInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutKnowledgeNestedInput
  }

  export type KnowledgeUncheckedUpdateInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateManyInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateManyInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateManyInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutAttitudeInput
  }

  export type AttitudeUncheckedCreateInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttitudeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutAttitudeNestedInput
  }

  export type AttitudeUncheckedUpdateInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeCreateManyInput = {
    id?: string
    SubjectId?: string | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttitudeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeUncheckedUpdateManyInput = {
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    SubjectId: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateInput = {
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManyInput = {
    id?: string
    SubjectId: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetenceCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PerformanceCriteria?: PerformanceCriteriaCreateNestedManyWithoutCompetenceInput
    subject?: SubjectCreateNestedOneWithoutCompetenceInput
  }

  export type CompetenceUncheckedCreateInput = {
    id?: string
    SubjectId: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PerformanceCriteria?: PerformanceCriteriaUncheckedCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PerformanceCriteria?: PerformanceCriteriaUpdateManyWithoutCompetenceNestedInput
    subject?: SubjectUpdateOneWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PerformanceCriteria?: PerformanceCriteriaUncheckedUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceCreateManyInput = {
    id?: string
    SubjectId: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetenceUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetenceUncheckedUpdateManyInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCriteriaCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    competence?: CompetenceCreateNestedOneWithoutPerformanceCriteriaInput
  }

  export type PerformanceCriteriaUncheckedCreateInput = {
    id?: string
    competenceId: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCriteriaUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competence?: CompetenceUpdateOneWithoutPerformanceCriteriaNestedInput
  }

  export type PerformanceCriteriaUncheckedUpdateInput = {
    competenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCriteriaCreateManyInput = {
    id?: string
    competenceId: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCriteriaUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCriteriaUncheckedUpdateManyInput = {
    competenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentCreateInput = {
    id?: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateInput = {
    id?: string
    SubjectId: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentUpdateInput = {
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentCreateManyInput = {
    id?: string
    SubjectId: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentUpdateManyMutationInput = {
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateManyInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateInput = {
    id?: string
    userId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Subject: SubjectCreateNestedOneWithoutNoteInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    userId: string
    subjectId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: SubjectUpdateOneRequiredWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: string
    userId: string
    subjectId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateInput = {
    id?: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutModelInput
    Subject: SubjectCreateNestedOneWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutModelNestedInput
    Subject?: SubjectUpdateOneRequiredWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateManyInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelUpdateManyMutationInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUncheckedUpdateManyInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuthenticatorListRelationFilter = {
    every?: AuthenticatorWhereInput
    some?: AuthenticatorWhereInput
    none?: AuthenticatorWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthenticatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    password?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    age?: SortOrder
    disabled?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    password?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    age?: SortOrder
    disabled?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    password?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    age?: SortOrder
    disabled?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AuthenticatorUserIdCredentialIDCompoundUniqueInput = {
    userId: string
    credentialID: string
  }

  export type AuthenticatorCountOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type AuthenticatorMaxOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorMinOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SectorListRelationFilter = {
    every?: SectorWhereInput
    some?: SectorWhereInput
    none?: SectorWhereInput
  }

  export type TradeListRelationFilter = {
    every?: TradeWhereInput
    some?: TradeWhereInput
    none?: TradeWhereInput
  }

  export type SectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationScalarRelationFilter = {
    is?: EducationWhereInput
    isNot?: EducationWhereInput
  }

  export type ClassRoomListRelationFilter = {
    every?: ClassRoomWhereInput
    some?: ClassRoomWhereInput
    none?: ClassRoomWhereInput
  }

  export type ClassRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectorCountOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorMaxOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorMinOrderByAggregateInput = {
    id?: SortOrder
    educationId?: SortOrder
    username?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    sectorId?: SortOrder
    limitClasses?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeAvgOrderByAggregateInput = {
    limitClasses?: SortOrder
  }

  export type TradeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    sectorId?: SortOrder
    limitClasses?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    sectorId?: SortOrder
    limitClasses?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeSumOrderByAggregateInput = {
    limitClasses?: SortOrder
  }

  export type EnumClassRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassRoomType | EnumClassRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClassRoomTypeFilter<$PrismaModel> | $Enums.ClassRoomType
  }

  export type TradeNullableScalarRelationFilter = {
    is?: TradeWhereInput | null
    isNot?: TradeWhereInput | null
  }

  export type SectorNullableScalarRelationFilter = {
    is?: SectorWhereInput | null
    isNot?: SectorWhereInput | null
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassRoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    ClassRoomType?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    ClassRoomType?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassRoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    ClassRoomType?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClassRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassRoomType | EnumClassRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClassRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClassRoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumClassRoomTypeFilter<$PrismaModel>
  }

  export type EnumClassTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassType | EnumClassTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClassTypeNullableFilter<$PrismaModel> | $Enums.ClassType | null
    isSet?: boolean
  }

  export type SubClassListRelationFilter = {
    every?: SubClassWhereInput
    some?: SubClassWhereInput
    none?: SubClassWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClassRoomNullableScalarRelationFilter = {
    is?: ClassRoomWhereInput | null
    isNot?: ClassRoomWhereInput | null
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type SubClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    classRoomId?: SortOrder
    userId?: SortOrder
    classType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    classRoomId?: SortOrder
    userId?: SortOrder
    classType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    description?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    disabled?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    classRoomId?: SortOrder
    userId?: SortOrder
    classType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClassTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassType | EnumClassTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClassTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClassType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClassTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumClassTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type SubClassCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubClassMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubClassMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subClassId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subClassId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subClassId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PostRole | EnumPostRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPostRoleFilter<$PrismaModel> | $Enums.PostRole
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    file?: SortOrder
    content?: SortOrder
    role?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    file?: SortOrder
    content?: SortOrder
    role?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    file?: SortOrder
    content?: SortOrder
    role?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostRole | EnumPostRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPostRoleWithAggregatesFilter<$PrismaModel> | $Enums.PostRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostRoleFilter<$PrismaModel>
    _max?: NestedEnumPostRoleFilter<$PrismaModel>
  }

  export type EnumSubjectTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubjectType | EnumSubjectTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectTypeNullableFilter<$PrismaModel> | $Enums.SubjectType | null
    isSet?: boolean
  }

  export type KnowledgeListRelationFilter = {
    every?: KnowledgeWhereInput
    some?: KnowledgeWhereInput
    none?: KnowledgeWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type CompetenceListRelationFilter = {
    every?: CompetenceWhereInput
    some?: CompetenceWhereInput
    none?: CompetenceWhereInput
  }

  export type AssessmentListRelationFilter = {
    every?: AssessmentWhereInput
    some?: AssessmentWhereInput
    none?: AssessmentWhereInput
  }

  export type LearningOutcomeListRelationFilter = {
    every?: LearningOutcomeWhereInput
    some?: LearningOutcomeWhereInput
    none?: LearningOutcomeWhereInput
  }

  export type IndicativeContentListRelationFilter = {
    every?: IndicativeContentWhereInput
    some?: IndicativeContentWhereInput
    none?: IndicativeContentWhereInput
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type AttitudeListRelationFilter = {
    every?: AttitudeWhereInput
    some?: AttitudeWhereInput
    none?: AttitudeWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type KnowledgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicativeContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttitudeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classRoomId?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    subjectType?: SortOrder
    curriculum?: SortOrder
    copyright?: SortOrder
    learningHours?: SortOrder
    issueDate?: SortOrder
    purpose?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    learningHours?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classRoomId?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    subjectType?: SortOrder
    curriculum?: SortOrder
    copyright?: SortOrder
    learningHours?: SortOrder
    issueDate?: SortOrder
    purpose?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    classRoomId?: SortOrder
    classId?: SortOrder
    code?: SortOrder
    sectorId?: SortOrder
    tradeId?: SortOrder
    subjectType?: SortOrder
    curriculum?: SortOrder
    copyright?: SortOrder
    learningHours?: SortOrder
    issueDate?: SortOrder
    purpose?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    learningHours?: SortOrder
  }

  export type EnumSubjectTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubjectType | EnumSubjectTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubjectType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubjectTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSubjectTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type LearningOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    learningHours?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningOutcomeAvgOrderByAggregateInput = {
    learningHours?: SortOrder
  }

  export type LearningOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    learningHours?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    learningHours?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningOutcomeSumOrderByAggregateInput = {
    learningHours?: SortOrder
  }

  export type LearningOutcomeScalarRelationFilter = {
    is?: LearningOutcomeWhereInput
    isNot?: LearningOutcomeWhereInput
  }

  export type IndicativeContentCountOrderByAggregateInput = {
    id?: SortOrder
    learningOutcomeId?: SortOrder
    content?: SortOrder
  }

  export type IndicativeContentMaxOrderByAggregateInput = {
    id?: SortOrder
    learningOutcomeId?: SortOrder
    content?: SortOrder
  }

  export type IndicativeContentMinOrderByAggregateInput = {
    id?: SortOrder
    learningOutcomeId?: SortOrder
    content?: SortOrder
  }

  export type KnowledgeCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttitudeCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttitudeMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttitudeMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumResourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableFilter<$PrismaModel> | $Enums.ResourceType | null
    isSet?: boolean
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumResourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type PerformanceCriteriaListRelationFilter = {
    every?: PerformanceCriteriaWhereInput
    some?: PerformanceCriteriaWhereInput
    none?: PerformanceCriteriaWhereInput
  }

  export type PerformanceCriteriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetenceCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetenceMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetenceMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetenceNullableScalarRelationFilter = {
    is?: CompetenceWhereInput | null
    isNot?: CompetenceWhereInput | null
  }

  export type PerformanceCriteriaCountOrderByAggregateInput = {
    id?: SortOrder
    competenceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceCriteriaMaxOrderByAggregateInput = {
    id?: SortOrder
    competenceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceCriteriaMinOrderByAggregateInput = {
    id?: SortOrder
    competenceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssessmentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel> | $Enums.AssessmentType | null
    isSet?: boolean
  }

  export type AssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    SubjectId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssessmentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAssessmentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
    seenBy?: SortOrder
    commentsIds?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput> | ClassCreateWithoutUserInput[] | ClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutUserInput | ClassCreateOrConnectWithoutUserInput[]
    createMany?: ClassCreateManyUserInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput> | ClassCreateWithoutUserInput[] | ClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutUserInput | ClassCreateOrConnectWithoutUserInput[]
    createMany?: ClassCreateManyUserInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput> | ClassCreateWithoutUserInput[] | ClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutUserInput | ClassCreateOrConnectWithoutUserInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutUserInput | ClassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassCreateManyUserInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutUserInput | ClassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutUserInput | ClassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput> | ClassCreateWithoutUserInput[] | ClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutUserInput | ClassCreateOrConnectWithoutUserInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutUserInput | ClassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassCreateManyUserInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutUserInput | ClassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutUserInput | ClassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAuthenticatorInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAuthenticatorNestedInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    upsert?: UserUpsertWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthenticatorInput, UserUpdateWithoutAuthenticatorInput>, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type EducationCreaterolesInput = {
    set: string[]
  }

  export type SectorCreateNestedManyWithoutEducationInput = {
    create?: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput> | SectorCreateWithoutEducationInput[] | SectorUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutEducationInput | SectorCreateOrConnectWithoutEducationInput[]
    createMany?: SectorCreateManyEducationInputEnvelope
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutSectorInput = {
    create?: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput> | TradeCreateWithoutSectorInput[] | TradeUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutSectorInput | TradeCreateOrConnectWithoutSectorInput[]
    createMany?: TradeCreateManySectorInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type SectorUncheckedCreateNestedManyWithoutEducationInput = {
    create?: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput> | SectorCreateWithoutEducationInput[] | SectorUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutEducationInput | SectorCreateOrConnectWithoutEducationInput[]
    createMany?: SectorCreateManyEducationInputEnvelope
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutSectorInput = {
    create?: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput> | TradeCreateWithoutSectorInput[] | TradeUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutSectorInput | TradeCreateOrConnectWithoutSectorInput[]
    createMany?: TradeCreateManySectorInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type EducationUpdaterolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SectorUpdateManyWithoutEducationNestedInput = {
    create?: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput> | SectorCreateWithoutEducationInput[] | SectorUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutEducationInput | SectorCreateOrConnectWithoutEducationInput[]
    upsert?: SectorUpsertWithWhereUniqueWithoutEducationInput | SectorUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: SectorCreateManyEducationInputEnvelope
    set?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    disconnect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    delete?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    update?: SectorUpdateWithWhereUniqueWithoutEducationInput | SectorUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: SectorUpdateManyWithWhereWithoutEducationInput | SectorUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: SectorScalarWhereInput | SectorScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutSectorNestedInput = {
    create?: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput> | TradeCreateWithoutSectorInput[] | TradeUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutSectorInput | TradeCreateOrConnectWithoutSectorInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutSectorInput | TradeUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: TradeCreateManySectorInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutSectorInput | TradeUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutSectorInput | TradeUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type SectorUncheckedUpdateManyWithoutEducationNestedInput = {
    create?: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput> | SectorCreateWithoutEducationInput[] | SectorUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutEducationInput | SectorCreateOrConnectWithoutEducationInput[]
    upsert?: SectorUpsertWithWhereUniqueWithoutEducationInput | SectorUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: SectorCreateManyEducationInputEnvelope
    set?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    disconnect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    delete?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    update?: SectorUpdateWithWhereUniqueWithoutEducationInput | SectorUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: SectorUpdateManyWithWhereWithoutEducationInput | SectorUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: SectorScalarWhereInput | SectorScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutSectorNestedInput = {
    create?: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput> | TradeCreateWithoutSectorInput[] | TradeUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutSectorInput | TradeCreateOrConnectWithoutSectorInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutSectorInput | TradeUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: TradeCreateManySectorInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutSectorInput | TradeUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutSectorInput | TradeUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type EducationCreateNestedOneWithoutSectorInput = {
    create?: XOR<EducationCreateWithoutSectorInput, EducationUncheckedCreateWithoutSectorInput>
    connectOrCreate?: EducationCreateOrConnectWithoutSectorInput
    connect?: EducationWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutSectorInput = {
    create?: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput> | ClassRoomCreateWithoutSectorInput[] | ClassRoomUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSectorInput | ClassRoomCreateOrConnectWithoutSectorInput[]
    createMany?: ClassRoomCreateManySectorInputEnvelope
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSectorInput = {
    create?: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput> | ClassCreateWithoutSectorInput[] | ClassUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSectorInput | ClassCreateOrConnectWithoutSectorInput[]
    createMany?: ClassCreateManySectorInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutSectorInput = {
    create?: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput> | ClassRoomCreateWithoutSectorInput[] | ClassRoomUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSectorInput | ClassRoomCreateOrConnectWithoutSectorInput[]
    createMany?: ClassRoomCreateManySectorInputEnvelope
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSectorInput = {
    create?: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput> | ClassCreateWithoutSectorInput[] | ClassUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSectorInput | ClassCreateOrConnectWithoutSectorInput[]
    createMany?: ClassCreateManySectorInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type EducationUpdateOneRequiredWithoutSectorNestedInput = {
    create?: XOR<EducationCreateWithoutSectorInput, EducationUncheckedCreateWithoutSectorInput>
    connectOrCreate?: EducationCreateOrConnectWithoutSectorInput
    upsert?: EducationUpsertWithoutSectorInput
    connect?: EducationWhereUniqueInput
    update?: XOR<XOR<EducationUpdateToOneWithWhereWithoutSectorInput, EducationUpdateWithoutSectorInput>, EducationUncheckedUpdateWithoutSectorInput>
  }

  export type ClassRoomUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput> | ClassRoomCreateWithoutSectorInput[] | ClassRoomUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSectorInput | ClassRoomCreateOrConnectWithoutSectorInput[]
    upsert?: ClassRoomUpsertWithWhereUniqueWithoutSectorInput | ClassRoomUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ClassRoomCreateManySectorInputEnvelope
    set?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    disconnect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    delete?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    update?: ClassRoomUpdateWithWhereUniqueWithoutSectorInput | ClassRoomUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ClassRoomUpdateManyWithWhereWithoutSectorInput | ClassRoomUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput> | ClassCreateWithoutSectorInput[] | ClassUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSectorInput | ClassCreateOrConnectWithoutSectorInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSectorInput | ClassUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ClassCreateManySectorInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSectorInput | ClassUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSectorInput | ClassUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassRoomUncheckedUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput> | ClassRoomCreateWithoutSectorInput[] | ClassRoomUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSectorInput | ClassRoomCreateOrConnectWithoutSectorInput[]
    upsert?: ClassRoomUpsertWithWhereUniqueWithoutSectorInput | ClassRoomUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ClassRoomCreateManySectorInputEnvelope
    set?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    disconnect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    delete?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    update?: ClassRoomUpdateWithWhereUniqueWithoutSectorInput | ClassRoomUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ClassRoomUpdateManyWithWhereWithoutSectorInput | ClassRoomUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput> | ClassCreateWithoutSectorInput[] | ClassUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSectorInput | ClassCreateOrConnectWithoutSectorInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSectorInput | ClassUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ClassCreateManySectorInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSectorInput | ClassUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSectorInput | ClassUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type EducationCreateNestedOneWithoutTradeInput = {
    create?: XOR<EducationCreateWithoutTradeInput, EducationUncheckedCreateWithoutTradeInput>
    connectOrCreate?: EducationCreateOrConnectWithoutTradeInput
    connect?: EducationWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutTradeInput = {
    create?: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput> | ClassRoomCreateWithoutTradeInput[] | ClassRoomUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTradeInput | ClassRoomCreateOrConnectWithoutTradeInput[]
    createMany?: ClassRoomCreateManyTradeInputEnvelope
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutTradeInput = {
    create?: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput> | ClassCreateWithoutTradeInput[] | ClassUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTradeInput | ClassCreateOrConnectWithoutTradeInput[]
    createMany?: ClassCreateManyTradeInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutTradeInput = {
    create?: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput> | ClassRoomCreateWithoutTradeInput[] | ClassRoomUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTradeInput | ClassRoomCreateOrConnectWithoutTradeInput[]
    createMany?: ClassRoomCreateManyTradeInputEnvelope
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTradeInput = {
    create?: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput> | ClassCreateWithoutTradeInput[] | ClassUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTradeInput | ClassCreateOrConnectWithoutTradeInput[]
    createMany?: ClassCreateManyTradeInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type EducationUpdateOneRequiredWithoutTradeNestedInput = {
    create?: XOR<EducationCreateWithoutTradeInput, EducationUncheckedCreateWithoutTradeInput>
    connectOrCreate?: EducationCreateOrConnectWithoutTradeInput
    upsert?: EducationUpsertWithoutTradeInput
    connect?: EducationWhereUniqueInput
    update?: XOR<XOR<EducationUpdateToOneWithWhereWithoutTradeInput, EducationUpdateWithoutTradeInput>, EducationUncheckedUpdateWithoutTradeInput>
  }

  export type ClassRoomUpdateManyWithoutTradeNestedInput = {
    create?: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput> | ClassRoomCreateWithoutTradeInput[] | ClassRoomUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTradeInput | ClassRoomCreateOrConnectWithoutTradeInput[]
    upsert?: ClassRoomUpsertWithWhereUniqueWithoutTradeInput | ClassRoomUpsertWithWhereUniqueWithoutTradeInput[]
    createMany?: ClassRoomCreateManyTradeInputEnvelope
    set?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    disconnect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    delete?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    update?: ClassRoomUpdateWithWhereUniqueWithoutTradeInput | ClassRoomUpdateWithWhereUniqueWithoutTradeInput[]
    updateMany?: ClassRoomUpdateManyWithWhereWithoutTradeInput | ClassRoomUpdateManyWithWhereWithoutTradeInput[]
    deleteMany?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutTradeNestedInput = {
    create?: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput> | ClassCreateWithoutTradeInput[] | ClassUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTradeInput | ClassCreateOrConnectWithoutTradeInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTradeInput | ClassUpsertWithWhereUniqueWithoutTradeInput[]
    createMany?: ClassCreateManyTradeInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTradeInput | ClassUpdateWithWhereUniqueWithoutTradeInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTradeInput | ClassUpdateManyWithWhereWithoutTradeInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassRoomUncheckedUpdateManyWithoutTradeNestedInput = {
    create?: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput> | ClassRoomCreateWithoutTradeInput[] | ClassRoomUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTradeInput | ClassRoomCreateOrConnectWithoutTradeInput[]
    upsert?: ClassRoomUpsertWithWhereUniqueWithoutTradeInput | ClassRoomUpsertWithWhereUniqueWithoutTradeInput[]
    createMany?: ClassRoomCreateManyTradeInputEnvelope
    set?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    disconnect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    delete?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    connect?: ClassRoomWhereUniqueInput | ClassRoomWhereUniqueInput[]
    update?: ClassRoomUpdateWithWhereUniqueWithoutTradeInput | ClassRoomUpdateWithWhereUniqueWithoutTradeInput[]
    updateMany?: ClassRoomUpdateManyWithWhereWithoutTradeInput | ClassRoomUpdateManyWithWhereWithoutTradeInput[]
    deleteMany?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTradeNestedInput = {
    create?: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput> | ClassCreateWithoutTradeInput[] | ClassUncheckedCreateWithoutTradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTradeInput | ClassCreateOrConnectWithoutTradeInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTradeInput | ClassUpsertWithWhereUniqueWithoutTradeInput[]
    createMany?: ClassCreateManyTradeInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTradeInput | ClassUpdateWithWhereUniqueWithoutTradeInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTradeInput | ClassUpdateManyWithWhereWithoutTradeInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TradeCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<TradeCreateWithoutClassRoomInput, TradeUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TradeCreateOrConnectWithoutClassRoomInput
    connect?: TradeWhereUniqueInput
  }

  export type SectorCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<SectorCreateWithoutClassRoomInput, SectorUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SectorCreateOrConnectWithoutClassRoomInput
    connect?: SectorWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutClassTeacherInput = {
    create?: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput> | ClassCreateWithoutClassTeacherInput[] | ClassUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassTeacherInput | ClassCreateOrConnectWithoutClassTeacherInput[]
    createMany?: ClassCreateManyClassTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput> | SubjectCreateWithoutClassRoomInput[] | SubjectUncheckedCreateWithoutClassRoomInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassRoomInput | SubjectCreateOrConnectWithoutClassRoomInput[]
    createMany?: SubjectCreateManyClassRoomInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutClassTeacherInput = {
    create?: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput> | ClassCreateWithoutClassTeacherInput[] | ClassUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassTeacherInput | ClassCreateOrConnectWithoutClassTeacherInput[]
    createMany?: ClassCreateManyClassTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput> | SubjectCreateWithoutClassRoomInput[] | SubjectUncheckedCreateWithoutClassRoomInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassRoomInput | SubjectCreateOrConnectWithoutClassRoomInput[]
    createMany?: SubjectCreateManyClassRoomInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type EnumClassRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClassRoomType
  }

  export type TradeUpdateOneWithoutClassRoomNestedInput = {
    create?: XOR<TradeCreateWithoutClassRoomInput, TradeUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TradeCreateOrConnectWithoutClassRoomInput
    upsert?: TradeUpsertWithoutClassRoomInput
    disconnect?: boolean
    delete?: TradeWhereInput | boolean
    connect?: TradeWhereUniqueInput
    update?: XOR<XOR<TradeUpdateToOneWithWhereWithoutClassRoomInput, TradeUpdateWithoutClassRoomInput>, TradeUncheckedUpdateWithoutClassRoomInput>
  }

  export type SectorUpdateOneWithoutClassRoomNestedInput = {
    create?: XOR<SectorCreateWithoutClassRoomInput, SectorUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SectorCreateOrConnectWithoutClassRoomInput
    upsert?: SectorUpsertWithoutClassRoomInput
    disconnect?: boolean
    delete?: SectorWhereInput | boolean
    connect?: SectorWhereUniqueInput
    update?: XOR<XOR<SectorUpdateToOneWithWhereWithoutClassRoomInput, SectorUpdateWithoutClassRoomInput>, SectorUncheckedUpdateWithoutClassRoomInput>
  }

  export type ClassUpdateManyWithoutClassTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput> | ClassCreateWithoutClassTeacherInput[] | ClassUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassTeacherInput | ClassCreateOrConnectWithoutClassTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClassTeacherInput | ClassUpsertWithWhereUniqueWithoutClassTeacherInput[]
    createMany?: ClassCreateManyClassTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClassTeacherInput | ClassUpdateWithWhereUniqueWithoutClassTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClassTeacherInput | ClassUpdateManyWithWhereWithoutClassTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput> | SubjectCreateWithoutClassRoomInput[] | SubjectUncheckedCreateWithoutClassRoomInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassRoomInput | SubjectCreateOrConnectWithoutClassRoomInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassRoomInput | SubjectUpsertWithWhereUniqueWithoutClassRoomInput[]
    createMany?: SubjectCreateManyClassRoomInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassRoomInput | SubjectUpdateWithWhereUniqueWithoutClassRoomInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassRoomInput | SubjectUpdateManyWithWhereWithoutClassRoomInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutClassTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput> | ClassCreateWithoutClassTeacherInput[] | ClassUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassTeacherInput | ClassCreateOrConnectWithoutClassTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClassTeacherInput | ClassUpsertWithWhereUniqueWithoutClassTeacherInput[]
    createMany?: ClassCreateManyClassTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClassTeacherInput | ClassUpdateWithWhereUniqueWithoutClassTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClassTeacherInput | ClassUpdateManyWithWhereWithoutClassTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput> | SubjectCreateWithoutClassRoomInput[] | SubjectUncheckedCreateWithoutClassRoomInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassRoomInput | SubjectCreateOrConnectWithoutClassRoomInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassRoomInput | SubjectUpsertWithWhereUniqueWithoutClassRoomInput[]
    createMany?: SubjectCreateManyClassRoomInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassRoomInput | SubjectUpdateWithWhereUniqueWithoutClassRoomInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassRoomInput | SubjectUpdateManyWithWhereWithoutClassRoomInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SubClassCreateNestedManyWithoutClassInput = {
    create?: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput> | SubClassCreateWithoutClassInput[] | SubClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubClassCreateOrConnectWithoutClassInput | SubClassCreateOrConnectWithoutClassInput[]
    createMany?: SubClassCreateManyClassInputEnvelope
    connect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
  }

  export type TradeCreateNestedOneWithoutClassInput = {
    create?: XOR<TradeCreateWithoutClassInput, TradeUncheckedCreateWithoutClassInput>
    connectOrCreate?: TradeCreateOrConnectWithoutClassInput
    connect?: TradeWhereUniqueInput
  }

  export type SectorCreateNestedOneWithoutClassInput = {
    create?: XOR<SectorCreateWithoutClassInput, SectorUncheckedCreateWithoutClassInput>
    connectOrCreate?: SectorCreateOrConnectWithoutClassInput
    connect?: SectorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassInput = {
    create?: XOR<UserCreateWithoutClassInput, UserUncheckedCreateWithoutClassInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassInput
    connect?: UserWhereUniqueInput
  }

  export type ClassRoomCreateNestedOneWithoutClassInput = {
    create?: XOR<ClassRoomCreateWithoutClassInput, ClassRoomUncheckedCreateWithoutClassInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutClassInput
    connect?: ClassRoomWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutClassInput = {
    create?: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput> | PostCreateWithoutClassInput[] | PostUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PostCreateOrConnectWithoutClassInput | PostCreateOrConnectWithoutClassInput[]
    createMany?: PostCreateManyClassInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput> | SubjectCreateWithoutClassInput[] | SubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassInput | SubjectCreateOrConnectWithoutClassInput[]
    createMany?: SubjectCreateManyClassInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ModelCreateNestedManyWithoutClassInput = {
    create?: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput> | ModelCreateWithoutClassInput[] | ModelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutClassInput | ModelCreateOrConnectWithoutClassInput[]
    createMany?: ModelCreateManyClassInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SubClassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput> | SubClassCreateWithoutClassInput[] | SubClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubClassCreateOrConnectWithoutClassInput | SubClassCreateOrConnectWithoutClassInput[]
    createMany?: SubClassCreateManyClassInputEnvelope
    connect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput> | PostCreateWithoutClassInput[] | PostUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PostCreateOrConnectWithoutClassInput | PostCreateOrConnectWithoutClassInput[]
    createMany?: PostCreateManyClassInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput> | SubjectCreateWithoutClassInput[] | SubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassInput | SubjectCreateOrConnectWithoutClassInput[]
    createMany?: SubjectCreateManyClassInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput> | ModelCreateWithoutClassInput[] | ModelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutClassInput | ModelCreateOrConnectWithoutClassInput[]
    createMany?: ModelCreateManyClassInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type NullableEnumClassTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClassType | null
    unset?: boolean
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SubClassUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput> | SubClassCreateWithoutClassInput[] | SubClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubClassCreateOrConnectWithoutClassInput | SubClassCreateOrConnectWithoutClassInput[]
    upsert?: SubClassUpsertWithWhereUniqueWithoutClassInput | SubClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubClassCreateManyClassInputEnvelope
    set?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    disconnect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    delete?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    connect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    update?: SubClassUpdateWithWhereUniqueWithoutClassInput | SubClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubClassUpdateManyWithWhereWithoutClassInput | SubClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubClassScalarWhereInput | SubClassScalarWhereInput[]
  }

  export type TradeUpdateOneWithoutClassNestedInput = {
    create?: XOR<TradeCreateWithoutClassInput, TradeUncheckedCreateWithoutClassInput>
    connectOrCreate?: TradeCreateOrConnectWithoutClassInput
    upsert?: TradeUpsertWithoutClassInput
    disconnect?: boolean
    delete?: TradeWhereInput | boolean
    connect?: TradeWhereUniqueInput
    update?: XOR<XOR<TradeUpdateToOneWithWhereWithoutClassInput, TradeUpdateWithoutClassInput>, TradeUncheckedUpdateWithoutClassInput>
  }

  export type SectorUpdateOneWithoutClassNestedInput = {
    create?: XOR<SectorCreateWithoutClassInput, SectorUncheckedCreateWithoutClassInput>
    connectOrCreate?: SectorCreateOrConnectWithoutClassInput
    upsert?: SectorUpsertWithoutClassInput
    disconnect?: boolean
    delete?: SectorWhereInput | boolean
    connect?: SectorWhereUniqueInput
    update?: XOR<XOR<SectorUpdateToOneWithWhereWithoutClassInput, SectorUpdateWithoutClassInput>, SectorUncheckedUpdateWithoutClassInput>
  }

  export type UserUpdateOneWithoutClassNestedInput = {
    create?: XOR<UserCreateWithoutClassInput, UserUncheckedCreateWithoutClassInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassInput
    upsert?: UserUpsertWithoutClassInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassInput, UserUpdateWithoutClassInput>, UserUncheckedUpdateWithoutClassInput>
  }

  export type ClassRoomUpdateOneWithoutClassNestedInput = {
    create?: XOR<ClassRoomCreateWithoutClassInput, ClassRoomUncheckedCreateWithoutClassInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutClassInput
    upsert?: ClassRoomUpsertWithoutClassInput
    disconnect?: boolean
    delete?: ClassRoomWhereInput | boolean
    connect?: ClassRoomWhereUniqueInput
    update?: XOR<XOR<ClassRoomUpdateToOneWithWhereWithoutClassInput, ClassRoomUpdateWithoutClassInput>, ClassRoomUncheckedUpdateWithoutClassInput>
  }

  export type PostUpdateManyWithoutClassNestedInput = {
    create?: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput> | PostCreateWithoutClassInput[] | PostUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PostCreateOrConnectWithoutClassInput | PostCreateOrConnectWithoutClassInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutClassInput | PostUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PostCreateManyClassInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutClassInput | PostUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PostUpdateManyWithWhereWithoutClassInput | PostUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput> | SubjectCreateWithoutClassInput[] | SubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassInput | SubjectCreateOrConnectWithoutClassInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassInput | SubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectCreateManyClassInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassInput | SubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassInput | SubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ModelUpdateManyWithoutClassNestedInput = {
    create?: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput> | ModelCreateWithoutClassInput[] | ModelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutClassInput | ModelCreateOrConnectWithoutClassInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutClassInput | ModelUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ModelCreateManyClassInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutClassInput | ModelUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutClassInput | ModelUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SubClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput> | SubClassCreateWithoutClassInput[] | SubClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubClassCreateOrConnectWithoutClassInput | SubClassCreateOrConnectWithoutClassInput[]
    upsert?: SubClassUpsertWithWhereUniqueWithoutClassInput | SubClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubClassCreateManyClassInputEnvelope
    set?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    disconnect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    delete?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    connect?: SubClassWhereUniqueInput | SubClassWhereUniqueInput[]
    update?: SubClassUpdateWithWhereUniqueWithoutClassInput | SubClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubClassUpdateManyWithWhereWithoutClassInput | SubClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubClassScalarWhereInput | SubClassScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput> | PostCreateWithoutClassInput[] | PostUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PostCreateOrConnectWithoutClassInput | PostCreateOrConnectWithoutClassInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutClassInput | PostUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PostCreateManyClassInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutClassInput | PostUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PostUpdateManyWithWhereWithoutClassInput | PostUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput> | SubjectCreateWithoutClassInput[] | SubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassInput | SubjectCreateOrConnectWithoutClassInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassInput | SubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectCreateManyClassInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassInput | SubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassInput | SubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput> | ModelCreateWithoutClassInput[] | ModelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutClassInput | ModelCreateOrConnectWithoutClassInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutClassInput | ModelUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ModelCreateManyClassInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutClassInput | ModelUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutClassInput | ModelUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutSubClassInput = {
    create?: XOR<ClassCreateWithoutSubClassInput, ClassUncheckedCreateWithoutSubClassInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubClassInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassUpdateOneWithoutSubClassNestedInput = {
    create?: XOR<ClassCreateWithoutSubClassInput, ClassUncheckedCreateWithoutSubClassInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubClassInput
    upsert?: ClassUpsertWithoutSubClassInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubClassInput, ClassUpdateWithoutSubClassInput>, ClassUncheckedUpdateWithoutSubClassInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentInput = {
    create?: XOR<ClassCreateWithoutStudentInput, ClassUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ClassUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ClassCreateWithoutStudentInput, ClassUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentInput
    upsert?: ClassUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentInput, ClassUpdateWithoutStudentInput>, ClassUncheckedUpdateWithoutStudentInput>
  }

  export type TeacherCreateclassesIdInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherUpdateclassesIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserCreateNestedOneWithoutPostInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutPostInput = {
    create?: XOR<ClassCreateWithoutPostInput, ClassUncheckedCreateWithoutPostInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPostInput
    connect?: ClassWhereUniqueInput
  }

  export type EnumPostRoleFieldUpdateOperationsInput = {
    set?: $Enums.PostRole
  }

  export type UserUpdateOneWithoutPostNestedInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    upsert?: UserUpsertWithoutPostInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostInput, UserUpdateWithoutPostInput>, UserUncheckedUpdateWithoutPostInput>
  }

  export type ClassUpdateOneWithoutPostNestedInput = {
    create?: XOR<ClassCreateWithoutPostInput, ClassUncheckedCreateWithoutPostInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPostInput
    upsert?: ClassUpsertWithoutPostInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutPostInput, ClassUpdateWithoutPostInput>, ClassUncheckedUpdateWithoutPostInput>
  }

  export type KnowledgeCreateNestedManyWithoutSubjectInput = {
    create?: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput> | KnowledgeCreateWithoutSubjectInput[] | KnowledgeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutSubjectInput | KnowledgeCreateOrConnectWithoutSubjectInput[]
    createMany?: KnowledgeCreateManySubjectInputEnvelope
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput> | ResourceCreateWithoutSubjectInput[] | ResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSubjectInput | ResourceCreateOrConnectWithoutSubjectInput[]
    createMany?: ResourceCreateManySubjectInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type CompetenceCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput> | CompetenceCreateWithoutSubjectInput[] | CompetenceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutSubjectInput | CompetenceCreateOrConnectWithoutSubjectInput[]
    createMany?: CompetenceCreateManySubjectInputEnvelope
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
  }

  export type AssessmentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput> | AssessmentCreateWithoutSubjectInput[] | AssessmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutSubjectInput | AssessmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssessmentCreateManySubjectInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type LearningOutcomeCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput> | LearningOutcomeCreateWithoutSubjectInput[] | LearningOutcomeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutSubjectInput | LearningOutcomeCreateOrConnectWithoutSubjectInput[]
    createMany?: LearningOutcomeCreateManySubjectInputEnvelope
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
  }

  export type IndicativeContentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput> | IndicativeContentCreateWithoutSubjectInput[] | IndicativeContentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutSubjectInput | IndicativeContentCreateOrConnectWithoutSubjectInput[]
    createMany?: IndicativeContentCreateManySubjectInputEnvelope
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput> | SkillCreateWithoutSubjectInput[] | SkillUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSubjectInput | SkillCreateOrConnectWithoutSubjectInput[]
    createMany?: SkillCreateManySubjectInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type AttitudeCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput> | AttitudeCreateWithoutSubjectInput[] | AttitudeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttitudeCreateOrConnectWithoutSubjectInput | AttitudeCreateOrConnectWithoutSubjectInput[]
    createMany?: AttitudeCreateManySubjectInputEnvelope
    connect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
  }

  export type ClassCreateNestedOneWithoutSubjectInput = {
    create?: XOR<ClassCreateWithoutSubjectInput, ClassUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassRoomCreateNestedOneWithoutSubjectInput = {
    create?: XOR<ClassRoomCreateWithoutSubjectInput, ClassRoomUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSubjectInput
    connect?: ClassRoomWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutSubjectInput = {
    create?: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput> | NoteCreateWithoutSubjectInput[] | NoteUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutSubjectInput | NoteCreateOrConnectWithoutSubjectInput[]
    createMany?: NoteCreateManySubjectInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ModelCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput> | ModelCreateWithoutSubjectInput[] | ModelUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutSubjectInput | ModelCreateOrConnectWithoutSubjectInput[]
    createMany?: ModelCreateManySubjectInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type KnowledgeUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput> | KnowledgeCreateWithoutSubjectInput[] | KnowledgeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutSubjectInput | KnowledgeCreateOrConnectWithoutSubjectInput[]
    createMany?: KnowledgeCreateManySubjectInputEnvelope
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput> | ResourceCreateWithoutSubjectInput[] | ResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSubjectInput | ResourceCreateOrConnectWithoutSubjectInput[]
    createMany?: ResourceCreateManySubjectInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type CompetenceUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput> | CompetenceCreateWithoutSubjectInput[] | CompetenceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutSubjectInput | CompetenceCreateOrConnectWithoutSubjectInput[]
    createMany?: CompetenceCreateManySubjectInputEnvelope
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
  }

  export type AssessmentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput> | AssessmentCreateWithoutSubjectInput[] | AssessmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutSubjectInput | AssessmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssessmentCreateManySubjectInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput> | LearningOutcomeCreateWithoutSubjectInput[] | LearningOutcomeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutSubjectInput | LearningOutcomeCreateOrConnectWithoutSubjectInput[]
    createMany?: LearningOutcomeCreateManySubjectInputEnvelope
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
  }

  export type IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput> | IndicativeContentCreateWithoutSubjectInput[] | IndicativeContentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutSubjectInput | IndicativeContentCreateOrConnectWithoutSubjectInput[]
    createMany?: IndicativeContentCreateManySubjectInputEnvelope
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput> | SkillCreateWithoutSubjectInput[] | SkillUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSubjectInput | SkillCreateOrConnectWithoutSubjectInput[]
    createMany?: SkillCreateManySubjectInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type AttitudeUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput> | AttitudeCreateWithoutSubjectInput[] | AttitudeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttitudeCreateOrConnectWithoutSubjectInput | AttitudeCreateOrConnectWithoutSubjectInput[]
    createMany?: AttitudeCreateManySubjectInputEnvelope
    connect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput> | NoteCreateWithoutSubjectInput[] | NoteUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutSubjectInput | NoteCreateOrConnectWithoutSubjectInput[]
    createMany?: NoteCreateManySubjectInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput> | ModelCreateWithoutSubjectInput[] | ModelUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutSubjectInput | ModelCreateOrConnectWithoutSubjectInput[]
    createMany?: ModelCreateManySubjectInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type NullableEnumSubjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubjectType | null
    unset?: boolean
  }

  export type KnowledgeUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput> | KnowledgeCreateWithoutSubjectInput[] | KnowledgeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutSubjectInput | KnowledgeCreateOrConnectWithoutSubjectInput[]
    upsert?: KnowledgeUpsertWithWhereUniqueWithoutSubjectInput | KnowledgeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: KnowledgeCreateManySubjectInputEnvelope
    set?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    disconnect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    delete?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    update?: KnowledgeUpdateWithWhereUniqueWithoutSubjectInput | KnowledgeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: KnowledgeUpdateManyWithWhereWithoutSubjectInput | KnowledgeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput> | ResourceCreateWithoutSubjectInput[] | ResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSubjectInput | ResourceCreateOrConnectWithoutSubjectInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSubjectInput | ResourceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ResourceCreateManySubjectInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSubjectInput | ResourceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSubjectInput | ResourceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type CompetenceUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput> | CompetenceCreateWithoutSubjectInput[] | CompetenceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutSubjectInput | CompetenceCreateOrConnectWithoutSubjectInput[]
    upsert?: CompetenceUpsertWithWhereUniqueWithoutSubjectInput | CompetenceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CompetenceCreateManySubjectInputEnvelope
    set?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    disconnect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    delete?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    update?: CompetenceUpdateWithWhereUniqueWithoutSubjectInput | CompetenceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CompetenceUpdateManyWithWhereWithoutSubjectInput | CompetenceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
  }

  export type AssessmentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput> | AssessmentCreateWithoutSubjectInput[] | AssessmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutSubjectInput | AssessmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutSubjectInput | AssessmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssessmentCreateManySubjectInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutSubjectInput | AssessmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutSubjectInput | AssessmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type LearningOutcomeUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput> | LearningOutcomeCreateWithoutSubjectInput[] | LearningOutcomeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutSubjectInput | LearningOutcomeCreateOrConnectWithoutSubjectInput[]
    upsert?: LearningOutcomeUpsertWithWhereUniqueWithoutSubjectInput | LearningOutcomeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LearningOutcomeCreateManySubjectInputEnvelope
    set?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    disconnect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    delete?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    update?: LearningOutcomeUpdateWithWhereUniqueWithoutSubjectInput | LearningOutcomeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LearningOutcomeUpdateManyWithWhereWithoutSubjectInput | LearningOutcomeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
  }

  export type IndicativeContentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput> | IndicativeContentCreateWithoutSubjectInput[] | IndicativeContentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutSubjectInput | IndicativeContentCreateOrConnectWithoutSubjectInput[]
    upsert?: IndicativeContentUpsertWithWhereUniqueWithoutSubjectInput | IndicativeContentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: IndicativeContentCreateManySubjectInputEnvelope
    set?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    disconnect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    delete?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    update?: IndicativeContentUpdateWithWhereUniqueWithoutSubjectInput | IndicativeContentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: IndicativeContentUpdateManyWithWhereWithoutSubjectInput | IndicativeContentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput> | SkillCreateWithoutSubjectInput[] | SkillUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSubjectInput | SkillCreateOrConnectWithoutSubjectInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutSubjectInput | SkillUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SkillCreateManySubjectInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutSubjectInput | SkillUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutSubjectInput | SkillUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type AttitudeUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput> | AttitudeCreateWithoutSubjectInput[] | AttitudeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttitudeCreateOrConnectWithoutSubjectInput | AttitudeCreateOrConnectWithoutSubjectInput[]
    upsert?: AttitudeUpsertWithWhereUniqueWithoutSubjectInput | AttitudeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttitudeCreateManySubjectInputEnvelope
    set?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    disconnect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    delete?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    connect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    update?: AttitudeUpdateWithWhereUniqueWithoutSubjectInput | AttitudeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttitudeUpdateManyWithWhereWithoutSubjectInput | AttitudeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttitudeScalarWhereInput | AttitudeScalarWhereInput[]
  }

  export type ClassUpdateOneWithoutSubjectNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectInput, ClassUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectInput
    upsert?: ClassUpsertWithoutSubjectInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubjectInput, ClassUpdateWithoutSubjectInput>, ClassUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassRoomUpdateOneWithoutSubjectNestedInput = {
    create?: XOR<ClassRoomCreateWithoutSubjectInput, ClassRoomUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutSubjectInput
    upsert?: ClassRoomUpsertWithoutSubjectInput
    disconnect?: boolean
    delete?: ClassRoomWhereInput | boolean
    connect?: ClassRoomWhereUniqueInput
    update?: XOR<XOR<ClassRoomUpdateToOneWithWhereWithoutSubjectInput, ClassRoomUpdateWithoutSubjectInput>, ClassRoomUncheckedUpdateWithoutSubjectInput>
  }

  export type NoteUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput> | NoteCreateWithoutSubjectInput[] | NoteUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutSubjectInput | NoteCreateOrConnectWithoutSubjectInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutSubjectInput | NoteUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: NoteCreateManySubjectInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutSubjectInput | NoteUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutSubjectInput | NoteUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ModelUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput> | ModelCreateWithoutSubjectInput[] | ModelUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutSubjectInput | ModelCreateOrConnectWithoutSubjectInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutSubjectInput | ModelUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ModelCreateManySubjectInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutSubjectInput | ModelUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutSubjectInput | ModelUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput> | KnowledgeCreateWithoutSubjectInput[] | KnowledgeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutSubjectInput | KnowledgeCreateOrConnectWithoutSubjectInput[]
    upsert?: KnowledgeUpsertWithWhereUniqueWithoutSubjectInput | KnowledgeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: KnowledgeCreateManySubjectInputEnvelope
    set?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    disconnect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    delete?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    update?: KnowledgeUpdateWithWhereUniqueWithoutSubjectInput | KnowledgeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: KnowledgeUpdateManyWithWhereWithoutSubjectInput | KnowledgeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput> | ResourceCreateWithoutSubjectInput[] | ResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSubjectInput | ResourceCreateOrConnectWithoutSubjectInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSubjectInput | ResourceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ResourceCreateManySubjectInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSubjectInput | ResourceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSubjectInput | ResourceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type CompetenceUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput> | CompetenceCreateWithoutSubjectInput[] | CompetenceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutSubjectInput | CompetenceCreateOrConnectWithoutSubjectInput[]
    upsert?: CompetenceUpsertWithWhereUniqueWithoutSubjectInput | CompetenceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CompetenceCreateManySubjectInputEnvelope
    set?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    disconnect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    delete?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    update?: CompetenceUpdateWithWhereUniqueWithoutSubjectInput | CompetenceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CompetenceUpdateManyWithWhereWithoutSubjectInput | CompetenceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
  }

  export type AssessmentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput> | AssessmentCreateWithoutSubjectInput[] | AssessmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutSubjectInput | AssessmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutSubjectInput | AssessmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssessmentCreateManySubjectInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutSubjectInput | AssessmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutSubjectInput | AssessmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput> | LearningOutcomeCreateWithoutSubjectInput[] | LearningOutcomeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutSubjectInput | LearningOutcomeCreateOrConnectWithoutSubjectInput[]
    upsert?: LearningOutcomeUpsertWithWhereUniqueWithoutSubjectInput | LearningOutcomeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LearningOutcomeCreateManySubjectInputEnvelope
    set?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    disconnect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    delete?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    connect?: LearningOutcomeWhereUniqueInput | LearningOutcomeWhereUniqueInput[]
    update?: LearningOutcomeUpdateWithWhereUniqueWithoutSubjectInput | LearningOutcomeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LearningOutcomeUpdateManyWithWhereWithoutSubjectInput | LearningOutcomeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
  }

  export type IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput> | IndicativeContentCreateWithoutSubjectInput[] | IndicativeContentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutSubjectInput | IndicativeContentCreateOrConnectWithoutSubjectInput[]
    upsert?: IndicativeContentUpsertWithWhereUniqueWithoutSubjectInput | IndicativeContentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: IndicativeContentCreateManySubjectInputEnvelope
    set?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    disconnect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    delete?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    update?: IndicativeContentUpdateWithWhereUniqueWithoutSubjectInput | IndicativeContentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: IndicativeContentUpdateManyWithWhereWithoutSubjectInput | IndicativeContentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput> | SkillCreateWithoutSubjectInput[] | SkillUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSubjectInput | SkillCreateOrConnectWithoutSubjectInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutSubjectInput | SkillUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SkillCreateManySubjectInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutSubjectInput | SkillUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutSubjectInput | SkillUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type AttitudeUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput> | AttitudeCreateWithoutSubjectInput[] | AttitudeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttitudeCreateOrConnectWithoutSubjectInput | AttitudeCreateOrConnectWithoutSubjectInput[]
    upsert?: AttitudeUpsertWithWhereUniqueWithoutSubjectInput | AttitudeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttitudeCreateManySubjectInputEnvelope
    set?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    disconnect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    delete?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    connect?: AttitudeWhereUniqueInput | AttitudeWhereUniqueInput[]
    update?: AttitudeUpdateWithWhereUniqueWithoutSubjectInput | AttitudeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttitudeUpdateManyWithWhereWithoutSubjectInput | AttitudeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttitudeScalarWhereInput | AttitudeScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput> | NoteCreateWithoutSubjectInput[] | NoteUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutSubjectInput | NoteCreateOrConnectWithoutSubjectInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutSubjectInput | NoteUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: NoteCreateManySubjectInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutSubjectInput | NoteUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutSubjectInput | NoteUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput> | ModelCreateWithoutSubjectInput[] | ModelUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutSubjectInput | ModelCreateOrConnectWithoutSubjectInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutSubjectInput | ModelUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ModelCreateManySubjectInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutSubjectInput | ModelUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutSubjectInput | ModelUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type IndicativeContentCreateNestedManyWithoutLearningOutcomeInput = {
    create?: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput> | IndicativeContentCreateWithoutLearningOutcomeInput[] | IndicativeContentUncheckedCreateWithoutLearningOutcomeInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutLearningOutcomeInput | IndicativeContentCreateOrConnectWithoutLearningOutcomeInput[]
    createMany?: IndicativeContentCreateManyLearningOutcomeInputEnvelope
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
  }

  export type SubjectCreateNestedOneWithoutLearningOutcomeInput = {
    create?: XOR<SubjectCreateWithoutLearningOutcomeInput, SubjectUncheckedCreateWithoutLearningOutcomeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutLearningOutcomeInput
    connect?: SubjectWhereUniqueInput
  }

  export type IndicativeContentUncheckedCreateNestedManyWithoutLearningOutcomeInput = {
    create?: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput> | IndicativeContentCreateWithoutLearningOutcomeInput[] | IndicativeContentUncheckedCreateWithoutLearningOutcomeInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutLearningOutcomeInput | IndicativeContentCreateOrConnectWithoutLearningOutcomeInput[]
    createMany?: IndicativeContentCreateManyLearningOutcomeInputEnvelope
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
  }

  export type IndicativeContentUpdateManyWithoutLearningOutcomeNestedInput = {
    create?: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput> | IndicativeContentCreateWithoutLearningOutcomeInput[] | IndicativeContentUncheckedCreateWithoutLearningOutcomeInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutLearningOutcomeInput | IndicativeContentCreateOrConnectWithoutLearningOutcomeInput[]
    upsert?: IndicativeContentUpsertWithWhereUniqueWithoutLearningOutcomeInput | IndicativeContentUpsertWithWhereUniqueWithoutLearningOutcomeInput[]
    createMany?: IndicativeContentCreateManyLearningOutcomeInputEnvelope
    set?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    disconnect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    delete?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    update?: IndicativeContentUpdateWithWhereUniqueWithoutLearningOutcomeInput | IndicativeContentUpdateWithWhereUniqueWithoutLearningOutcomeInput[]
    updateMany?: IndicativeContentUpdateManyWithWhereWithoutLearningOutcomeInput | IndicativeContentUpdateManyWithWhereWithoutLearningOutcomeInput[]
    deleteMany?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
  }

  export type SubjectUpdateOneWithoutLearningOutcomeNestedInput = {
    create?: XOR<SubjectCreateWithoutLearningOutcomeInput, SubjectUncheckedCreateWithoutLearningOutcomeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutLearningOutcomeInput
    upsert?: SubjectUpsertWithoutLearningOutcomeInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutLearningOutcomeInput, SubjectUpdateWithoutLearningOutcomeInput>, SubjectUncheckedUpdateWithoutLearningOutcomeInput>
  }

  export type IndicativeContentUncheckedUpdateManyWithoutLearningOutcomeNestedInput = {
    create?: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput> | IndicativeContentCreateWithoutLearningOutcomeInput[] | IndicativeContentUncheckedCreateWithoutLearningOutcomeInput[]
    connectOrCreate?: IndicativeContentCreateOrConnectWithoutLearningOutcomeInput | IndicativeContentCreateOrConnectWithoutLearningOutcomeInput[]
    upsert?: IndicativeContentUpsertWithWhereUniqueWithoutLearningOutcomeInput | IndicativeContentUpsertWithWhereUniqueWithoutLearningOutcomeInput[]
    createMany?: IndicativeContentCreateManyLearningOutcomeInputEnvelope
    set?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    disconnect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    delete?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    connect?: IndicativeContentWhereUniqueInput | IndicativeContentWhereUniqueInput[]
    update?: IndicativeContentUpdateWithWhereUniqueWithoutLearningOutcomeInput | IndicativeContentUpdateWithWhereUniqueWithoutLearningOutcomeInput[]
    updateMany?: IndicativeContentUpdateManyWithWhereWithoutLearningOutcomeInput | IndicativeContentUpdateManyWithWhereWithoutLearningOutcomeInput[]
    deleteMany?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
  }

  export type SubjectCreateNestedOneWithoutIndicativeContentInput = {
    create?: XOR<SubjectCreateWithoutIndicativeContentInput, SubjectUncheckedCreateWithoutIndicativeContentInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutIndicativeContentInput
    connect?: SubjectWhereUniqueInput
  }

  export type LearningOutcomeCreateNestedOneWithoutIndicativeContentInput = {
    create?: XOR<LearningOutcomeCreateWithoutIndicativeContentInput, LearningOutcomeUncheckedCreateWithoutIndicativeContentInput>
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutIndicativeContentInput
    connect?: LearningOutcomeWhereUniqueInput
  }

  export type SubjectUpdateOneWithoutIndicativeContentNestedInput = {
    create?: XOR<SubjectCreateWithoutIndicativeContentInput, SubjectUncheckedCreateWithoutIndicativeContentInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutIndicativeContentInput
    upsert?: SubjectUpsertWithoutIndicativeContentInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutIndicativeContentInput, SubjectUpdateWithoutIndicativeContentInput>, SubjectUncheckedUpdateWithoutIndicativeContentInput>
  }

  export type LearningOutcomeUpdateOneRequiredWithoutIndicativeContentNestedInput = {
    create?: XOR<LearningOutcomeCreateWithoutIndicativeContentInput, LearningOutcomeUncheckedCreateWithoutIndicativeContentInput>
    connectOrCreate?: LearningOutcomeCreateOrConnectWithoutIndicativeContentInput
    upsert?: LearningOutcomeUpsertWithoutIndicativeContentInput
    connect?: LearningOutcomeWhereUniqueInput
    update?: XOR<XOR<LearningOutcomeUpdateToOneWithWhereWithoutIndicativeContentInput, LearningOutcomeUpdateWithoutIndicativeContentInput>, LearningOutcomeUncheckedUpdateWithoutIndicativeContentInput>
  }

  export type SubjectCreateNestedOneWithoutKnowledgeInput = {
    create?: XOR<SubjectCreateWithoutKnowledgeInput, SubjectUncheckedCreateWithoutKnowledgeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutKnowledgeInput
    connect?: SubjectWhereUniqueInput
  }

  export type SubjectUpdateOneWithoutKnowledgeNestedInput = {
    create?: XOR<SubjectCreateWithoutKnowledgeInput, SubjectUncheckedCreateWithoutKnowledgeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutKnowledgeInput
    upsert?: SubjectUpsertWithoutKnowledgeInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutKnowledgeInput, SubjectUpdateWithoutKnowledgeInput>, SubjectUncheckedUpdateWithoutKnowledgeInput>
  }

  export type SubjectCreateNestedOneWithoutSkillInput = {
    create?: XOR<SubjectCreateWithoutSkillInput, SubjectUncheckedCreateWithoutSkillInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSkillInput
    connect?: SubjectWhereUniqueInput
  }

  export type SubjectUpdateOneWithoutSkillNestedInput = {
    create?: XOR<SubjectCreateWithoutSkillInput, SubjectUncheckedCreateWithoutSkillInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSkillInput
    upsert?: SubjectUpsertWithoutSkillInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutSkillInput, SubjectUpdateWithoutSkillInput>, SubjectUncheckedUpdateWithoutSkillInput>
  }

  export type SubjectCreateNestedOneWithoutAttitudeInput = {
    create?: XOR<SubjectCreateWithoutAttitudeInput, SubjectUncheckedCreateWithoutAttitudeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttitudeInput
    connect?: SubjectWhereUniqueInput
  }

  export type SubjectUpdateOneWithoutAttitudeNestedInput = {
    create?: XOR<SubjectCreateWithoutAttitudeInput, SubjectUncheckedCreateWithoutAttitudeInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttitudeInput
    upsert?: SubjectUpsertWithoutAttitudeInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAttitudeInput, SubjectUpdateWithoutAttitudeInput>, SubjectUncheckedUpdateWithoutAttitudeInput>
  }

  export type SubjectCreateNestedOneWithoutResourceInput = {
    create?: XOR<SubjectCreateWithoutResourceInput, SubjectUncheckedCreateWithoutResourceInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResourceInput
    connect?: SubjectWhereUniqueInput
  }

  export type NullableEnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType | null
    unset?: boolean
  }

  export type SubjectUpdateOneWithoutResourceNestedInput = {
    create?: XOR<SubjectCreateWithoutResourceInput, SubjectUncheckedCreateWithoutResourceInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResourceInput
    upsert?: SubjectUpsertWithoutResourceInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutResourceInput, SubjectUpdateWithoutResourceInput>, SubjectUncheckedUpdateWithoutResourceInput>
  }

  export type PerformanceCriteriaCreateNestedManyWithoutCompetenceInput = {
    create?: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput> | PerformanceCriteriaCreateWithoutCompetenceInput[] | PerformanceCriteriaUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PerformanceCriteriaCreateOrConnectWithoutCompetenceInput | PerformanceCriteriaCreateOrConnectWithoutCompetenceInput[]
    createMany?: PerformanceCriteriaCreateManyCompetenceInputEnvelope
    connect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
  }

  export type SubjectCreateNestedOneWithoutCompetenceInput = {
    create?: XOR<SubjectCreateWithoutCompetenceInput, SubjectUncheckedCreateWithoutCompetenceInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCompetenceInput
    connect?: SubjectWhereUniqueInput
  }

  export type PerformanceCriteriaUncheckedCreateNestedManyWithoutCompetenceInput = {
    create?: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput> | PerformanceCriteriaCreateWithoutCompetenceInput[] | PerformanceCriteriaUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PerformanceCriteriaCreateOrConnectWithoutCompetenceInput | PerformanceCriteriaCreateOrConnectWithoutCompetenceInput[]
    createMany?: PerformanceCriteriaCreateManyCompetenceInputEnvelope
    connect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
  }

  export type PerformanceCriteriaUpdateManyWithoutCompetenceNestedInput = {
    create?: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput> | PerformanceCriteriaCreateWithoutCompetenceInput[] | PerformanceCriteriaUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PerformanceCriteriaCreateOrConnectWithoutCompetenceInput | PerformanceCriteriaCreateOrConnectWithoutCompetenceInput[]
    upsert?: PerformanceCriteriaUpsertWithWhereUniqueWithoutCompetenceInput | PerformanceCriteriaUpsertWithWhereUniqueWithoutCompetenceInput[]
    createMany?: PerformanceCriteriaCreateManyCompetenceInputEnvelope
    set?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    disconnect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    delete?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    connect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    update?: PerformanceCriteriaUpdateWithWhereUniqueWithoutCompetenceInput | PerformanceCriteriaUpdateWithWhereUniqueWithoutCompetenceInput[]
    updateMany?: PerformanceCriteriaUpdateManyWithWhereWithoutCompetenceInput | PerformanceCriteriaUpdateManyWithWhereWithoutCompetenceInput[]
    deleteMany?: PerformanceCriteriaScalarWhereInput | PerformanceCriteriaScalarWhereInput[]
  }

  export type SubjectUpdateOneWithoutCompetenceNestedInput = {
    create?: XOR<SubjectCreateWithoutCompetenceInput, SubjectUncheckedCreateWithoutCompetenceInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCompetenceInput
    upsert?: SubjectUpsertWithoutCompetenceInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutCompetenceInput, SubjectUpdateWithoutCompetenceInput>, SubjectUncheckedUpdateWithoutCompetenceInput>
  }

  export type PerformanceCriteriaUncheckedUpdateManyWithoutCompetenceNestedInput = {
    create?: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput> | PerformanceCriteriaCreateWithoutCompetenceInput[] | PerformanceCriteriaUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PerformanceCriteriaCreateOrConnectWithoutCompetenceInput | PerformanceCriteriaCreateOrConnectWithoutCompetenceInput[]
    upsert?: PerformanceCriteriaUpsertWithWhereUniqueWithoutCompetenceInput | PerformanceCriteriaUpsertWithWhereUniqueWithoutCompetenceInput[]
    createMany?: PerformanceCriteriaCreateManyCompetenceInputEnvelope
    set?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    disconnect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    delete?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    connect?: PerformanceCriteriaWhereUniqueInput | PerformanceCriteriaWhereUniqueInput[]
    update?: PerformanceCriteriaUpdateWithWhereUniqueWithoutCompetenceInput | PerformanceCriteriaUpdateWithWhereUniqueWithoutCompetenceInput[]
    updateMany?: PerformanceCriteriaUpdateManyWithWhereWithoutCompetenceInput | PerformanceCriteriaUpdateManyWithWhereWithoutCompetenceInput[]
    deleteMany?: PerformanceCriteriaScalarWhereInput | PerformanceCriteriaScalarWhereInput[]
  }

  export type CompetenceCreateNestedOneWithoutPerformanceCriteriaInput = {
    create?: XOR<CompetenceCreateWithoutPerformanceCriteriaInput, CompetenceUncheckedCreateWithoutPerformanceCriteriaInput>
    connectOrCreate?: CompetenceCreateOrConnectWithoutPerformanceCriteriaInput
    connect?: CompetenceWhereUniqueInput
  }

  export type CompetenceUpdateOneWithoutPerformanceCriteriaNestedInput = {
    create?: XOR<CompetenceCreateWithoutPerformanceCriteriaInput, CompetenceUncheckedCreateWithoutPerformanceCriteriaInput>
    connectOrCreate?: CompetenceCreateOrConnectWithoutPerformanceCriteriaInput
    upsert?: CompetenceUpsertWithoutPerformanceCriteriaInput
    disconnect?: boolean
    delete?: CompetenceWhereInput | boolean
    connect?: CompetenceWhereUniqueInput
    update?: XOR<XOR<CompetenceUpdateToOneWithWhereWithoutPerformanceCriteriaInput, CompetenceUpdateWithoutPerformanceCriteriaInput>, CompetenceUncheckedUpdateWithoutPerformanceCriteriaInput>
  }

  export type SubjectCreateNestedOneWithoutAssessmentInput = {
    create?: XOR<SubjectCreateWithoutAssessmentInput, SubjectUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssessmentInput
    connect?: SubjectWhereUniqueInput
  }

  export type NullableEnumAssessmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssessmentType | null
    unset?: boolean
  }

  export type SubjectUpdateOneWithoutAssessmentNestedInput = {
    create?: XOR<SubjectCreateWithoutAssessmentInput, SubjectUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssessmentInput
    upsert?: SubjectUpsertWithoutAssessmentInput
    disconnect?: boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAssessmentInput, SubjectUpdateWithoutAssessmentInput>, SubjectUncheckedUpdateWithoutAssessmentInput>
  }

  export type NoteCreateseenByInput = {
    set: string[]
  }

  export type NoteCreatecommentsIdsInput = {
    set: string[]
  }

  export type SubjectCreateNestedOneWithoutNoteInput = {
    create?: XOR<SubjectCreateWithoutNoteInput, SubjectUncheckedCreateWithoutNoteInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutNoteInput
    connect?: SubjectWhereUniqueInput
  }

  export type NoteUpdateseenByInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NoteUpdatecommentsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubjectUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<SubjectCreateWithoutNoteInput, SubjectUncheckedCreateWithoutNoteInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutNoteInput
    upsert?: SubjectUpsertWithoutNoteInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutNoteInput, SubjectUpdateWithoutNoteInput>, SubjectUncheckedUpdateWithoutNoteInput>
  }

  export type ClassCreateNestedOneWithoutModelInput = {
    create?: XOR<ClassCreateWithoutModelInput, ClassUncheckedCreateWithoutModelInput>
    connectOrCreate?: ClassCreateOrConnectWithoutModelInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutModelInput = {
    create?: XOR<SubjectCreateWithoutModelInput, SubjectUncheckedCreateWithoutModelInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutModelInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassUpdateOneWithoutModelNestedInput = {
    create?: XOR<ClassCreateWithoutModelInput, ClassUncheckedCreateWithoutModelInput>
    connectOrCreate?: ClassCreateOrConnectWithoutModelInput
    upsert?: ClassUpsertWithoutModelInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutModelInput, ClassUpdateWithoutModelInput>, ClassUncheckedUpdateWithoutModelInput>
  }

  export type SubjectUpdateOneRequiredWithoutModelNestedInput = {
    create?: XOR<SubjectCreateWithoutModelInput, SubjectUncheckedCreateWithoutModelInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutModelInput
    upsert?: SubjectUpsertWithoutModelInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutModelInput, SubjectUpdateWithoutModelInput>, SubjectUncheckedUpdateWithoutModelInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumClassRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassRoomType | EnumClassRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClassRoomTypeFilter<$PrismaModel> | $Enums.ClassRoomType
  }

  export type NestedEnumClassRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassRoomType | EnumClassRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassRoomType[] | ListEnumClassRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClassRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClassRoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumClassRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumClassTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassType | EnumClassTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClassTypeNullableFilter<$PrismaModel> | $Enums.ClassType | null
    isSet?: boolean
  }

  export type NestedEnumClassTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassType | EnumClassTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClassType[] | ListEnumClassTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClassTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClassType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClassTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumClassTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumPostRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PostRole | EnumPostRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPostRoleFilter<$PrismaModel> | $Enums.PostRole
  }

  export type NestedEnumPostRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostRole | EnumPostRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostRole[] | ListEnumPostRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPostRoleWithAggregatesFilter<$PrismaModel> | $Enums.PostRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostRoleFilter<$PrismaModel>
    _max?: NestedEnumPostRoleFilter<$PrismaModel>
  }

  export type NestedEnumSubjectTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubjectType | EnumSubjectTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectTypeNullableFilter<$PrismaModel> | $Enums.SubjectType | null
    isSet?: boolean
  }

  export type NestedEnumSubjectTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubjectType | EnumSubjectTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubjectType[] | ListEnumSubjectTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubjectType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubjectTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSubjectTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumResourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableFilter<$PrismaModel> | $Enums.ResourceType | null
    isSet?: boolean
  }

  export type NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumAssessmentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel> | $Enums.AssessmentType | null
    isSet?: boolean
  }

  export type NestedEnumAssessmentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAssessmentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAssessmentTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type AuthenticatorCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUncheckedCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorCreateOrConnectWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorCreateManyUserInputEnvelope = {
    data: AuthenticatorCreateManyUserInput | AuthenticatorCreateManyUserInput[]
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    subClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    subClassId?: string | null
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateManyUserInputEnvelope = {
    data: StudentCreateManyUserInput | StudentCreateManyUserInput[]
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateManyUserInputEnvelope = {
    data: TeacherCreateManyUserInput | TeacherCreateManyUserInput[]
  }

  export type ClassCreateWithoutUserInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutUserInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput>
  }

  export type ClassCreateManyUserInputEnvelope = {
    data: ClassCreateManyUserInput | ClassCreateManyUserInput[]
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuthenticatorUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    update: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    data: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
  }

  export type AuthenticatorUpdateManyWithWhereWithoutUserInput = {
    where: AuthenticatorScalarWhereInput
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthenticatorScalarWhereInput = {
    AND?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    OR?: AuthenticatorScalarWhereInput[]
    NOT?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
  }

  export type StudentUpsertWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateManyWithWhereWithoutUserInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutUserInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    subClassId?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type TeacherUpsertWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateManyWithWhereWithoutUserInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutUserInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    classesId?: StringNullableListFilter<"Teacher">
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutUserInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutUserInput, ClassUncheckedUpdateWithoutUserInput>
    create: XOR<ClassCreateWithoutUserInput, ClassUncheckedCreateWithoutUserInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutUserInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutUserInput, ClassUncheckedUpdateWithoutUserInput>
  }

  export type ClassUpdateManyWithWhereWithoutUserInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutUserInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    username?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    code?: StringFilter<"Class"> | string
    symbol?: StringNullableFilter<"Class"> | string | null
    disabled?: BoolFilter<"Class"> | boolean
    sectorId?: StringNullableFilter<"Class"> | string | null
    tradeId?: StringNullableFilter<"Class"> | string | null
    classRoomId?: StringNullableFilter<"Class"> | string | null
    userId?: StringFilter<"Class"> | string
    classType?: EnumClassTypeNullableFilter<"Class"> | $Enums.ClassType | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    file?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    role?: EnumPostRoleFilter<"Post"> | $Enums.PostRole
    classId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuthenticatorInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthenticatorInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthenticatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
  }

  export type UserUpsertWithoutAuthenticatorInput = {
    update: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthenticatorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type UserUpdateWithoutAuthenticatorInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthenticatorInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SectorCreateWithoutEducationInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomCreateNestedManyWithoutSectorInput
    Class?: ClassCreateNestedManyWithoutSectorInput
  }

  export type SectorUncheckedCreateWithoutEducationInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutSectorInput
    Class?: ClassUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorCreateOrConnectWithoutEducationInput = {
    where: SectorWhereUniqueInput
    create: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput>
  }

  export type SectorCreateManyEducationInputEnvelope = {
    data: SectorCreateManyEducationInput | SectorCreateManyEducationInput[]
  }

  export type TradeCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomCreateNestedManyWithoutTradeInput
    Class?: ClassCreateNestedManyWithoutTradeInput
  }

  export type TradeUncheckedCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutTradeInput
    Class?: ClassUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradeCreateOrConnectWithoutSectorInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput>
  }

  export type TradeCreateManySectorInputEnvelope = {
    data: TradeCreateManySectorInput | TradeCreateManySectorInput[]
  }

  export type SectorUpsertWithWhereUniqueWithoutEducationInput = {
    where: SectorWhereUniqueInput
    update: XOR<SectorUpdateWithoutEducationInput, SectorUncheckedUpdateWithoutEducationInput>
    create: XOR<SectorCreateWithoutEducationInput, SectorUncheckedCreateWithoutEducationInput>
  }

  export type SectorUpdateWithWhereUniqueWithoutEducationInput = {
    where: SectorWhereUniqueInput
    data: XOR<SectorUpdateWithoutEducationInput, SectorUncheckedUpdateWithoutEducationInput>
  }

  export type SectorUpdateManyWithWhereWithoutEducationInput = {
    where: SectorScalarWhereInput
    data: XOR<SectorUpdateManyMutationInput, SectorUncheckedUpdateManyWithoutEducationInput>
  }

  export type SectorScalarWhereInput = {
    AND?: SectorScalarWhereInput | SectorScalarWhereInput[]
    OR?: SectorScalarWhereInput[]
    NOT?: SectorScalarWhereInput | SectorScalarWhereInput[]
    id?: StringFilter<"Sector"> | string
    educationId?: StringFilter<"Sector"> | string
    username?: StringFilter<"Sector"> | string
    name?: StringFilter<"Sector"> | string
    description?: StringNullableFilter<"Sector"> | string | null
    symbol?: StringNullableFilter<"Sector"> | string | null
    disabled?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
  }

  export type TradeUpsertWithWhereUniqueWithoutSectorInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutSectorInput, TradeUncheckedUpdateWithoutSectorInput>
    create: XOR<TradeCreateWithoutSectorInput, TradeUncheckedCreateWithoutSectorInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutSectorInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutSectorInput, TradeUncheckedUpdateWithoutSectorInput>
  }

  export type TradeUpdateManyWithWhereWithoutSectorInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutSectorInput>
  }

  export type TradeScalarWhereInput = {
    AND?: TradeScalarWhereInput | TradeScalarWhereInput[]
    OR?: TradeScalarWhereInput[]
    NOT?: TradeScalarWhereInput | TradeScalarWhereInput[]
    id?: StringFilter<"Trade"> | string
    name?: StringFilter<"Trade"> | string
    username?: StringFilter<"Trade"> | string
    description?: StringNullableFilter<"Trade"> | string | null
    sectorId?: StringFilter<"Trade"> | string
    limitClasses?: IntFilter<"Trade"> | number
    symbol?: StringNullableFilter<"Trade"> | string | null
    disabled?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
  }

  export type EducationCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Trade?: TradeCreateNestedManyWithoutSectorInput
  }

  export type EducationUncheckedCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Trade?: TradeUncheckedCreateNestedManyWithoutSectorInput
  }

  export type EducationCreateOrConnectWithoutSectorInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutSectorInput, EducationUncheckedCreateWithoutSectorInput>
  }

  export type ClassRoomCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trade?: TradeCreateNestedOneWithoutClassRoomInput
    Class?: ClassCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutSectorInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput>
  }

  export type ClassRoomCreateManySectorInputEnvelope = {
    data: ClassRoomCreateManySectorInput | ClassRoomCreateManySectorInput[]
  }

  export type ClassCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSectorInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput>
  }

  export type ClassCreateManySectorInputEnvelope = {
    data: ClassCreateManySectorInput | ClassCreateManySectorInput[]
  }

  export type EducationUpsertWithoutSectorInput = {
    update: XOR<EducationUpdateWithoutSectorInput, EducationUncheckedUpdateWithoutSectorInput>
    create: XOR<EducationCreateWithoutSectorInput, EducationUncheckedCreateWithoutSectorInput>
    where?: EducationWhereInput
  }

  export type EducationUpdateToOneWithWhereWithoutSectorInput = {
    where?: EducationWhereInput
    data: XOR<EducationUpdateWithoutSectorInput, EducationUncheckedUpdateWithoutSectorInput>
  }

  export type EducationUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Trade?: TradeUpdateManyWithoutSectorNestedInput
  }

  export type EducationUncheckedUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Trade?: TradeUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutSectorInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutSectorInput, ClassRoomUncheckedUpdateWithoutSectorInput>
    create: XOR<ClassRoomCreateWithoutSectorInput, ClassRoomUncheckedCreateWithoutSectorInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutSectorInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutSectorInput, ClassRoomUncheckedUpdateWithoutSectorInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutSectorInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutSectorInput>
  }

  export type ClassRoomScalarWhereInput = {
    AND?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
    OR?: ClassRoomScalarWhereInput[]
    NOT?: ClassRoomScalarWhereInput | ClassRoomScalarWhereInput[]
    id?: StringFilter<"ClassRoom"> | string
    name?: StringFilter<"ClassRoom"> | string
    username?: StringFilter<"ClassRoom"> | string
    description?: StringNullableFilter<"ClassRoom"> | string | null
    symbol?: StringNullableFilter<"ClassRoom"> | string | null
    disabled?: BoolFilter<"ClassRoom"> | boolean
    ClassRoomType?: EnumClassRoomTypeFilter<"ClassRoom"> | $Enums.ClassRoomType
    sectorId?: StringNullableFilter<"ClassRoom"> | string | null
    tradeId?: StringNullableFilter<"ClassRoom"> | string | null
    code?: StringNullableFilter<"ClassRoom"> | string | null
    createdAt?: DateTimeFilter<"ClassRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ClassRoom"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSectorInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSectorInput, ClassUncheckedUpdateWithoutSectorInput>
    create: XOR<ClassCreateWithoutSectorInput, ClassUncheckedCreateWithoutSectorInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSectorInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSectorInput, ClassUncheckedUpdateWithoutSectorInput>
  }

  export type ClassUpdateManyWithWhereWithoutSectorInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSectorInput>
  }

  export type EducationCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Sector?: SectorCreateNestedManyWithoutEducationInput
  }

  export type EducationUncheckedCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    roles?: EducationCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Sector?: SectorUncheckedCreateNestedManyWithoutEducationInput
  }

  export type EducationCreateOrConnectWithoutTradeInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutTradeInput, EducationUncheckedCreateWithoutTradeInput>
  }

  export type ClassRoomCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sector?: SectorCreateNestedOneWithoutClassRoomInput
    Class?: ClassCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutClassTeacherInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutTradeInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput>
  }

  export type ClassRoomCreateManyTradeInputEnvelope = {
    data: ClassRoomCreateManyTradeInput | ClassRoomCreateManyTradeInput[]
  }

  export type ClassCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTradeInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput>
  }

  export type ClassCreateManyTradeInputEnvelope = {
    data: ClassCreateManyTradeInput | ClassCreateManyTradeInput[]
  }

  export type EducationUpsertWithoutTradeInput = {
    update: XOR<EducationUpdateWithoutTradeInput, EducationUncheckedUpdateWithoutTradeInput>
    create: XOR<EducationCreateWithoutTradeInput, EducationUncheckedCreateWithoutTradeInput>
    where?: EducationWhereInput
  }

  export type EducationUpdateToOneWithWhereWithoutTradeInput = {
    where?: EducationWhereInput
    data: XOR<EducationUpdateWithoutTradeInput, EducationUncheckedUpdateWithoutTradeInput>
  }

  export type EducationUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sector?: SectorUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    roles?: EducationUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sector?: SectorUncheckedUpdateManyWithoutEducationNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutTradeInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutTradeInput, ClassRoomUncheckedUpdateWithoutTradeInput>
    create: XOR<ClassRoomCreateWithoutTradeInput, ClassRoomUncheckedCreateWithoutTradeInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutTradeInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutTradeInput, ClassRoomUncheckedUpdateWithoutTradeInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutTradeInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutTradeInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutTradeInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTradeInput, ClassUncheckedUpdateWithoutTradeInput>
    create: XOR<ClassCreateWithoutTradeInput, ClassUncheckedCreateWithoutTradeInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTradeInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTradeInput, ClassUncheckedUpdateWithoutTradeInput>
  }

  export type ClassUpdateManyWithWhereWithoutTradeInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTradeInput>
  }

  export type TradeCreateWithoutClassRoomInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sector: EducationCreateNestedOneWithoutTradeInput
    Class?: ClassCreateNestedManyWithoutTradeInput
  }

  export type TradeUncheckedCreateWithoutClassRoomInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    sectorId: string
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradeCreateOrConnectWithoutClassRoomInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutClassRoomInput, TradeUncheckedCreateWithoutClassRoomInput>
  }

  export type SectorCreateWithoutClassRoomInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    education: EducationCreateNestedOneWithoutSectorInput
    Class?: ClassCreateNestedManyWithoutSectorInput
  }

  export type SectorUncheckedCreateWithoutClassRoomInput = {
    id?: string
    educationId: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorCreateOrConnectWithoutClassRoomInput = {
    where: SectorWhereUniqueInput
    create: XOR<SectorCreateWithoutClassRoomInput, SectorUncheckedCreateWithoutClassRoomInput>
  }

  export type ClassCreateWithoutClassTeacherInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassTeacherInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClassTeacherInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput>
  }

  export type ClassCreateManyClassTeacherInputEnvelope = {
    data: ClassCreateManyClassTeacherInput | ClassCreateManyClassTeacherInput[]
  }

  export type SubjectCreateWithoutClassRoomInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassRoomInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassRoomInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput>
  }

  export type SubjectCreateManyClassRoomInputEnvelope = {
    data: SubjectCreateManyClassRoomInput | SubjectCreateManyClassRoomInput[]
  }

  export type TradeUpsertWithoutClassRoomInput = {
    update: XOR<TradeUpdateWithoutClassRoomInput, TradeUncheckedUpdateWithoutClassRoomInput>
    create: XOR<TradeCreateWithoutClassRoomInput, TradeUncheckedCreateWithoutClassRoomInput>
    where?: TradeWhereInput
  }

  export type TradeUpdateToOneWithWhereWithoutClassRoomInput = {
    where?: TradeWhereInput
    data: XOR<TradeUpdateWithoutClassRoomInput, TradeUncheckedUpdateWithoutClassRoomInput>
  }

  export type TradeUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EducationUpdateOneRequiredWithoutTradeNestedInput
    Class?: ClassUpdateManyWithoutTradeNestedInput
  }

  export type TradeUncheckedUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectorId?: StringFieldUpdateOperationsInput | string
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type SectorUpsertWithoutClassRoomInput = {
    update: XOR<SectorUpdateWithoutClassRoomInput, SectorUncheckedUpdateWithoutClassRoomInput>
    create: XOR<SectorCreateWithoutClassRoomInput, SectorUncheckedCreateWithoutClassRoomInput>
    where?: SectorWhereInput
  }

  export type SectorUpdateToOneWithWhereWithoutClassRoomInput = {
    where?: SectorWhereInput
    data: XOR<SectorUpdateWithoutClassRoomInput, SectorUncheckedUpdateWithoutClassRoomInput>
  }

  export type SectorUpdateWithoutClassRoomInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    education?: EducationUpdateOneRequiredWithoutSectorNestedInput
    Class?: ClassUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateWithoutClassRoomInput = {
    educationId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type ClassUpsertWithWhereUniqueWithoutClassTeacherInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutClassTeacherInput, ClassUncheckedUpdateWithoutClassTeacherInput>
    create: XOR<ClassCreateWithoutClassTeacherInput, ClassUncheckedCreateWithoutClassTeacherInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutClassTeacherInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutClassTeacherInput, ClassUncheckedUpdateWithoutClassTeacherInput>
  }

  export type ClassUpdateManyWithWhereWithoutClassTeacherInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutClassTeacherInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutClassRoomInput, SubjectUncheckedUpdateWithoutClassRoomInput>
    create: XOR<SubjectCreateWithoutClassRoomInput, SubjectUncheckedCreateWithoutClassRoomInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutClassRoomInput, SubjectUncheckedUpdateWithoutClassRoomInput>
  }

  export type SubjectUpdateManyWithWhereWithoutClassRoomInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    classRoomId?: StringNullableFilter<"Subject"> | string | null
    classId?: StringNullableFilter<"Subject"> | string | null
    code?: StringFilter<"Subject"> | string
    sectorId?: StringNullableFilter<"Subject"> | string | null
    tradeId?: StringNullableFilter<"Subject"> | string | null
    subjectType?: EnumSubjectTypeNullableFilter<"Subject"> | $Enums.SubjectType | null
    curriculum?: StringNullableFilter<"Subject"> | string | null
    copyright?: StringNullableFilter<"Subject"> | string | null
    learningHours?: IntNullableFilter<"Subject"> | number | null
    issueDate?: DateTimeNullableFilter<"Subject"> | Date | string | null
    purpose?: StringNullableFilter<"Subject"> | string | null
    symbol?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    subClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    subClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
  }

  export type SubClassCreateWithoutClassInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubClassUncheckedCreateWithoutClassInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubClassCreateOrConnectWithoutClassInput = {
    where: SubClassWhereUniqueInput
    create: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput>
  }

  export type SubClassCreateManyClassInputEnvelope = {
    data: SubClassCreateManyClassInput | SubClassCreateManyClassInput[]
  }

  export type TradeCreateWithoutClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sector: EducationCreateNestedOneWithoutTradeInput
    ClassRoom?: ClassRoomCreateNestedManyWithoutTradeInput
  }

  export type TradeUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    sectorId: string
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradeCreateOrConnectWithoutClassInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutClassInput, TradeUncheckedCreateWithoutClassInput>
  }

  export type SectorCreateWithoutClassInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    education: EducationCreateNestedOneWithoutSectorInput
    ClassRoom?: ClassRoomCreateNestedManyWithoutSectorInput
  }

  export type SectorUncheckedCreateWithoutClassInput = {
    id?: string
    educationId: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ClassRoom?: ClassRoomUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorCreateOrConnectWithoutClassInput = {
    where: SectorWhereUniqueInput
    create: XOR<SectorCreateWithoutClassInput, SectorUncheckedCreateWithoutClassInput>
  }

  export type UserCreateWithoutClassInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClassInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClassInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassInput, UserUncheckedCreateWithoutClassInput>
  }

  export type ClassRoomCreateWithoutClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trade?: TradeCreateNestedOneWithoutClassRoomInput
    sector?: SectorCreateNestedOneWithoutClassRoomInput
    Subject?: SubjectCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutClassInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutClassInput, ClassRoomUncheckedCreateWithoutClassInput>
  }

  export type PostCreateWithoutClassInput = {
    id?: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutClassInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput>
  }

  export type PostCreateManyClassInputEnvelope = {
    data: PostCreateManyClassInput | PostCreateManyClassInput[]
  }

  export type SubjectCreateWithoutClassInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput>
  }

  export type SubjectCreateManyClassInputEnvelope = {
    data: SubjectCreateManyClassInput | SubjectCreateManyClassInput[]
  }

  export type ModelCreateWithoutClassInput = {
    id?: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Subject: SubjectCreateNestedOneWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCreateOrConnectWithoutClassInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput>
  }

  export type ModelCreateManyClassInputEnvelope = {
    data: ModelCreateManyClassInput | ModelCreateManyClassInput[]
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type SubClassUpsertWithWhereUniqueWithoutClassInput = {
    where: SubClassWhereUniqueInput
    update: XOR<SubClassUpdateWithoutClassInput, SubClassUncheckedUpdateWithoutClassInput>
    create: XOR<SubClassCreateWithoutClassInput, SubClassUncheckedCreateWithoutClassInput>
  }

  export type SubClassUpdateWithWhereUniqueWithoutClassInput = {
    where: SubClassWhereUniqueInput
    data: XOR<SubClassUpdateWithoutClassInput, SubClassUncheckedUpdateWithoutClassInput>
  }

  export type SubClassUpdateManyWithWhereWithoutClassInput = {
    where: SubClassScalarWhereInput
    data: XOR<SubClassUpdateManyMutationInput, SubClassUncheckedUpdateManyWithoutClassInput>
  }

  export type SubClassScalarWhereInput = {
    AND?: SubClassScalarWhereInput | SubClassScalarWhereInput[]
    OR?: SubClassScalarWhereInput[]
    NOT?: SubClassScalarWhereInput | SubClassScalarWhereInput[]
    id?: StringFilter<"SubClass"> | string
    classId?: StringFilter<"SubClass"> | string
    code?: StringFilter<"SubClass"> | string
    name?: StringFilter<"SubClass"> | string
    createdAt?: DateTimeFilter<"SubClass"> | Date | string
    updatedAt?: DateTimeFilter<"SubClass"> | Date | string
  }

  export type TradeUpsertWithoutClassInput = {
    update: XOR<TradeUpdateWithoutClassInput, TradeUncheckedUpdateWithoutClassInput>
    create: XOR<TradeCreateWithoutClassInput, TradeUncheckedCreateWithoutClassInput>
    where?: TradeWhereInput
  }

  export type TradeUpdateToOneWithWhereWithoutClassInput = {
    where?: TradeWhereInput
    data: XOR<TradeUpdateWithoutClassInput, TradeUncheckedUpdateWithoutClassInput>
  }

  export type TradeUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: EducationUpdateOneRequiredWithoutTradeNestedInput
    ClassRoom?: ClassRoomUpdateManyWithoutTradeNestedInput
  }

  export type TradeUncheckedUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sectorId?: StringFieldUpdateOperationsInput | string
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type SectorUpsertWithoutClassInput = {
    update: XOR<SectorUpdateWithoutClassInput, SectorUncheckedUpdateWithoutClassInput>
    create: XOR<SectorCreateWithoutClassInput, SectorUncheckedCreateWithoutClassInput>
    where?: SectorWhereInput
  }

  export type SectorUpdateToOneWithWhereWithoutClassInput = {
    where?: SectorWhereInput
    data: XOR<SectorUpdateWithoutClassInput, SectorUncheckedUpdateWithoutClassInput>
  }

  export type SectorUpdateWithoutClassInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    education?: EducationUpdateOneRequiredWithoutSectorNestedInput
    ClassRoom?: ClassRoomUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateWithoutClassInput = {
    educationId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type UserUpsertWithoutClassInput = {
    update: XOR<UserUpdateWithoutClassInput, UserUncheckedUpdateWithoutClassInput>
    create: XOR<UserCreateWithoutClassInput, UserUncheckedCreateWithoutClassInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassInput, UserUncheckedUpdateWithoutClassInput>
  }

  export type UserUpdateWithoutClassInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassRoomUpsertWithoutClassInput = {
    update: XOR<ClassRoomUpdateWithoutClassInput, ClassRoomUncheckedUpdateWithoutClassInput>
    create: XOR<ClassRoomCreateWithoutClassInput, ClassRoomUncheckedCreateWithoutClassInput>
    where?: ClassRoomWhereInput
  }

  export type ClassRoomUpdateToOneWithWhereWithoutClassInput = {
    where?: ClassRoomWhereInput
    data: XOR<ClassRoomUpdateWithoutClassInput, ClassRoomUncheckedUpdateWithoutClassInput>
  }

  export type ClassRoomUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trade?: TradeUpdateOneWithoutClassRoomNestedInput
    sector?: SectorUpdateOneWithoutClassRoomNestedInput
    Subject?: SubjectUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: SubjectUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutClassInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutClassInput, PostUncheckedUpdateWithoutClassInput>
    create: XOR<PostCreateWithoutClassInput, PostUncheckedCreateWithoutClassInput>
  }

  export type PostUpdateWithWhereUniqueWithoutClassInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutClassInput, PostUncheckedUpdateWithoutClassInput>
  }

  export type PostUpdateManyWithWhereWithoutClassInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutClassInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutClassInput, SubjectUncheckedUpdateWithoutClassInput>
    create: XOR<SubjectCreateWithoutClassInput, SubjectUncheckedCreateWithoutClassInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutClassInput, SubjectUncheckedUpdateWithoutClassInput>
  }

  export type SubjectUpdateManyWithWhereWithoutClassInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type ModelUpsertWithWhereUniqueWithoutClassInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutClassInput, ModelUncheckedUpdateWithoutClassInput>
    create: XOR<ModelCreateWithoutClassInput, ModelUncheckedCreateWithoutClassInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutClassInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutClassInput, ModelUncheckedUpdateWithoutClassInput>
  }

  export type ModelUpdateManyWithWhereWithoutClassInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutClassInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: StringFilter<"Model"> | string
    teacherId?: StringFilter<"Model"> | string
    subjectId?: StringFilter<"Model"> | string
    classId?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
  }

  export type ClassCreateWithoutSubClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubClassInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubClassInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubClassInput, ClassUncheckedCreateWithoutSubClassInput>
  }

  export type ClassUpsertWithoutSubClassInput = {
    update: XOR<ClassUpdateWithoutSubClassInput, ClassUncheckedUpdateWithoutSubClassInput>
    create: XOR<ClassCreateWithoutSubClassInput, ClassUncheckedCreateWithoutSubClassInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubClassInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubClassInput, ClassUncheckedUpdateWithoutSubClassInput>
  }

  export type ClassUpdateWithoutSubClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ClassCreateWithoutStudentInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentInput, ClassUncheckedCreateWithoutStudentInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutStudentInput = {
    update: XOR<ClassUpdateWithoutStudentInput, ClassUncheckedUpdateWithoutStudentInput>
    create: XOR<ClassCreateWithoutStudentInput, ClassUncheckedCreateWithoutStudentInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentInput, ClassUncheckedUpdateWithoutStudentInput>
  }

  export type ClassUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
    Student?: StudentCreateNestedManyWithoutUserInput
    Teacher?: TeacherCreateNestedManyWithoutUserInput
    Class?: ClassCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    password?: string | null
    username?: string | null
    bio?: string | null
    age?: Date | string | null
    disabled?: boolean
    gender?: $Enums.Gender | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Student?: StudentUncheckedCreateNestedManyWithoutUserInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    Class?: ClassUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
  }

  export type ClassCreateWithoutPostInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutPostInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutPostInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutPostInput, ClassUncheckedCreateWithoutPostInput>
  }

  export type UserUpsertWithoutPostInput = {
    update: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
  }

  export type UserUpdateWithoutPostInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
    Student?: StudentUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUpdateManyWithoutUserNestedInput
    Class?: ClassUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    Class?: ClassUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutPostInput = {
    update: XOR<ClassUpdateWithoutPostInput, ClassUncheckedUpdateWithoutPostInput>
    create: XOR<ClassCreateWithoutPostInput, ClassUncheckedCreateWithoutPostInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutPostInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutPostInput, ClassUncheckedUpdateWithoutPostInput>
  }

  export type ClassUpdateWithoutPostInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutPostInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type KnowledgeCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUncheckedCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeCreateOrConnectWithoutSubjectInput = {
    where: KnowledgeWhereUniqueInput
    create: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput>
  }

  export type KnowledgeCreateManySubjectInputEnvelope = {
    data: KnowledgeCreateManySubjectInput | KnowledgeCreateManySubjectInput[]
  }

  export type ResourceCreateWithoutSubjectInput = {
    id?: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUncheckedCreateWithoutSubjectInput = {
    id?: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutSubjectInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput>
  }

  export type ResourceCreateManySubjectInputEnvelope = {
    data: ResourceCreateManySubjectInput | ResourceCreateManySubjectInput[]
  }

  export type CompetenceCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PerformanceCriteria?: PerformanceCriteriaCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceUncheckedCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PerformanceCriteria?: PerformanceCriteriaUncheckedCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceCreateOrConnectWithoutSubjectInput = {
    where: CompetenceWhereUniqueInput
    create: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput>
  }

  export type CompetenceCreateManySubjectInputEnvelope = {
    data: CompetenceCreateManySubjectInput | CompetenceCreateManySubjectInput[]
  }

  export type AssessmentCreateWithoutSubjectInput = {
    id?: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentUncheckedCreateWithoutSubjectInput = {
    id?: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentCreateOrConnectWithoutSubjectInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssessmentCreateManySubjectInputEnvelope = {
    data: AssessmentCreateManySubjectInput | AssessmentCreateManySubjectInput[]
  }

  export type LearningOutcomeCreateWithoutSubjectInput = {
    id?: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    indicativeContent?: IndicativeContentCreateNestedManyWithoutLearningOutcomeInput
  }

  export type LearningOutcomeUncheckedCreateWithoutSubjectInput = {
    id?: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    indicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutLearningOutcomeInput
  }

  export type LearningOutcomeCreateOrConnectWithoutSubjectInput = {
    where: LearningOutcomeWhereUniqueInput
    create: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput>
  }

  export type LearningOutcomeCreateManySubjectInputEnvelope = {
    data: LearningOutcomeCreateManySubjectInput | LearningOutcomeCreateManySubjectInput[]
  }

  export type IndicativeContentCreateWithoutSubjectInput = {
    id?: string
    content: string
    LearningOutcome: LearningOutcomeCreateNestedOneWithoutIndicativeContentInput
  }

  export type IndicativeContentUncheckedCreateWithoutSubjectInput = {
    id?: string
    content: string
  }

  export type IndicativeContentCreateOrConnectWithoutSubjectInput = {
    where: IndicativeContentWhereUniqueInput
    create: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput>
  }

  export type IndicativeContentCreateManySubjectInputEnvelope = {
    data: IndicativeContentCreateManySubjectInput | IndicativeContentCreateManySubjectInput[]
  }

  export type SkillCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUncheckedCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillCreateOrConnectWithoutSubjectInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput>
  }

  export type SkillCreateManySubjectInputEnvelope = {
    data: SkillCreateManySubjectInput | SkillCreateManySubjectInput[]
  }

  export type AttitudeCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttitudeUncheckedCreateWithoutSubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttitudeCreateOrConnectWithoutSubjectInput = {
    where: AttitudeWhereUniqueInput
    create: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput>
  }

  export type AttitudeCreateManySubjectInputEnvelope = {
    data: AttitudeCreateManySubjectInput | AttitudeCreateManySubjectInput[]
  }

  export type ClassCreateWithoutSubjectInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Model?: ModelCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubjectInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Model?: ModelUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubjectInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubjectInput, ClassUncheckedCreateWithoutSubjectInput>
  }

  export type ClassRoomCreateWithoutSubjectInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trade?: TradeCreateNestedOneWithoutClassRoomInput
    sector?: SectorCreateNestedOneWithoutClassRoomInput
    Class?: ClassCreateNestedManyWithoutClassTeacherInput
  }

  export type ClassRoomUncheckedCreateWithoutSubjectInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Class?: ClassUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type ClassRoomCreateOrConnectWithoutSubjectInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutSubjectInput, ClassRoomUncheckedCreateWithoutSubjectInput>
  }

  export type NoteCreateWithoutSubjectInput = {
    id?: string
    userId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUncheckedCreateWithoutSubjectInput = {
    id?: string
    userId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutSubjectInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput>
  }

  export type NoteCreateManySubjectInputEnvelope = {
    data: NoteCreateManySubjectInput | NoteCreateManySubjectInput[]
  }

  export type ModelCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCreateOrConnectWithoutSubjectInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput>
  }

  export type ModelCreateManySubjectInputEnvelope = {
    data: ModelCreateManySubjectInput | ModelCreateManySubjectInput[]
  }

  export type KnowledgeUpsertWithWhereUniqueWithoutSubjectInput = {
    where: KnowledgeWhereUniqueInput
    update: XOR<KnowledgeUpdateWithoutSubjectInput, KnowledgeUncheckedUpdateWithoutSubjectInput>
    create: XOR<KnowledgeCreateWithoutSubjectInput, KnowledgeUncheckedCreateWithoutSubjectInput>
  }

  export type KnowledgeUpdateWithWhereUniqueWithoutSubjectInput = {
    where: KnowledgeWhereUniqueInput
    data: XOR<KnowledgeUpdateWithoutSubjectInput, KnowledgeUncheckedUpdateWithoutSubjectInput>
  }

  export type KnowledgeUpdateManyWithWhereWithoutSubjectInput = {
    where: KnowledgeScalarWhereInput
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyWithoutSubjectInput>
  }

  export type KnowledgeScalarWhereInput = {
    AND?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
    OR?: KnowledgeScalarWhereInput[]
    NOT?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
    id?: StringFilter<"Knowledge"> | string
    SubjectId?: StringNullableFilter<"Knowledge"> | string | null
    description?: StringFilter<"Knowledge"> | string
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
  }

  export type ResourceUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutSubjectInput, ResourceUncheckedUpdateWithoutSubjectInput>
    create: XOR<ResourceCreateWithoutSubjectInput, ResourceUncheckedCreateWithoutSubjectInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutSubjectInput, ResourceUncheckedUpdateWithoutSubjectInput>
  }

  export type ResourceUpdateManyWithWhereWithoutSubjectInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    SubjectId?: StringFilter<"Resource"> | string
    category?: EnumResourceTypeNullableFilter<"Resource"> | $Enums.ResourceType | null
    description?: StringFilter<"Resource"> | string
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type CompetenceUpsertWithWhereUniqueWithoutSubjectInput = {
    where: CompetenceWhereUniqueInput
    update: XOR<CompetenceUpdateWithoutSubjectInput, CompetenceUncheckedUpdateWithoutSubjectInput>
    create: XOR<CompetenceCreateWithoutSubjectInput, CompetenceUncheckedCreateWithoutSubjectInput>
  }

  export type CompetenceUpdateWithWhereUniqueWithoutSubjectInput = {
    where: CompetenceWhereUniqueInput
    data: XOR<CompetenceUpdateWithoutSubjectInput, CompetenceUncheckedUpdateWithoutSubjectInput>
  }

  export type CompetenceUpdateManyWithWhereWithoutSubjectInput = {
    where: CompetenceScalarWhereInput
    data: XOR<CompetenceUpdateManyMutationInput, CompetenceUncheckedUpdateManyWithoutSubjectInput>
  }

  export type CompetenceScalarWhereInput = {
    AND?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
    OR?: CompetenceScalarWhereInput[]
    NOT?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
    id?: StringFilter<"Competence"> | string
    SubjectId?: StringFilter<"Competence"> | string
    description?: StringFilter<"Competence"> | string
    createdAt?: DateTimeFilter<"Competence"> | Date | string
    updatedAt?: DateTimeFilter<"Competence"> | Date | string
  }

  export type AssessmentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AssessmentWhereUniqueInput
    update: XOR<AssessmentUpdateWithoutSubjectInput, AssessmentUncheckedUpdateWithoutSubjectInput>
    create: XOR<AssessmentCreateWithoutSubjectInput, AssessmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssessmentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AssessmentWhereUniqueInput
    data: XOR<AssessmentUpdateWithoutSubjectInput, AssessmentUncheckedUpdateWithoutSubjectInput>
  }

  export type AssessmentUpdateManyWithWhereWithoutSubjectInput = {
    where: AssessmentScalarWhereInput
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AssessmentScalarWhereInput = {
    AND?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    OR?: AssessmentScalarWhereInput[]
    NOT?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    id?: StringFilter<"Assessment"> | string
    SubjectId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeNullableFilter<"Assessment"> | $Enums.AssessmentType | null
    method?: StringFilter<"Assessment"> | string
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
  }

  export type LearningOutcomeUpsertWithWhereUniqueWithoutSubjectInput = {
    where: LearningOutcomeWhereUniqueInput
    update: XOR<LearningOutcomeUpdateWithoutSubjectInput, LearningOutcomeUncheckedUpdateWithoutSubjectInput>
    create: XOR<LearningOutcomeCreateWithoutSubjectInput, LearningOutcomeUncheckedCreateWithoutSubjectInput>
  }

  export type LearningOutcomeUpdateWithWhereUniqueWithoutSubjectInput = {
    where: LearningOutcomeWhereUniqueInput
    data: XOR<LearningOutcomeUpdateWithoutSubjectInput, LearningOutcomeUncheckedUpdateWithoutSubjectInput>
  }

  export type LearningOutcomeUpdateManyWithWhereWithoutSubjectInput = {
    where: LearningOutcomeScalarWhereInput
    data: XOR<LearningOutcomeUpdateManyMutationInput, LearningOutcomeUncheckedUpdateManyWithoutSubjectInput>
  }

  export type LearningOutcomeScalarWhereInput = {
    AND?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
    OR?: LearningOutcomeScalarWhereInput[]
    NOT?: LearningOutcomeScalarWhereInput | LearningOutcomeScalarWhereInput[]
    id?: StringFilter<"LearningOutcome"> | string
    SubjectId?: StringFilter<"LearningOutcome"> | string
    learningHours?: IntNullableFilter<"LearningOutcome"> | number | null
    description?: StringNullableFilter<"LearningOutcome"> | string | null
    createdAt?: DateTimeFilter<"LearningOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"LearningOutcome"> | Date | string
  }

  export type IndicativeContentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: IndicativeContentWhereUniqueInput
    update: XOR<IndicativeContentUpdateWithoutSubjectInput, IndicativeContentUncheckedUpdateWithoutSubjectInput>
    create: XOR<IndicativeContentCreateWithoutSubjectInput, IndicativeContentUncheckedCreateWithoutSubjectInput>
  }

  export type IndicativeContentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: IndicativeContentWhereUniqueInput
    data: XOR<IndicativeContentUpdateWithoutSubjectInput, IndicativeContentUncheckedUpdateWithoutSubjectInput>
  }

  export type IndicativeContentUpdateManyWithWhereWithoutSubjectInput = {
    where: IndicativeContentScalarWhereInput
    data: XOR<IndicativeContentUpdateManyMutationInput, IndicativeContentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type IndicativeContentScalarWhereInput = {
    AND?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
    OR?: IndicativeContentScalarWhereInput[]
    NOT?: IndicativeContentScalarWhereInput | IndicativeContentScalarWhereInput[]
    id?: StringFilter<"IndicativeContent"> | string
    learningOutcomeId?: StringFilter<"IndicativeContent"> | string
    content?: StringFilter<"IndicativeContent"> | string
  }

  export type SkillUpsertWithWhereUniqueWithoutSubjectInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutSubjectInput, SkillUncheckedUpdateWithoutSubjectInput>
    create: XOR<SkillCreateWithoutSubjectInput, SkillUncheckedCreateWithoutSubjectInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutSubjectInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutSubjectInput, SkillUncheckedUpdateWithoutSubjectInput>
  }

  export type SkillUpdateManyWithWhereWithoutSubjectInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: StringFilter<"Skill"> | string
    SubjectId?: StringNullableFilter<"Skill"> | string | null
    description?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
  }

  export type AttitudeUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AttitudeWhereUniqueInput
    update: XOR<AttitudeUpdateWithoutSubjectInput, AttitudeUncheckedUpdateWithoutSubjectInput>
    create: XOR<AttitudeCreateWithoutSubjectInput, AttitudeUncheckedCreateWithoutSubjectInput>
  }

  export type AttitudeUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AttitudeWhereUniqueInput
    data: XOR<AttitudeUpdateWithoutSubjectInput, AttitudeUncheckedUpdateWithoutSubjectInput>
  }

  export type AttitudeUpdateManyWithWhereWithoutSubjectInput = {
    where: AttitudeScalarWhereInput
    data: XOR<AttitudeUpdateManyMutationInput, AttitudeUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AttitudeScalarWhereInput = {
    AND?: AttitudeScalarWhereInput | AttitudeScalarWhereInput[]
    OR?: AttitudeScalarWhereInput[]
    NOT?: AttitudeScalarWhereInput | AttitudeScalarWhereInput[]
    id?: StringFilter<"Attitude"> | string
    SubjectId?: StringNullableFilter<"Attitude"> | string | null
    description?: StringFilter<"Attitude"> | string
    createdAt?: DateTimeFilter<"Attitude"> | Date | string
    updatedAt?: DateTimeFilter<"Attitude"> | Date | string
  }

  export type ClassUpsertWithoutSubjectInput = {
    update: XOR<ClassUpdateWithoutSubjectInput, ClassUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassCreateWithoutSubjectInput, ClassUncheckedCreateWithoutSubjectInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubjectInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubjectInput, ClassUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassRoomUpsertWithoutSubjectInput = {
    update: XOR<ClassRoomUpdateWithoutSubjectInput, ClassRoomUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassRoomCreateWithoutSubjectInput, ClassRoomUncheckedCreateWithoutSubjectInput>
    where?: ClassRoomWhereInput
  }

  export type ClassRoomUpdateToOneWithWhereWithoutSubjectInput = {
    where?: ClassRoomWhereInput
    data: XOR<ClassRoomUpdateWithoutSubjectInput, ClassRoomUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassRoomUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trade?: TradeUpdateOneWithoutClassRoomNestedInput
    sector?: SectorUpdateOneWithoutClassRoomNestedInput
    Class?: ClassUpdateManyWithoutClassTeacherNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutSubjectInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutSubjectInput, NoteUncheckedUpdateWithoutSubjectInput>
    create: XOR<NoteCreateWithoutSubjectInput, NoteUncheckedCreateWithoutSubjectInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutSubjectInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutSubjectInput, NoteUncheckedUpdateWithoutSubjectInput>
  }

  export type NoteUpdateManyWithWhereWithoutSubjectInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutSubjectInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    subjectId?: StringFilter<"Note"> | string
    seenBy?: StringNullableListFilter<"Note">
    commentsIds?: StringNullableListFilter<"Note">
    fileId?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    description?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type ModelUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutSubjectInput, ModelUncheckedUpdateWithoutSubjectInput>
    create: XOR<ModelCreateWithoutSubjectInput, ModelUncheckedCreateWithoutSubjectInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutSubjectInput, ModelUncheckedUpdateWithoutSubjectInput>
  }

  export type ModelUpdateManyWithWhereWithoutSubjectInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutSubjectInput>
  }

  export type IndicativeContentCreateWithoutLearningOutcomeInput = {
    id?: string
    content: string
    subject?: SubjectCreateNestedOneWithoutIndicativeContentInput
  }

  export type IndicativeContentUncheckedCreateWithoutLearningOutcomeInput = {
    id?: string
    content: string
  }

  export type IndicativeContentCreateOrConnectWithoutLearningOutcomeInput = {
    where: IndicativeContentWhereUniqueInput
    create: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput>
  }

  export type IndicativeContentCreateManyLearningOutcomeInputEnvelope = {
    data: IndicativeContentCreateManyLearningOutcomeInput | IndicativeContentCreateManyLearningOutcomeInput[]
  }

  export type SubjectCreateWithoutLearningOutcomeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutLearningOutcomeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutLearningOutcomeInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutLearningOutcomeInput, SubjectUncheckedCreateWithoutLearningOutcomeInput>
  }

  export type IndicativeContentUpsertWithWhereUniqueWithoutLearningOutcomeInput = {
    where: IndicativeContentWhereUniqueInput
    update: XOR<IndicativeContentUpdateWithoutLearningOutcomeInput, IndicativeContentUncheckedUpdateWithoutLearningOutcomeInput>
    create: XOR<IndicativeContentCreateWithoutLearningOutcomeInput, IndicativeContentUncheckedCreateWithoutLearningOutcomeInput>
  }

  export type IndicativeContentUpdateWithWhereUniqueWithoutLearningOutcomeInput = {
    where: IndicativeContentWhereUniqueInput
    data: XOR<IndicativeContentUpdateWithoutLearningOutcomeInput, IndicativeContentUncheckedUpdateWithoutLearningOutcomeInput>
  }

  export type IndicativeContentUpdateManyWithWhereWithoutLearningOutcomeInput = {
    where: IndicativeContentScalarWhereInput
    data: XOR<IndicativeContentUpdateManyMutationInput, IndicativeContentUncheckedUpdateManyWithoutLearningOutcomeInput>
  }

  export type SubjectUpsertWithoutLearningOutcomeInput = {
    update: XOR<SubjectUpdateWithoutLearningOutcomeInput, SubjectUncheckedUpdateWithoutLearningOutcomeInput>
    create: XOR<SubjectCreateWithoutLearningOutcomeInput, SubjectUncheckedCreateWithoutLearningOutcomeInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutLearningOutcomeInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutLearningOutcomeInput, SubjectUncheckedUpdateWithoutLearningOutcomeInput>
  }

  export type SubjectUpdateWithoutLearningOutcomeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutLearningOutcomeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateWithoutIndicativeContentInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutIndicativeContentInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutIndicativeContentInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutIndicativeContentInput, SubjectUncheckedCreateWithoutIndicativeContentInput>
  }

  export type LearningOutcomeCreateWithoutIndicativeContentInput = {
    id?: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutLearningOutcomeInput
  }

  export type LearningOutcomeUncheckedCreateWithoutIndicativeContentInput = {
    id?: string
    SubjectId: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningOutcomeCreateOrConnectWithoutIndicativeContentInput = {
    where: LearningOutcomeWhereUniqueInput
    create: XOR<LearningOutcomeCreateWithoutIndicativeContentInput, LearningOutcomeUncheckedCreateWithoutIndicativeContentInput>
  }

  export type SubjectUpsertWithoutIndicativeContentInput = {
    update: XOR<SubjectUpdateWithoutIndicativeContentInput, SubjectUncheckedUpdateWithoutIndicativeContentInput>
    create: XOR<SubjectCreateWithoutIndicativeContentInput, SubjectUncheckedCreateWithoutIndicativeContentInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutIndicativeContentInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutIndicativeContentInput, SubjectUncheckedUpdateWithoutIndicativeContentInput>
  }

  export type SubjectUpdateWithoutIndicativeContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutIndicativeContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type LearningOutcomeUpsertWithoutIndicativeContentInput = {
    update: XOR<LearningOutcomeUpdateWithoutIndicativeContentInput, LearningOutcomeUncheckedUpdateWithoutIndicativeContentInput>
    create: XOR<LearningOutcomeCreateWithoutIndicativeContentInput, LearningOutcomeUncheckedCreateWithoutIndicativeContentInput>
    where?: LearningOutcomeWhereInput
  }

  export type LearningOutcomeUpdateToOneWithWhereWithoutIndicativeContentInput = {
    where?: LearningOutcomeWhereInput
    data: XOR<LearningOutcomeUpdateWithoutIndicativeContentInput, LearningOutcomeUncheckedUpdateWithoutIndicativeContentInput>
  }

  export type LearningOutcomeUpdateWithoutIndicativeContentInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutLearningOutcomeNestedInput
  }

  export type LearningOutcomeUncheckedUpdateWithoutIndicativeContentInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateWithoutKnowledgeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutKnowledgeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutKnowledgeInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutKnowledgeInput, SubjectUncheckedCreateWithoutKnowledgeInput>
  }

  export type SubjectUpsertWithoutKnowledgeInput = {
    update: XOR<SubjectUpdateWithoutKnowledgeInput, SubjectUncheckedUpdateWithoutKnowledgeInput>
    create: XOR<SubjectCreateWithoutKnowledgeInput, SubjectUncheckedCreateWithoutKnowledgeInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutKnowledgeInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutKnowledgeInput, SubjectUncheckedUpdateWithoutKnowledgeInput>
  }

  export type SubjectUpdateWithoutKnowledgeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutKnowledgeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateWithoutSkillInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutSkillInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutSkillInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSkillInput, SubjectUncheckedCreateWithoutSkillInput>
  }

  export type SubjectUpsertWithoutSkillInput = {
    update: XOR<SubjectUpdateWithoutSkillInput, SubjectUncheckedUpdateWithoutSkillInput>
    create: XOR<SubjectCreateWithoutSkillInput, SubjectUncheckedCreateWithoutSkillInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutSkillInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutSkillInput, SubjectUncheckedUpdateWithoutSkillInput>
  }

  export type SubjectUpdateWithoutSkillInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutSkillInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateWithoutAttitudeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAttitudeInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAttitudeInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAttitudeInput, SubjectUncheckedCreateWithoutAttitudeInput>
  }

  export type SubjectUpsertWithoutAttitudeInput = {
    update: XOR<SubjectUpdateWithoutAttitudeInput, SubjectUncheckedUpdateWithoutAttitudeInput>
    create: XOR<SubjectCreateWithoutAttitudeInput, SubjectUncheckedCreateWithoutAttitudeInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAttitudeInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAttitudeInput, SubjectUncheckedUpdateWithoutAttitudeInput>
  }

  export type SubjectUpdateWithoutAttitudeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAttitudeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateWithoutResourceInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutResourceInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutResourceInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutResourceInput, SubjectUncheckedCreateWithoutResourceInput>
  }

  export type SubjectUpsertWithoutResourceInput = {
    update: XOR<SubjectUpdateWithoutResourceInput, SubjectUncheckedUpdateWithoutResourceInput>
    create: XOR<SubjectCreateWithoutResourceInput, SubjectUncheckedCreateWithoutResourceInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutResourceInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutResourceInput, SubjectUncheckedUpdateWithoutResourceInput>
  }

  export type SubjectUpdateWithoutResourceInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutResourceInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type PerformanceCriteriaCreateWithoutCompetenceInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCriteriaUncheckedCreateWithoutCompetenceInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCriteriaCreateOrConnectWithoutCompetenceInput = {
    where: PerformanceCriteriaWhereUniqueInput
    create: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput>
  }

  export type PerformanceCriteriaCreateManyCompetenceInputEnvelope = {
    data: PerformanceCriteriaCreateManyCompetenceInput | PerformanceCriteriaCreateManyCompetenceInput[]
  }

  export type SubjectCreateWithoutCompetenceInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCompetenceInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCompetenceInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCompetenceInput, SubjectUncheckedCreateWithoutCompetenceInput>
  }

  export type PerformanceCriteriaUpsertWithWhereUniqueWithoutCompetenceInput = {
    where: PerformanceCriteriaWhereUniqueInput
    update: XOR<PerformanceCriteriaUpdateWithoutCompetenceInput, PerformanceCriteriaUncheckedUpdateWithoutCompetenceInput>
    create: XOR<PerformanceCriteriaCreateWithoutCompetenceInput, PerformanceCriteriaUncheckedCreateWithoutCompetenceInput>
  }

  export type PerformanceCriteriaUpdateWithWhereUniqueWithoutCompetenceInput = {
    where: PerformanceCriteriaWhereUniqueInput
    data: XOR<PerformanceCriteriaUpdateWithoutCompetenceInput, PerformanceCriteriaUncheckedUpdateWithoutCompetenceInput>
  }

  export type PerformanceCriteriaUpdateManyWithWhereWithoutCompetenceInput = {
    where: PerformanceCriteriaScalarWhereInput
    data: XOR<PerformanceCriteriaUpdateManyMutationInput, PerformanceCriteriaUncheckedUpdateManyWithoutCompetenceInput>
  }

  export type PerformanceCriteriaScalarWhereInput = {
    AND?: PerformanceCriteriaScalarWhereInput | PerformanceCriteriaScalarWhereInput[]
    OR?: PerformanceCriteriaScalarWhereInput[]
    NOT?: PerformanceCriteriaScalarWhereInput | PerformanceCriteriaScalarWhereInput[]
    id?: StringFilter<"PerformanceCriteria"> | string
    competenceId?: StringFilter<"PerformanceCriteria"> | string
    description?: StringFilter<"PerformanceCriteria"> | string
    createdAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceCriteria"> | Date | string
  }

  export type SubjectUpsertWithoutCompetenceInput = {
    update: XOR<SubjectUpdateWithoutCompetenceInput, SubjectUncheckedUpdateWithoutCompetenceInput>
    create: XOR<SubjectCreateWithoutCompetenceInput, SubjectUncheckedCreateWithoutCompetenceInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutCompetenceInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutCompetenceInput, SubjectUncheckedUpdateWithoutCompetenceInput>
  }

  export type SubjectUpdateWithoutCompetenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCompetenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type CompetenceCreateWithoutPerformanceCriteriaInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: SubjectCreateNestedOneWithoutCompetenceInput
  }

  export type CompetenceUncheckedCreateWithoutPerformanceCriteriaInput = {
    id?: string
    SubjectId: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetenceCreateOrConnectWithoutPerformanceCriteriaInput = {
    where: CompetenceWhereUniqueInput
    create: XOR<CompetenceCreateWithoutPerformanceCriteriaInput, CompetenceUncheckedCreateWithoutPerformanceCriteriaInput>
  }

  export type CompetenceUpsertWithoutPerformanceCriteriaInput = {
    update: XOR<CompetenceUpdateWithoutPerformanceCriteriaInput, CompetenceUncheckedUpdateWithoutPerformanceCriteriaInput>
    create: XOR<CompetenceCreateWithoutPerformanceCriteriaInput, CompetenceUncheckedCreateWithoutPerformanceCriteriaInput>
    where?: CompetenceWhereInput
  }

  export type CompetenceUpdateToOneWithWhereWithoutPerformanceCriteriaInput = {
    where?: CompetenceWhereInput
    data: XOR<CompetenceUpdateWithoutPerformanceCriteriaInput, CompetenceUncheckedUpdateWithoutPerformanceCriteriaInput>
  }

  export type CompetenceUpdateWithoutPerformanceCriteriaInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateWithoutPerformanceCriteriaInput = {
    SubjectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateWithoutAssessmentInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAssessmentInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAssessmentInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAssessmentInput, SubjectUncheckedCreateWithoutAssessmentInput>
  }

  export type SubjectUpsertWithoutAssessmentInput = {
    update: XOR<SubjectUpdateWithoutAssessmentInput, SubjectUncheckedUpdateWithoutAssessmentInput>
    create: XOR<SubjectCreateWithoutAssessmentInput, SubjectUncheckedCreateWithoutAssessmentInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAssessmentInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAssessmentInput, SubjectUncheckedUpdateWithoutAssessmentInput>
  }

  export type SubjectUpdateWithoutAssessmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAssessmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateWithoutNoteInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Model?: ModelCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutNoteInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Model?: ModelUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutNoteInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutNoteInput, SubjectUncheckedCreateWithoutNoteInput>
  }

  export type SubjectUpsertWithoutNoteInput = {
    update: XOR<SubjectUpdateWithoutNoteInput, SubjectUncheckedUpdateWithoutNoteInput>
    create: XOR<SubjectCreateWithoutNoteInput, SubjectUncheckedCreateWithoutNoteInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutNoteInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutNoteInput, SubjectUncheckedUpdateWithoutNoteInput>
  }

  export type SubjectUpdateWithoutNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ClassCreateWithoutModelInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentCreateNestedManyWithoutClassInput
    SubClass?: SubClassCreateNestedManyWithoutClassInput
    trade?: TradeCreateNestedOneWithoutClassInput
    sector?: SectorCreateNestedOneWithoutClassInput
    user?: UserCreateNestedOneWithoutClassInput
    classTeacher?: ClassRoomCreateNestedOneWithoutClassInput
    Post?: PostCreateNestedManyWithoutClassInput
    Subject?: SubjectCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutModelInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Student?: StudentUncheckedCreateNestedManyWithoutClassInput
    SubClass?: SubClassUncheckedCreateNestedManyWithoutClassInput
    Post?: PostUncheckedCreateNestedManyWithoutClassInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutModelInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutModelInput, ClassUncheckedCreateWithoutModelInput>
  }

  export type SubjectCreateWithoutModelInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutSubjectInput
    Resource?: ResourceCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentCreateNestedManyWithoutSubjectInput
    Skill?: SkillCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeCreateNestedManyWithoutSubjectInput
    class?: ClassCreateNestedOneWithoutSubjectInput
    classRoom?: ClassRoomCreateNestedOneWithoutSubjectInput
    Note?: NoteCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutModelInput = {
    id?: string
    name: string
    classRoomId?: string | null
    classId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutSubjectInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutSubjectInput
    Competence?: CompetenceUncheckedCreateNestedManyWithoutSubjectInput
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutSubjectInput
    LearningOutcome?: LearningOutcomeUncheckedCreateNestedManyWithoutSubjectInput
    IndicativeContent?: IndicativeContentUncheckedCreateNestedManyWithoutSubjectInput
    Skill?: SkillUncheckedCreateNestedManyWithoutSubjectInput
    Attitude?: AttitudeUncheckedCreateNestedManyWithoutSubjectInput
    Note?: NoteUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutModelInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutModelInput, SubjectUncheckedCreateWithoutModelInput>
  }

  export type ClassUpsertWithoutModelInput = {
    update: XOR<ClassUpdateWithoutModelInput, ClassUncheckedUpdateWithoutModelInput>
    create: XOR<ClassCreateWithoutModelInput, ClassUncheckedCreateWithoutModelInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutModelInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutModelInput, ClassUncheckedUpdateWithoutModelInput>
  }

  export type ClassUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutModelInput = {
    update: XOR<SubjectUpdateWithoutModelInput, SubjectUncheckedUpdateWithoutModelInput>
    create: XOR<SubjectCreateWithoutModelInput, SubjectUncheckedCreateWithoutModelInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutModelInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutModelInput, SubjectUncheckedUpdateWithoutModelInput>
  }

  export type SubjectUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthenticatorCreateManyUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type StudentCreateManyUserInput = {
    id?: string
    subClassId?: string | null
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateManyUserInput = {
    id?: string
    classesId?: TeacherCreateclassesIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyUserInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    classRoomId?: string | null
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyUserInput = {
    id?: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    classId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorUpdateWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpdateWithoutUserInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyWithoutUserInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpdateWithoutUserInput = {
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyWithoutUserInput = {
    classesId?: TeacherUpdateclassesIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutUserInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorCreateManyEducationInput = {
    id?: string
    username: string
    name: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManySectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    limitClasses: number
    symbol?: string | null
    disabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorUpdateWithoutEducationInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUpdateManyWithoutSectorNestedInput
    Class?: ClassUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateWithoutEducationInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutSectorNestedInput
    Class?: ClassUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateManyWithoutEducationInput = {
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUpdateManyWithoutTradeNestedInput
    Class?: ClassUpdateManyWithoutTradeNestedInput
  }

  export type TradeUncheckedUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ClassRoom?: ClassRoomUncheckedUpdateManyWithoutTradeNestedInput
    Class?: ClassUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type TradeUncheckedUpdateManyWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    limitClasses?: IntFieldUpdateOperationsInput | number
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassRoomCreateManySectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    tradeId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManySectorInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    tradeId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassRoomUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trade?: TradeUpdateOneWithoutClassRoomNestedInput
    Class?: ClassUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateManyWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSectorInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassRoomCreateManyTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    symbol?: string | null
    disabled?: boolean
    ClassRoomType?: $Enums.ClassRoomType
    sectorId?: string | null
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyTradeInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    classRoomId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassRoomUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: SectorUpdateOneWithoutClassRoomNestedInput
    Class?: ClassUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Class?: ClassUncheckedUpdateManyWithoutClassTeacherNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateManyWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    ClassRoomType?: EnumClassRoomTypeFieldUpdateOperationsInput | $Enums.ClassRoomType
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    classTeacher?: ClassRoomUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTradeInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManyClassTeacherInput = {
    id?: string
    name: string
    username: string
    description?: string | null
    code: string
    symbol?: string | null
    disabled?: boolean
    sectorId?: string | null
    tradeId?: string | null
    userId: string
    classType?: $Enums.ClassType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyClassRoomInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutClassTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUpdateManyWithoutClassNestedInput
    trade?: TradeUpdateOneWithoutClassNestedInput
    sector?: SectorUpdateOneWithoutClassNestedInput
    user?: UserUpdateOneWithoutClassNestedInput
    Post?: PostUpdateManyWithoutClassNestedInput
    Subject?: SubjectUpdateManyWithoutClassNestedInput
    Model?: ModelUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateManyWithoutClassNestedInput
    SubClass?: SubClassUncheckedUpdateManyWithoutClassNestedInput
    Post?: PostUncheckedUpdateManyWithoutClassNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutClassNestedInput
    Model?: ModelUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutClassTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    classType?: NullableEnumClassTypeFieldUpdateOperationsInput | $Enums.ClassType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    class?: ClassUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    userId: string
    subClassId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubClassCreateManyClassInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyClassInput = {
    id?: string
    userId: string
    file?: string | null
    content?: string | null
    role?: $Enums.PostRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyClassInput = {
    id?: string
    name: string
    classRoomId?: string | null
    code: string
    sectorId?: string | null
    tradeId?: string | null
    subjectType?: $Enums.SubjectType | null
    curriculum?: string | null
    copyright?: string | null
    learningHours?: number | null
    issueDate?: Date | string | null
    purpose?: string | null
    symbol?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCreateManyClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutClassInput = {
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subClassId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassUpdateWithoutClassInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassUncheckedUpdateWithoutClassInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubClassUncheckedUpdateManyWithoutClassInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutClassInput = {
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumPostRoleFieldUpdateOperationsInput | $Enums.PostRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUpdateManyWithoutSubjectNestedInput
    classRoom?: ClassRoomUpdateOneWithoutSubjectNestedInput
    Note?: NoteUpdateManyWithoutSubjectNestedInput
    Model?: ModelUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutSubjectNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutSubjectNestedInput
    Competence?: CompetenceUncheckedUpdateManyWithoutSubjectNestedInput
    Assessment?: AssessmentUncheckedUpdateManyWithoutSubjectNestedInput
    LearningOutcome?: LearningOutcomeUncheckedUpdateManyWithoutSubjectNestedInput
    IndicativeContent?: IndicativeContentUncheckedUpdateManyWithoutSubjectNestedInput
    Skill?: SkillUncheckedUpdateManyWithoutSubjectNestedInput
    Attitude?: AttitudeUncheckedUpdateManyWithoutSubjectNestedInput
    Note?: NoteUncheckedUpdateManyWithoutSubjectNestedInput
    Model?: ModelUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    classRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    sectorId?: NullableStringFieldUpdateOperationsInput | string | null
    tradeId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectType?: NullableEnumSubjectTypeFieldUpdateOperationsInput | $Enums.SubjectType | null
    curriculum?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUpdateWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: SubjectUpdateOneRequiredWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUncheckedUpdateManyWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateManySubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateManySubjectInput = {
    id?: string
    category?: $Enums.ResourceType | null
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetenceCreateManySubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentCreateManySubjectInput = {
    id?: string
    type?: $Enums.AssessmentType | null
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningOutcomeCreateManySubjectInput = {
    id?: string
    learningHours?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicativeContentCreateManySubjectInput = {
    id?: string
    content: string
  }

  export type SkillCreateManySubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttitudeCreateManySubjectInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManySubjectInput = {
    id?: string
    userId: string
    seenBy?: NoteCreateseenByInput | string[]
    commentsIds?: NoteCreatecommentsIdsInput | string[]
    fileId?: string | null
    content: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCreateManySubjectInput = {
    id?: string
    teacherId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateManyWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpdateWithoutSubjectInput = {
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateWithoutSubjectInput = {
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyWithoutSubjectInput = {
    category?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetenceUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PerformanceCriteria?: PerformanceCriteriaUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PerformanceCriteria?: PerformanceCriteriaUncheckedUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateManyWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUpdateWithoutSubjectInput = {
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateWithoutSubjectInput = {
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateManyWithoutSubjectInput = {
    type?: NullableEnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType | null
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningOutcomeUpdateWithoutSubjectInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicativeContent?: IndicativeContentUpdateManyWithoutLearningOutcomeNestedInput
  }

  export type LearningOutcomeUncheckedUpdateWithoutSubjectInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicativeContent?: IndicativeContentUncheckedUpdateManyWithoutLearningOutcomeNestedInput
  }

  export type LearningOutcomeUncheckedUpdateManyWithoutSubjectInput = {
    learningHours?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicativeContentUpdateWithoutSubjectInput = {
    content?: StringFieldUpdateOperationsInput | string
    LearningOutcome?: LearningOutcomeUpdateOneRequiredWithoutIndicativeContentNestedInput
  }

  export type IndicativeContentUncheckedUpdateWithoutSubjectInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type IndicativeContentUncheckedUpdateManyWithoutSubjectInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type SkillUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeUncheckedUpdateWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttitudeUncheckedUpdateManyWithoutSubjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutSubjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateWithoutSubjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutSubjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seenBy?: NoteUpdateseenByInput | string[]
    commentsIds?: NoteUpdatecommentsIdsInput | string[]
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUpdateWithoutSubjectInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutSubjectInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUncheckedUpdateManyWithoutSubjectInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicativeContentCreateManyLearningOutcomeInput = {
    id?: string
    content: string
  }

  export type IndicativeContentUpdateWithoutLearningOutcomeInput = {
    content?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneWithoutIndicativeContentNestedInput
  }

  export type IndicativeContentUncheckedUpdateWithoutLearningOutcomeInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type IndicativeContentUncheckedUpdateManyWithoutLearningOutcomeInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceCriteriaCreateManyCompetenceInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCriteriaUpdateWithoutCompetenceInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCriteriaUncheckedUpdateWithoutCompetenceInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCriteriaUncheckedUpdateManyWithoutCompetenceInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}